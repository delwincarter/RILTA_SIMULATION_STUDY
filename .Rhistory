message("README.md created successfully!")
# Step 4: Prepare Word document content
doc <- read_docx()
doc <- body_add_par(doc, "Project Directory Overview", style = "heading 1")
# Main folder contents
doc <- body_add_par(doc, "Main Folder Contents", style = "heading 2")
doc <- body_add_par(doc, paste("- ", main_contents, collapse = "\n"), style = "Normal")
# 2 Time Points folder
doc <- body_add_par(doc, "2 Time Points Folder Contents", style = "heading 2")
doc <- body_add_par(doc, paste("- ", two_time_points, collapse = "\n"), style = "Normal")
# 3 Time Points folder
doc <- body_add_par(doc, "3 Time Points Folder Contents", style = "heading 2")
doc <- body_add_par(doc, paste("- ", three_time_points, collapse = "\n"), style = "Normal")
# Descriptions for "2 Time Points" subfolders
doc <- body_add_par(doc, "Descriptions of Subfolders: 2 Time Points", style = "heading 2")
for (folder in two_time_points) {
description <- if (grepl("^\\d_", folder)) {
"Contains input, output, and CSV files for simulation runs."
} else if (grepl("^zFigures", folder)) {
"Contains generated figures for analyses."
} else if (grepl("^zHeatmaps", folder)) {
"Contains heatmaps visualizing simulation results."
} else if (grepl("^zViolator", folder)) {
"Contains plots highlighting label switching or other violations."
} else {
"General folder for analysis."
}
doc <- body_add_par(doc, paste("- ", folder, ":", description), style = "Normal")
}
# Descriptions for "3 Time Points" subfolders
doc <- body_add_par(doc, "Descriptions of Subfolders: 3 Time Points", style = "heading 2")
for (folder in three_time_points) {
description <- if (grepl("^\\d_", folder)) {
"Contains input, output, and CSV files for simulation runs."
} else if (grepl("^zFigures", folder)) {
"Contains generated figures for analyses."
} else if (grepl("^zHeatmaps", folder)) {
"Contains heatmaps visualizing simulation results."
} else if (grepl("^zViolator", folder)) {
"Contains plots highlighting label switching or other violations."
} else {
"General folder for analysis."
}
doc <- body_add_par(doc, paste("- ", folder, ":", description), style = "Normal")
}
# Save the Word document
print(doc, target = file.path(root_dir, doc_file))
message("Documentation created successfully at: ", file.path(root_dir, doc_file))
}
# Run the script
generate_readme_and_doc()
library(officer)
generate_readme_and_doc <- function(root_dir = ".", readme_file = "README.md", doc_file = "_RILTA 1 (k = 2) _ STARTS Project_Documentation.docx") {
# Step 1: List main folder contents
main_contents <- list.files(root_dir, full.names = FALSE)
# Step 2: List subfolders in "2 Time Points" and "3 Time Points"
two_time_points <- list.files(file.path(root_dir, "2 Time Points"), full.names = FALSE)
three_time_points <- list.files(file.path(root_dir, "3 Time Points"), full.names = FALSE)
# Step 3: Prepare README.md content
readme_lines <- c(
"# Project Directory Overview",
"",
"## Main Folder Contents",
paste("- ", main_contents),
"",
"## 2 Time Points Folder Contents",
paste("- ", two_time_points),
"",
"## 3 Time Points Folder Contents",
paste("- ", three_time_points),
"",
"## Descriptions of Subfolders",
"### 2 Time Points Subfolders"
)
# Add descriptions for subfolders in "2 Time Points"
for (folder in two_time_points) {
description <- if (grepl("^\\d_", folder)) {
"Contains input, output, and CSV files for simulation runs."
} else if (grepl("^zFigures", folder)) {
"Contains generated figures for analyses."
} else if (grepl("^zHeatmaps", folder)) {
"Contains heatmaps visualizing simulation results."
} else if (grepl("^zViolator", folder)) {
"Contains plots highlighting label switching or other violations."
} else {
"General folder for analysis."
}
readme_lines <- c(readme_lines, paste("- **", folder, "**:", description))
}
# Add descriptions for subfolders in "3 Time Points"
readme_lines <- c(readme_lines, "### 3 Time Points Subfolders")
for (folder in three_time_points) {
description <- if (grepl("^\\d_", folder)) {
"Contains input, output, and CSV files for simulation runs."
} else if (grepl("^zFigures", folder)) {
"Contains generated figures for analyses."
} else if (grepl("^zHeatmaps", folder)) {
"Contains heatmaps visualizing simulation results."
} else if (grepl("^zViolator", folder)) {
"Contains plots highlighting label switching or other violations."
} else {
"General folder for analysis."
}
readme_lines <- c(readme_lines, paste("- **", folder, "**:", description))
}
# Write README.md
writeLines(readme_lines, file.path(root_dir, readme_file))
message("README.md created successfully!")
# Step 4: Prepare Word document content
doc <- read_docx()
doc <- body_add_par(doc, "Project Directory Overview", style = "heading 1")
# Main folder contents
doc <- body_add_par(doc, "Main Folder Contents", style = "heading 2")
doc <- body_add_par(doc, paste("- ", main_contents, collapse = "\n"), style = "Normal")
# 2 Time Points folder
doc <- body_add_par(doc, "2 Time Points Folder Contents", style = "heading 2")
doc <- body_add_par(doc, paste("- ", two_time_points, collapse = "\n"), style = "Normal")
# 3 Time Points folder
doc <- body_add_par(doc, "3 Time Points Folder Contents", style = "heading 2")
doc <- body_add_par(doc, paste("- ", three_time_points, collapse = "\n"), style = "Normal")
# Descriptions for "2 Time Points" subfolders
doc <- body_add_par(doc, "Descriptions of Subfolders: 2 Time Points", style = "heading 2")
for (folder in two_time_points) {
description <- if (grepl("^\\d_", folder)) {
"Contains input, output, and CSV files for simulation runs."
} else if (grepl("^zFigures", folder)) {
"Contains generated figures for analyses."
} else if (grepl("^zHeatmaps", folder)) {
"Contains heatmaps visualizing simulation results."
} else if (grepl("^zViolator", folder)) {
"Contains plots highlighting label switching or other violations."
} else {
"General folder for analysis."
}
doc <- body_add_par(doc, paste("- ", folder, ":", description), style = "Normal")
}
# Descriptions for "3 Time Points" subfolders
doc <- body_add_par(doc, "Descriptions of Subfolders: 3 Time Points", style = "heading 2")
for (folder in three_time_points) {
description <- if (grepl("^\\d_", folder)) {
"Contains input, output, and CSV files for simulation runs."
} else if (grepl("^zFigures", folder)) {
"Contains generated figures for analyses."
} else if (grepl("^zHeatmaps", folder)) {
"Contains heatmaps visualizing simulation results."
} else if (grepl("^zViolator", folder)) {
"Contains plots highlighting label switching or other violations."
} else {
"General folder for analysis."
}
doc <- body_add_par(doc, paste("- ", folder, ":", description), style = "Normal")
}
# Save the Word document
print(doc, target = file.path(root_dir, doc_file))
message("Documentation created successfully at: ", file.path(root_dir, doc_file))
}
# Run the script
generate_readme_and_doc()
here::here()
#| label: "load-libraries"
#| echo: true
#| message: false
#| warning: false
library(tidyverse)
library(MplusAutomation)
library(here)
library(gt)
library(janitor)
library(glue)
library(ggtext)
library(rlang)
library(knitr)
library(parallel)
library(tools)
library(tidyr)
#| label: "scrape-csv-files-part 2"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true
# Step 1: Set the correct CSV directory
csv_directory <- here('2 Time Points', '4_2T_RILTA_GEN_RILTA_ANALYZED_REP')
# Step 2: Source the child document
source(here('Child_Docs', 'data_scraping.R'))
#| label: "scrape-rows-process-data-parallel2"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true
# Step 2: Process the data using the child script
source(here('Child_Docs', 'step2_2t_RILTA.R'))
#| label: "convert-logits-to-probabilities2"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true
# Step 3 and 4: Process the data and return results
source(here('Child_Docs', 'steps_3_and_4.R'))
# The objects `final_data_with_actuals` and `violators` should now be in the global environment
#| label: "data-processing"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true
library(parallel)
# Define helper functions
extract_errors_from_file <- function(filepath) {
lines <- readLines(filepath)
error_keywords <- c("SINGULARITY", "NON-POSITIVE DEFINITE")
# Step 1: Extract total replications
completed_line <- lines[grepl("Completed", lines, ignore.case = TRUE)]
total_replications <- as.integer(str_match(completed_line, "Completed\\s+(\\d+)")[, 2])
if (is.na(total_replications) || length(total_replications) == 0) total_replications <- 0
# Step 2: Initialize results
results <- tibble(
FileName = basename(filepath),
Replication = 1:total_replications,
ErrorFlag = 0,
Message = "None"
)
# Step 3: Extract errors and warnings
current_replication <- NULL
for (line in lines) {
replication_match <- str_match(line, "REPLICATION (\\d+):")
if (!is.na(replication_match[1])) {
current_replication <- as.integer(replication_match[2])
}
if (!is.null(current_replication) && any(sapply(error_keywords, grepl, line, ignore.case = TRUE))) {
results <- results %>%
mutate(
ErrorFlag = if_else(Replication == current_replication, 1, ErrorFlag),
Message = if_else(Replication == current_replication,
paste0(Message, "; ", str_trim(line)),
Message
)
)
}
}
# Step 4: Clean messages
results <- results %>%
mutate(
Message = if_else(Message == "None", "No Errors or Warnings", Message)
)
return(results)
}
extract_completed_replications <- function(filepath) {
lines <- readLines(filepath)
completed_line <- lines[grepl("Completed", lines, ignore.case = TRUE)]
completed <- as.integer(str_match(completed_line, "Completed\\s+(\\d+)")[, 2])
if (length(completed) == 0) completed <- 0
tibble(FileName = basename(filepath), CompletedReplications = completed)
}
extract_requested_replications <- function(filepath) {
lines <- readLines(filepath)
requested_line <- lines[grepl("Requested", lines, ignore.case = TRUE)]
requested <- as.integer(str_match(requested_line, "Requested\\s+(\\d+)")[, 2])
if (length(requested) == 0) requested <- 0
tibble(FileName = basename(filepath), RequestedReplications = requested)
}
calculate_replication_summary <- function(error_summary, completed_replications, requested_replications) {
summary <- error_summary %>%
group_by(FileName) %>%
summarise(ErrorReplications = sum(ErrorFlag), .groups = "drop") %>%  # Count flagged errors
mutate(ErrorReplications = coalesce(ErrorReplications, 0))          # Handle missing values
full_summary <- requested_replications %>%
left_join(completed_replications, by = "FileName") %>%
left_join(summary, by = "FileName") %>%
mutate(
GoodReplications = CompletedReplications - ErrorReplications,
ErrorRate = if_else(RequestedReplications > 0, (ErrorReplications / RequestedReplications) * 100, 0)
) %>%
select(FileName, CompletedReplications, RequestedReplications, ErrorReplications, GoodReplications, ErrorRate)
return(full_summary)
}
# Parallel processing
output_folder <- "4_2T_RILTA_GEN_RILTA_ANALYZED_REP"
file_list <- list.files(output_folder, pattern = "\\.out$", full.names = TRUE)
cluster_type <- ifelse(.Platform$OS.type == "windows", "PSOCK", "FORK")
num_cores <- detectCores() - 1
cl <- makeCluster(num_cores, type = cluster_type)
clusterExport(cl, c("extract_errors_from_file", "extract_completed_replications", "extract_requested_replications"))
clusterEvalQ(cl, library(tidyverse))
error_summary <- bind_rows(parLapply(cl, file_list, extract_errors_from_file))
completed_replications <- bind_rows(parLapply(cl, file_list, extract_completed_replications))
requested_replications <- bind_rows(parLapply(cl, file_list, extract_requested_replications))
stopCluster(cl)
# **Normalization: Ensure FileName consistency**
error_summary <- error_summary %>%
mutate(FileName = tolower(gsub("\\.out$", "", FileName)))
completed_replications <- completed_replications %>%
mutate(FileName = tolower(gsub("\\.out$", "", FileName)))
requested_replications <- requested_replications %>%
mutate(FileName = tolower(gsub("\\.out$", "", FileName)))
# Calculate summary
replication_summary <- calculate_replication_summary(error_summary, completed_replications, requested_replications)
#| label: "visualization"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true
if (nrow(replication_summary) > 0 && any(replication_summary$ErrorReplications > 0)) {
replication_summary_table <- replication_summary %>%
gt() %>%
tab_header(
title = "Replication Summary",
subtitle = paste0("Folder: ", output_folder)
) %>%
fmt_number(columns = vars(CompletedReplications, RequestedReplications, ErrorReplications, GoodReplications, ErrorRate), decimals = 2) %>%
cols_label(
FileName = "File Name",
CompletedReplications = "Completed Replications",
RequestedReplications = "Requested Replications",
ErrorReplications = "Replications with Errors",
GoodReplications = "Good Replications",
ErrorRate = "Error Rate (%)"
) %>%
tab_options(
table.font.size = "small",
heading.title.font.size = "medium",
heading.subtitle.font.size = "small"
)
print(replication_summary_table)
} else {
message("No errors or warnings detected. No table to display.")
}
# Normalize filenames for consistency
normalize_filenames <- function(df) {
df %>%
mutate(FileName = tolower(gsub("\\.out$", "", FileName)))  # Convert to lowercase and remove extension
}
# Normalize filenames in error_summary
error_summary <- normalize_filenames(error_summary)
# Filter out flagged errors
clean_data <- error_summary %>%
filter(ErrorFlag == 0) %>%  # Keep only rows without errors
select(FileName, Replication)  # Keep only relevant columns for clean data
# Validate the cleaned dataset
cat("Number of valid replications per file:\n")
clean_data_summary <- clean_data %>%
group_by(FileName) %>%
summarise(ValidReplications = n(), .groups = "drop")
# Step 1: Generate All Replication Numbers for Each File
all_reps <- completed_replications %>%
rowwise() %>%
mutate(Rep = list(seq_len(CompletedReplications))) %>%
unnest(cols = c(Rep))  # Create one row per replication number
# Validate all_reps creation
validation_all_reps <- all_reps %>%
group_by(FileName) %>%
summarise(
ExpectedReps = max(CompletedReplications, na.rm = TRUE),
GeneratedReps = n(),
.groups = "drop"
) %>%
filter(ExpectedReps != GeneratedReps)
if (nrow(validation_all_reps) > 0) {
warning("Mismatch detected in replication numbers for the following files:")
print(validation_all_reps)
} else {
message("Validation successful: All replication numbers are correct.")
}
# Step 2: Combine All Reps with Error Information
error_results <- all_reps %>%
left_join(
error_summary %>%
filter(ErrorFlag == 1) %>%  # Only keep rows with errors
select(FileName, Replication) %>%  # Select relevant columns
rename(Rep = Replication),  # Align column names
by = c("FileName", "Rep")
) %>%
mutate(ErrorFlag = if_else(is.na(Rep), 0, 1))  # Set ErrorFlag to 1 if error exists, else 0
# Validate error_results creation
validation_error_results <- error_results %>%
group_by(FileName) %>%
summarise(
TotalReps = n(),
ErrorFlagsAssigned = sum(!is.na(ErrorFlag)),
.groups = "drop"
) %>%
filter(TotalReps != ErrorFlagsAssigned)
if (nrow(validation_error_results) > 0) {
warning("Mismatch detected in error flag assignment for the following files:")
print(validation_error_results)
} else {
message("Validation successful: All error flags are correctly assigned.")
}
# Step 3: Merge and compute remaining values
error_summary <- error_summary %>%
# Merge CompletedReplications into error_summary
left_join(completed_replications, by = "FileName") %>%
# Calculate ErrorReplications from error_results
left_join(
error_results %>%
group_by(FileName) %>%
summarise(ErrorReplications = n_distinct(Rep[ErrorFlag == 1]), .groups = "drop"),
by = "FileName"
) %>%
# Merge RemainingReplications
left_join(remaining_replications, by = "FileName") %>%
# Compute ComputedAfterErrors
mutate(
ComputedAfterErrors = CompletedReplications - ErrorReplications,
ErrorRate = if_else(
CompletedReplications > 0,
(ErrorReplications / CompletedReplications) * 100,
0
)  # Calculate ErrorRate
)
# Step 1: Generate All Replication Numbers for Each File
all_reps <- completed_replications %>%
rowwise() %>%
mutate(Rep = list(seq_len(CompletedReplications))) %>%
unnest(cols = c(Rep))  # Create one row per replication number
# Validate all_reps creation
validation_all_reps <- all_reps %>%
group_by(FileName) %>%
summarise(
ExpectedReps = max(CompletedReplications, na.rm = TRUE),
GeneratedReps = n(),
.groups = "drop"
) %>%
filter(ExpectedReps != GeneratedReps)
if (nrow(validation_all_reps) > 0) {
warning("Mismatch detected in replication numbers for the following files:")
print(validation_all_reps)
} else {
message("Validation successful: All replication numbers are correct.")
}
# Step 2: Combine All Reps with Error Information
error_results <- all_reps %>%
left_join(
error_summary %>%
filter(ErrorFlag == 1) %>%  # Only keep rows with errors
select(FileName, Replication) %>%  # Select relevant columns
rename(Rep = Replication),  # Align column names
by = c("FileName", "Rep")
) %>%
mutate(ErrorFlag = if_else(is.na(Rep), 0, 1))  # Set ErrorFlag to 1 if error exists, else 0
# Validate error_results creation
validation_error_results <- error_results %>%
group_by(FileName) %>%
summarise(
TotalReps = n(),
ErrorFlagsAssigned = sum(!is.na(ErrorFlag)),
.groups = "drop"
) %>%
filter(TotalReps != ErrorFlagsAssigned)
if (nrow(validation_error_results) > 0) {
warning("Mismatch detected in error flag assignment for the following files:")
print(validation_error_results)
} else {
message("Validation successful: All error flags are correctly assigned.")
}
# Step 3: Calculate RemainingReplications
remaining_replications <- error_results %>%
filter(ErrorFlag == 0) %>%
group_by(FileName) %>%
summarise(RemainingReplications = n_distinct(Rep), .groups = "drop")
# Step 4: Merge and compute remaining values
error_summary <- error_summary %>%
# Merge CompletedReplications into error_summary
left_join(completed_replications, by = "FileName") %>%
# Calculate ErrorReplications from error_results
left_join(
error_results %>%
group_by(FileName) %>%
summarise(ErrorReplications = n_distinct(Rep[ErrorFlag == 1]), .groups = "drop"),
by = "FileName"
) %>%
# Merge RemainingReplications
left_join(remaining_replications, by = "FileName") %>%
# Compute ComputedAfterErrors
mutate(
ComputedAfterErrors = CompletedReplications - ErrorReplications,
ErrorRate = if_else(
CompletedReplications > 0,
(ErrorReplications / CompletedReplications) * 100,
0
)  # Calculate ErrorRate
)
#| label: "visualize_data_post_errors"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true
# Generate the summary table without RequestedReplications
error_handling_summary_table <- error_summary %>%
gt() %>%
tab_header(
title = "Error Handling Summary",
subtitle = "Summary of file-based replication after handling errors"
) %>%
cols_label(
FileName = "Output File",
CompletedReplications = "Completed Replications",
ErrorReplications = "Replications with Errors",
RemainingReplications = "Remaining Replications After Errors",
ComputedAfterErrors = "Computed Replications After Errors",
ErrorRate = "Error Rate (%)"
) %>%
fmt_number(
columns = c(CompletedReplications, ErrorReplications, RemainingReplications,
ComputedAfterErrors, ErrorRate),
decimals = 2
) %>%
tab_options(
table.font.size = "small",
heading.title.font.size = "medium",
heading.subtitle.font.size = "small"
)
# Display the table
print(error_handling_summary_table)
