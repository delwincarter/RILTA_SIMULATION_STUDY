---
title: "Understanding the Performance of Random Intercepts Latent Transition Analysis (RI-LTA): A Monte Carlo Simulation Study Using MplusAutomation"
subtitle: "Study 1.7: RILTA Generated, LTA Analyzed with Three Timepoints"
author: "Delwin Carter"
date: "`r format(Sys.time(), '%B %d, %Y')`"

format:
  html:
    toc: true
    toc-title: "Overview"
    toc-depth: 3
    toc-float:
      collapsed: false
      smooth-scroll: true
    theme: flatly
    fig-format: svg
    page-layout: full
    code-tools: true
    df-print: paged
    font:
      main: "Avenir Next"

editor: visual

knitr:
  opts_chunk:
    echo: true
    out.width: "100%"
    fig.align: "center"
---

------------------------------------------------------------------------

::: {layout-ncol="2"}
![](images/LVG%20FINAL.png){width="300"}

![](images/UCSB_Gauchos_logo_PNG2.png){width="300"}
:::

------------------------------------------------------------------------

# Introduction

## Study 1.7: RILTA Generated, LTA Analyzed

------------------------------------------------------------------------

![](images/clipboard-3308695735.png){width="350"}

------------------------------------------------------------------------

Load Packages

```{r, message=FALSE, warning=FALSE}
#| label: "load-libraries"
#| echo: true
#| message: false
#| warning: false

library(tidyverse)
library(MplusAutomation)
library(here)
library(gt)
library(janitor)
library(glue)
library(ggtext)
library(rlang)
library(knitr)
library(parallel)
library(tools)
library(webshot2)
library(webshot)
library(flextable)
library(officer)
```

# Simulation

------------------------------------------------------------------------

## Part 1: Conduct Simulation

> In this section, I am conducting a simulation where I am generating data as Latent Transition Analysis and analyzing it as Random Intercepts Latent Transition Analysis to fully explore the model's performance. The simulation consists of 144 conditions, combining four sample sizes (N = 500, 1000, 2000, 4000) with six transition probabilities linked to logits (*betas;* 1.385, .85, .41, -.41, -.85, -1.385), corresponding to probabilities of .8, .7, .6, .4, .3, and .2., and lambda loadings on the random intercept of 0, .2, .4, .6, .8, and 1. These conditions are iterated over programmatically using MplusAutomation to set up and execute the models. To speed up the process, I employ parallel processing, which distributes computations across multiple CPU cores, enabling efficient completion of the simulations across all scenarios.

Conditions:

Sample Size: N = 500, 1000, 2000, and 4000

Transition logit (probability): TPs = 1.385 (.8), .85 (.7), .41 (.6), -.41 (.4), -.85 (.3) , and -1.385 (.2)

![](images/clipboard-4066126347.png){width="544"}

RI Loadings: Lambda = 0, .2, .4, .6, .8, 1

![](images/clipboard-3621509256.png){width="450"}

### Setting up the Simulation Conditions¬†

```{r}

p1 <- expand.grid(N = c(500, 1000, 2000, 4000),
TPs = c(1.385, .85, .41, -.41, -.85, -1.385),
Lambda = c(0, .2, .4, .6, .8, 1))
       
# Display the matrix using gt
p1 %>%
  gt() %>%
  tab_header(
    title = "Simulation Conditions Matrix",
    subtitle = "Combinations of Sample Sizes, Transition Probabilities, and Mixtures"
  ) %>%
  cols_align(
    align = "center",
    columns = everything() # Centers all columns
  )
```

------------------------------------------------------------------------

### Run Initial Simulation

```{r,eval = FALSE}
#| label: "rilta-lta-simulation"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

library(parallel)
# Step 1: Create the cluster for parallel processing
num_cores <- detectCores() - 1  # Detect the number of available cores (minus 1)
cl <- makeCluster(num_cores, type = "PSOCK")  # Create the PSOCK cluster

rilta_lta_func <- function(N, TPs, Lambda) {
  
  RILTA_LTA <- mplusObject(
    TITLE = glue("Generate RILTA_LTA_N_{N}_TP_{TPs}_TH_1_Lambda_{Lambda}"),

    MONTECARLO =
      glue("NAMES = u11-u15 u21-u25 u31-u35;
      GENERATE = u11-u15 u21-u25 u31-u35(1);
      CATEGORICAL = u11-u15 u21-u25 u31-u35;
      GENCLASSES = c1(2) c2(2) c3(2);
      CLASSES = c1(2) c2(2) c3(2);
      NOBSERVATIONS = {N};
      SEED = 07252005;
      NREPS = 500;
      !!SAVE = repM1*.dat;
      RESULTS = RILTA_LTA_N_{N}_TP_{TPs}_TH_1_Lambda_{Lambda}.csv;"),
    
    ANALYSIS =
      "TYPE = MIXTURE;
      algorithm = integration;
      processors = 24;
      starts= 100 20;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    OUTPUT = "TECH9",

    MODELPOPULATION = glue("	
        %OVERALL%

        [c1#1-c3#1*0];
        c2#1 on c1#1*{TPs};
        c3#1 on c2#1*0;
      	
     f by  u11-u15*{Lambda} (p1-p5)
               u21-u25*{Lambda} (p1-p5)
               u31-u35*{Lambda} (p1-p5);
          
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
        %c1#1%
     [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);

        %c1#2%
     [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);

        %c2#2%
     [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
     
     MODEL POPULATION-c3:  
        %c3#1%
     [u31$1*1 u32$1*1 u33$1*1 u34$1*1 u35$1*1] (p111-p115);

        %c3#2%
     [u31$1*-1 u32$1*-1 u33$1*-1 u34$1*-1 u35$1*-1] (p121-p125);
       "),
     

    MODEL =
      glue("	
        %OVERALL%
          [c1#1-c3#1*0](par1-par3);
        	c2#1 on c1#1*{TPs} (par11);
        	c3#1 on c2#1*0;

     MODEL c1:
        %c1#1%
     [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);

        %c1#2%
     [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);

    MODEL c2: 	
        %c2#1%
     [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);

        %c2#2%
     [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
     
    MODEL c3:  
        %c3#1%
     [u31$1*1 u32$1*1 u33$1*1 u34$1*1 u35$1*1] (p111-p115);

        %c3#2%
     [u31$1*-1 u32$1*-1 u33$1*-1 u34$1*-1 u35$1*-1] (p121-p125);
	      "),
      

    MODELCONSTRAINT =
      if (TPs == 1.385) {
        glue("
        New(
        trans11*.80 trans12*.20 trans21*.5 trans22*.5
        prob11*.5 prob12*.5 prob21*.65 prob22*.35);
        trans11 = 1/(1+exp(-(par2+par11)));
        trans12 = 1-trans11;
        trans21 = 1/(1+exp(-par2));
        trans22 = 1- trans21;
        !marginal probabilities at T1 and T2:
        prob11 = 1/(1+exp(-par1));
        prob12 = 1 - prob11;
        prob21 = prob11*trans11+prob12*trans21;
        prob22 = 1- prob21;
        ")
      } 
             else if (TPs == .85) {
        glue("
        New(
        trans11*.70 trans12*.30 trans21*.5 trans22*.5
        prob11*.5 prob12*.5 prob21*.60 prob22*.4);
        trans11 = 1/(1+exp(-(par2+par11)));
        trans12 = 1-trans11;
        trans21 = 1/(1+exp(-par2));
        trans22 = 1- trans21;
        !marginal probabilities at T1 and T2:
        prob11 = 1/(1+exp(-par1));
        prob12 = 1 - prob11;
        prob21 = prob11*trans11+prob12*trans21;
        prob22 = 1- prob21;
        ")
              } 
            else  if (TPs == .41) {
        glue("
        New(
        trans11*.60 trans12*.40 trans21*.5 trans22*.5
        prob11*.5 prob12*.5 prob21*.55 prob22*.45);
        trans11 = 1/(1+exp(-(par2+par11)));
        trans12 = 1-trans11;
        trans21 = 1/(1+exp(-par2));
        trans22 = 1- trans21;
        !marginal probabilities at T1 and T2:
        prob11 = 1/(1+exp(-par1));
        prob12 = 1 - prob11;
        prob21 = prob11*trans11+prob12*trans21;
        prob22 = 1- prob21;
        ")
              } 
             else if (TPs == -.41) {
        glue("
        New(
        trans11*.40 trans12*.60 trans21*.5 trans22*.5
        prob11*.5 prob12*.5 prob21*.45 prob22*.55);
        trans11 = 1/(1+exp(-(par2+par11)));
        trans12 = 1-trans11;
        trans21 = 1/(1+exp(-par2));
        trans22 = 1- trans21;
        !marginal probabilities at T1 and T2:
        prob11 = 1/(1+exp(-par1));
        prob12 = 1 - prob11;
        prob21 = prob11*trans11+prob12*trans21;
        prob22 = 1- prob21;
        ")
              } 
             else if (TPs == -.85) {
        glue("
        New(
        trans11*.30 trans12*.70 trans21*.5 trans22*.5
        prob11*.5 prob12*.5 prob21*.40 prob22*.60);
        trans11 = 1/(1+exp(-(par2+par11)));
        trans12 = 1-trans11;
        trans21 = 1/(1+exp(-par2));
        trans22 = 1- trans21;
        !marginal probabilities at T1 and T2:
        prob11 = 1/(1+exp(-par1));
        prob12 = 1 - prob11;
        prob21 = prob11*trans11+prob12*trans21;
        prob22 = 1- prob21;
        ")
              } 
        
        else if (TPs == -1.385) {
        glue("
         New(
        trans11*.20 trans12*.80 trans21*.5 trans22*.5
        prob11*.5 prob12*.5 prob21*.35 prob22*.65);

        trans11 = 1/(1+exp(-(par2+par11)));
        trans12 = 1-trans11;
        trans21 = 1/(1+exp(-par2));
        trans22 = 1- trans21;
        !marginal probabilities at T1 and T2:
        prob11 = 1/(1+exp(-par1));
        prob12 = 1 - prob11;
        prob21 = prob11*trans11+prob12*trans21;
        prob22 = 1- prob21;")
      }
  )

  # Run Mplus model
  RILTA_LTA_Model<- mplusModeler(RILTA_LTA, 
                                   dataout = here('Simulations', 'STUDY_1', '3 Time Points', '7_3T_RILTA_GEN_LTA_ANALYZED', glue("RILTA_LTA_N_{N}_TP_{TPs}_TH_1_Lambda_{Lambda}.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_1', '3 Time Points', '7_3T_RILTA_GEN_LTA_ANALYZED', "RILTA_LTA_N_{N}_TP_{TPs}_TH_1_Lambda_{Lambda}.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
  
return(RILTA_LTA_Model)
}

# Step 3: Export necessary objects to the cluster
clusterExport(cl, c("rilta_lta_func", "p1", "here", "glue", "mplusModeler", "mplusObject"))

# Ensure necessary libraries are loaded on each cluster node
clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
})

# Step 4: Run the simulation in parallel using the cluster
result_list <- parLapply(cl, 1:nrow(p1), function(i) {
  rilta_lta_func(p1$N[i], p1$TPs[i], p1$Lambda[i])
})

# Step 5: Stop the cluster after the simulation
stopCluster(cl)


```

------------------------------------------------------------------------

# Data Processing and Verification

------------------------------------------------------------------------

## Check for Label Switching and Errors

> In this section: .csv files are first merged into a single data frame, from which specific parameters are extracted. Logit values are then converted to probabilities, and known class values are incorporated into the data frame. A subset of cases involving label switching is selected randomly and plotted for visual review. Output files are scanned for errors, which are subsequently merged back into the original data file. Additional columns derived from the file name are added, and the percentage of violations is calculated. Both errors and label switching violations are visually represented, and the total number of corrected replications is reported.

### Scrape Mplus CSV Files

*First, Load all CSV files and combine them into a single data frame.*

```{r}
#| label: "combine-csv-files-parallel"
#| echo: true
#| message: false
#| warning: false
#| code-fold: false

# Step 1: Set the correct CSV directory
csv_directory <- here('Simulations', 'STUDY_1', '3 Time Points', '7_3T_RILTA_GEN_LTA_ANALYZED')

# Step 2: Source the child document
source(here('Child_Docs', 'data_scraping.R'))

# Will return combined_data dataframe
```

### Slice Data / Extract Parameters

*Extract data from the appropriate rows from each 9-row chunk and prepare the data for further processing.*

```{r}
#| label: "scrape-rows-process-data-parallel"
#| echo: true
#| message: false
#| warning: false
#| code-fold: false

# Step 2: Process the data using the child script
source(here('Child_Docs', 'step2_3t_LTA.R'))

final_combined_data <- final_combined_data %>%
  mutate(
    TRANS11 = as.numeric(TRANS11),
    SE_11 = as.numeric(SE_11),
    across(starts_with("Ec"), as.numeric),  # Convert all Ec columns
    ll_csv = as.numeric(ll_csv)  # Convert Log-Likelihood values
  )

# Will populate final_combined_data dataframe in global environment
```

### Wrangle Data

*Convert the logits to probabilities and add the known actual values to each row.*

```{r}
#| label: "convert-logits-to-probabilities"
#| echo: true
#| message: false
#| warning: false
#| code-fold: false

# Step 3: Process the data and return results
source(here('Child_Docs', 'step_3.R'))

# The objects `final_data_with_actuals` and `violators` should now be in the global environment
```

### Generate Plots of Label Switching

*Generate plots of randomly sampled violators for visual inspection using parallel processing.*

```{r, eval=FALSE}
#| label: "plot-violators"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Set plot width and height
plot_width <- 8
plot_height <- 6

# Take a random sample of up to 250 violators (ensure not to exceed the total number of violators)
set.seed(123)  # For reproducibility
sample_size <- min(nrow(violators), 250)  # Handle cases where fewer than 250 violators exist
sampled_violators <- violators[sample(nrow(violators), sample_size), ]

# Define the function to create plots sequentially
plot_violator <- function(i) {
  row_data <- sampled_violators[i, ]
  
  # Extract the file name from the current row
  file_name <- row_data$FileName

  # Extract probability values for EC1 and EC2 (estimated probabilities) and AC1 and AC2 (actuals)
  estimated_probabilities <- c(
    as.numeric(row_data[c("Ec1u1", "Ec1u2", "Ec1u3", "Ec1u4", "Ec1u5")]),
    as.numeric(row_data[c("Ec2u1", "Ec2u2", "Ec2u3", "Ec2u4", "Ec2u5")])
  )
  
  actual_values <- c(
    as.numeric(row_data[c("Ac1u1", "Ac1u2", "Ac1u3", "Ac1u4", "Ac1u5")]),
    as.numeric(row_data[c("Ac2u1", "Ac2u2", "Ac2u3", "Ac2u4", "Ac2u5")])
  )
  
  # Create labels for the legend with actual values directly from the dataset
  labels <- c(
    paste0("EC1: (", round(row_data$Ec1u1, 3), ", ", round(row_data$Ec1u2, 3), ", ", round(row_data$Ec1u3, 3), ", ", round(row_data$Ec1u4, 3), ", ", round(row_data$Ec1u5, 3), ")"),
    paste0("EC2: (", round(row_data$Ec2u1, 3), ", ", round(row_data$Ec2u2, 3), ", ", round(row_data$Ec2u3, 3), ", ", round(row_data$Ec2u4, 3), ", ", round(row_data$Ec2u5, 3), ")"),
    paste0("AC1: (", round(row_data$Ac1u1, 3), ", ", round(row_data$Ac1u2, 3), ", ", round(row_data$Ac1u3, 3), ", ", round(row_data$Ac1u4, 3), ", ", round(row_data$Ac1u5, 3), ")"),
    paste0("AC2: (", round(row_data$Ac2u1, 3), ", ", round(row_data$Ac2u2, 3), ", ", round(row_data$Ac2u3, 3), ", ", round(row_data$Ac2u4, 3), ", ", round(row_data$Ac2u5, 3), ")")
  )

  # Step 6: Create a data frame for plotting
  plot_data <- data.frame(
    Items = rep(1:5, 4),
    Probabilities = c(estimated_probabilities, actual_values),
    Class = rep(labels, each = 5)
  )

  # Step 7: Create the plot with the file name in the title
  p <- ggplot(plot_data, aes(x = Items, y = Probabilities, color = Class, group = Class)) +
    geom_line(size = 1.2) +
    geom_point(size = 3) +
    labs(title = file_name, x = "Items", y = "Probabilities") +  # Only the file name in the title
    theme_minimal(base_size = 16) +
    theme(panel.background = element_rect(fill = "white"),
          plot.background = element_rect(fill = "white"),
          plot.title = element_text(size = 14, hjust = 0.5)) +  # Adjust title size and center
    scale_color_manual(values = c(
      "darkblue", "darkgreen",  # EC1 and EC2 (Estimated Probabilities)
      "lightblue", "lightgreen"  # AC1 and AC2 (Actual Values)
    ))

  ggsave(filename = file.path("3 Time Points", "zVIOLATOR_PLOTS","z3t_rilta_lta_violator_plots", paste0("violator_plot_", i, "_", file_name, ".png")),
         plot = p, width = plot_width, height = plot_height)
}

# Apply the function to generate plots sequentially (without parallelization)
invisible(lapply(1:sample_size, plot_violator))

```

------------------------------------------------------------------------

# Error Handling

------------------------------------------------------------------------

### Scrape for Errors

*Scrape output files for errors*

```{r}
#| label: "summarize-errors"
#| echo: true
#| message: false
#| warning: false
#| code-fold: false

# Step 1: Set the correct output directory for .out files
output_folder <- here('Simulations', 'STUDY_1', '3 Time Points', '7_3T_RILTA_GEN_LTA_ANALYZED')

# Step 2: Source the child document that processes .out files
source(here('Child_Docs', 'out_scraping.R'))

# ===================================================== #
#  ‚úÖ SECTION 1 Generate Replication Summary Table
# ===================================================== #
replication_summary_table <- replication_summary %>%
  gt() %>%
  tab_header(
    title = "Replication Summary",
    subtitle = paste0("Folder: ", output_folder)
  ) %>%
  fmt_number(
    columns = c("Total", "Replicated_Yes", "Replicated_No", "Error_Count"),
    decimals = 0
  ) %>%
  cols_label(
    FileName = "File Name",
    Total = "Total Replications",
    Replicated_Yes = "LL Replicated",
    Replicated_No = "LL Not Replicated",
    Error_Count = "Errors"
  ) %>%
  cols_align(
    align = "center",
    columns = everything()
  ) %>%
  tab_options(
    table.font.size = "small",
    heading.title.font.size = "medium",
    heading.subtitle.font.size = "small",
    table.width = pct(80)
  )

# Display the table
replication_summary_table

# ===================================================== #
#  ‚úÖ SECTION 2 Row Count Validation
# ===================================================== #
cat("Rows in final_data_with_actuals:", nrow(final_data_with_actuals), "\n")
cat("Rows in final_results:", nrow(final_results), "\n")
cat("Rows in replication_summary:", nrow(replication_summary), "\n")

```

### Merge Errors with Main Data File

*Combine error information with main data file*

```{r}
#| label: "merge-errors"
#| echo: true
#| message: false
#| warning: false

final_data_with_actuals <- final_data_with_actuals %>%
  left_join(
    final_results %>% dplyr::select(FileName, Replication, ll_out, LL_Replicated, ErrorFlag), 
    by = c("FileName", "Replication")
  ) %>%
  mutate(
    Any_Violation = ifelse(is.na(Any_Violation), 0, Any_Violation),
    ErrorFlag = ifelse(is.na(ErrorFlag), 0, ErrorFlag),
    LL_Replicated = ifelse(LL_Replicated == "Yes", 1, 0),  # ‚úÖ Convert Yes/No to 1/0

    # üîπ Create a new True Violation column
    True_Violation = case_when(
      Any_Violation == 1 | ErrorFlag == 1 | LL_Replicated == 0 ~ 1,  # ‚úÖ At least one violation
      TRUE ~ 0
    )
  )

```

Visualize differences between ll_out and ll_csv

```{r}

ll_check <- final_data_with_actuals %>%
  mutate(diff = round(ll_out - ll_csv, 3)) %>%  # Round before counting
  count(diff)

ll_check_table <- ll_check %>%
  gt() %>%
  tab_header(
    title = "LL Difference Summary",
    subtitle = "Comparison of LL values between CSV and OUT files"
  ) %>%
  cols_label(
    diff = "LL Difference",
    n = "Count"
  ) %>%
  fmt_number(
    columns = diff,
    decimals = 3
  ) %>%
  cols_align(
    align = "center",
    columns = everything()
  ) %>%
  tab_options(
    table.font.size = "small",
    heading.title.font.size = "medium",
    heading.subtitle.font.size = "small",
    table.width = pct(50)
  )

# Display the table
ll_check_table
```

Create DF of LL differences from .out and .csv files for inspection at the replication level

```{r}
# Create a dataframe with only rows where ll_out and ll_csv differ
ll_mismatch <- final_data_with_actuals %>%
  mutate(diff = round(ll_out - ll_csv, 3)) %>%
  filter(diff != 0) %>%
  dplyr::select(FileName, Replication, ll_out, ll_csv, diff)


```

### Scrape File Name Components

*Create Column Names from the File Name*

```{r}
#| label: "create-column-names-from-filename"
#| echo: true
#| message: false
#| warning: false
#| code-fold: false

# Add new columns based on the information in the FileName and set factors
final_data_with_actuals <- final_data_with_actuals %>%
  mutate(
    # Extract the sample size (N) from the FileName with the correct values
    N = case_when(
      grepl("n_4000", FileName) ~ 4,  
      grepl("n_500", FileName) ~ 1,   
      grepl("n_1000", FileName) ~ 2,  
      grepl("n_2000", FileName) ~ 3,  
      TRUE ~ NA_integer_
    ),
    # Map the TPs from the FileName to the appropriate Population labels
    Population = case_when(
      grepl("tp_1.385", FileName) ~ ".800",
      grepl("tp_0.85", FileName) ~ ".700",
      grepl("tp_0.41", FileName) ~ ".600",
      grepl("tp_-0.41", FileName) ~ ".400",
      grepl("tp_-0.85", FileName) ~ ".300",
      grepl("tp_-1.385", FileName) ~ ".200",
      TRUE ~ NA_character_
    ),
    # ‚úÖ Create `TPs` directly from `Population`
    TPs = case_when(
      Population == ".800" ~ 1.385,
      Population == ".700" ~ 0.85,
      Population == ".600" ~ 0.41,
      Population == ".400" ~ -0.41,
      Population == ".300" ~ -0.85,
      Population == ".200" ~ -1.385,
      TRUE ~ NA_real_
    ),
    Lambda = case_when(
      grepl("lambda_0\\.2", FileName) ~ "0.2",  
      grepl("lambda_0\\.4", FileName) ~ "0.4",  
      grepl("lambda_0\\.6", FileName) ~ "0.6",  
      grepl("lambda_0\\.8", FileName) ~ "0.8",  
      grepl("lambda_1(\\.|$)", FileName) ~ "1",  
      grepl("lambda_0(\\.|$)", FileName) ~ "0",  
      TRUE ~ NA_character_
    ),
    # Create the Transitions variable before Population is a factor
    Transitions = case_when(
      Population %in% c(".200", ".300", ".400") ~ 1,  
      Population %in% c(".600", ".700", ".800") ~ 2,  
      TRUE ~ NA_integer_
    )
  ) %>%
  # Convert Population to a factor
  mutate(
    Population = factor(Population, levels = c(".800", ".700", ".600", ".400", ".300", ".200")),
    N = factor(N, levels = c(4, 1, 2, 3), labels = c("N = 4000", "N = 500", "N = 1000", "N = 2000")),
    Transitions = factor(Transitions, levels = c(1, 2), labels = c("Mover", "Stayer"))
  )

```

### Calculate Violations

*Calculate Violation Percentages per Condition*

```{r}
#| label: "calculate-violations"
#| echo: true
#| message: false
#| warning: false
#| code-fold: false


violation_summary <- final_data_with_actuals %>%
  mutate(
    N_numeric = as.numeric(gsub("N = ", "", as.character(N))),
    N_numeric = ifelse(is.na(N_numeric), 0, N_numeric),
    Lambda = as.numeric(Lambda)
  ) %>%
  group_by(FileName, Population, N, N_numeric, Lambda) %>%
  summarize(
    Total_Rows = n(),
    Total_Violations = sum(Any_Violation, na.rm = TRUE),
    Total_Errors = sum(ErrorFlag, na.rm = TRUE),
    Total_LL_Failures = sum(LL_Replicated == 0, na.rm = TRUE),
    Total_True_Violations = sum(True_Violation, na.rm = TRUE),
    Percentage_Violations = round((Total_Violations / Total_Rows) * 100, 1),
    True_Violation_Perc = round((Total_True_Violations / Total_Rows) * 100, 1),
    ErrorRate = round((Total_Errors / Total_Rows) * 100, 1),
    LL_Failure_Perc = round((Total_LL_Failures / Total_Rows) * 100, 1),
    .groups = "drop"
  ) %>%
  mutate(
    GoodReplications = Total_Rows - Total_True_Violations,
    GoodReplications = ifelse(GoodReplications < 0, 0, GoodReplications),
    Reanalysis_Needed = if_else(GoodReplications >= 500, "No", "Yes"),
    Adjusted_Replications_Needed = case_when(
      True_Violation_Perc >= 100 ~ NA_real_,
      TRUE ~ ceiling(500 / (1 - (True_Violation_Perc / 100 + 0.11)) + 55)
    ),
    Adjusted_Replications_Needed = if_else(
      is.na(Adjusted_Replications_Needed) | Adjusted_Replications_Needed < 500,
      500,
      Adjusted_Replications_Needed
    ),
    TPs = case_when(
      Population == ".800" ~ 1.385,
      Population == ".700" ~ 0.85,
      Population == ".600" ~ 0.41,
      Population == ".400" ~ -0.41,
      Population == ".300" ~ -0.85,
      Population == ".200" ~ -1.385,
      TRUE ~ NA_real_
    )
  ) %>%
  arrange(
    factor(N_numeric, levels = c(500, 1000, 2000, 4000)),
    Lambda
  ) %>%
  dplyr::select(
    FileName, Population, TPs, Lambda, N, N_numeric,
    Total_Rows, Total_Violations, Total_True_Violations, True_Violation_Perc,
    Percentage_Violations,
    Total_Errors, ErrorRate,
    Total_LL_Failures, LL_Failure_Perc,
    GoodReplications, Reanalysis_Needed,
    Adjusted_Replications_Needed
  ) %>%
  mutate(
    N_numeric = trimws(as.numeric(N_numeric)),
    Population = as.character(Population)  # ‚úÖ <- THE FIX: preserve correct Population labels
  )

# ‚úÖ Save to CSV with correct Population values
write.csv(
  violation_summary,
  here("Simulations", "STUDY_1", "3 Time Points", "zdata", "violation_summary_r_l_3t.csv"),
  row.names = FALSE
)

```

```{r}
# Read in the previously saved summary file
violation_summary <- read.csv(here("Simulations", "STUDY_1", "3 Time Points", "zdata", "violation_summary_r_l_3t.csv"))

# Main Computer (N_numeric = 4000 all TPs; N_numeric = 2000, TPs = 1.385, 0.850; 48 conditions)
#violation_summary <- violation_summary[(violation_summary$N_numeric == 4000 | (violation_summary$N_numeric == 2000 & violation_summary$TPs %in% c(1.385, 0.850))), ]

# Old Rig 1 (N_numeric = 500, TPs = 1.385, 0.850, 0.410; 18 conditions)
#violation_summary <- violation_summary[violation_summary$N_numeric == 500 & violation_summary$TPs %in% c(1.385, 0.850, 0.410), ]

# Old Rig 2 (N_numeric = 500, TPs = -0.410, -0.850, -1.385; 18 conditions)
#violation_summary <- violation_summary[violation_summary$N_numeric == 500 & violation_summary$TPs %in% c(-0.410, -0.850, -1.385), ]

# Old Rig 3 (N_numeric = 1000, TPs = 1.385, 0.850, 0.410; 18 conditions)
violation_summary <- violation_summary[violation_summary$N_numeric == 1000 & violation_summary$TPs %in% c(1.385, 0.850, 0.410), ]

# Old Rig 4 (N_numeric = 1000, TPs = -0.410, -0.850, -1.385; 18 conditions)
#violation_summary <- violation_summary[violation_summary$N_numeric == 1000 & violation_summary$TPs %in% c(-0.410, -0.850, -1.385), ]

# Old Rig 5 (N_numeric = 2000, TPs = -0.410, -0.850, -1.385, 0.410; 24 conditions)
#violation_summary <- violation_summary[violation_summary$N_numeric == 2000 & violation_summary$TPs %in% c(-0.410, -0.850, -1.385, 0.410), ]
```

*Prepare Subsets by Transition Probability for Label Switching and Error Visualization*

```{r}
#| label: "read-fix-subset-population"
#| echo: true
#| message: false
#| warning: false

# Read in the previously saved summary file
violation_summary <- read.csv(here("Simulations", "STUDY_1", "3 Time Points", "zdata", "violation_summary_r_l_3t.csv"))

# üîß Fix Population labels (convert numeric to proper character labels)
violation_summary <- violation_summary %>%
  mutate(Population = case_when(
    Population == 0.2 ~ ".200",
    Population == 0.3 ~ ".300",
    Population == 0.4 ~ ".400",
    Population == 0.6 ~ ".600",
    Population == 0.7 ~ ".700",
    Population == 0.8 ~ ".800",
    TRUE ~ as.character(Population)
  ))

# ‚úÖ Subset by Population label
subset_200 <- violation_summary %>% filter(Population == ".200")
subset_300 <- violation_summary %>% filter(Population == ".300")
subset_400 <- violation_summary %>% filter(Population == ".400")
subset_600 <- violation_summary %>% filter(Population == ".600")
subset_700 <- violation_summary %>% filter(Population == ".700")
subset_800 <- violation_summary %>% filter(Population == ".800")

# Group into a list if needed
transition_subsets <- list(
  "TP_200" = subset_200,
  "TP_300" = subset_300,
  "TP_400" = subset_400,
  "TP_600" = subset_600,
  "TP_700" = subset_700,
  "TP_800" = subset_800
)

```

### Summarize & Visualize Label Switching Percentage Results

```{r}
#| label: "visualize-errrors-violations"
#| echo: true
#| message: false
#| warning: false

create_flextable <- function(data) {
  
  # Ensure only the required columns are used
  data <- data %>%
    dplyr::select(
      N_numeric,  
      Lambda,  # Replacing Population with Lambda
      Total_Violations,
      Percentage_Violations,
      Total_Errors,
      ErrorRate,
      Total_LL_Failures,
      LL_Failure_Perc,
      Total_True_Violations,
      True_Violation_Perc,
      Adjusted_Replications_Needed
    ) %>%
    as.data.frame()  # Ensures proper structure before passing to flextable
  
  # Create the flextable
  ft <- flextable(data) %>%
    set_header_labels(
      N_numeric = "N",
      Lambda = "\u03BB",  # Lambda symbol (Œª)
      Total_Violations = "V",
      Percentage_Violations = "V %",
      Total_Errors = "\u03B5",  # Epsilon
      ErrorRate = "\u03B5 %",
      Total_LL_Failures = "\u2112\u2097",  # ‚Ñí‚Çó
      LL_Failure_Perc = "\u2112\u2097 %",  # ‚Ñí‚Çó%
      Total_True_Violations = "\u03C4\u1D65",  # Tau subscript v (ùúè·µ•)
      True_Violation_Perc = "\u03C4\u1D65 %",
      Adjusted_Replications_Needed = "\u2206 Reps Req‚Äôd"  # Delta Symbol
    )

  # Apply special formatting to headers
  ft <- compose(ft, part = "header", j = "N_numeric", value = as_paragraph(as_i("N")))
  ft <- compose(ft, part = "header", j = "Lambda", value = as_paragraph(as_i("\u03BB")))  # Lambda symbol

  # üîπ Label Switching Violations
  ft <- compose(ft, part = "header", j = "Total_Violations", value = as_paragraph(as_i("V")))
  ft <- compose(ft, part = "header", j = "Percentage_Violations", value = as_paragraph(as_i("V"), "%"))

  # üîπ Mplus Errors
  ft <- compose(ft, part = "header", j = "Total_Errors", value = as_paragraph(as_i("\u03B5")))  
  ft <- compose(ft, part = "header", j = "ErrorRate", value = as_paragraph(as_i("\u03B5"), "%"))

  # üîπ NEW: LL Replication Failures (‚Ñí‚Çó)
  ft <- compose(ft, part = "header", j = "Total_LL_Failures", value = as_paragraph(as_i("\u2112"), as_sub("r")))
  ft <- compose(ft, part = "header", j = "LL_Failure_Perc", value = as_paragraph(as_i("\u2112"), as_sub("r"), "%"))

# üîπ True Violations (ùúè·µ•)
ft <- compose(ft, part = "header", j = "Total_True_Violations", value = as_paragraph(as_i("\u03C4"), as_sub(as_i("v"))))  
ft <- compose(ft, part = "header", j = "True_Violation_Perc", value = as_paragraph(as_i("\u03C4"), as_sub(as_i("v")), "%"))  

  ft <- compose(ft, part = "header", j = "Adjusted_Replications_Needed", value = as_paragraph(as_i("\u2206"), "\n", as_i("Reps"), "\n", "Req'd"))

  # Apply width settings
  ft <- width(ft, j = "N_numeric", width = 1.)
  ft <- width(ft, j = "Lambda", width = 0.6)
  ft <- width(ft, j = "Total_Violations", width = 0.6)
  ft <- width(ft, j = "Percentage_Violations", width = 0.6)
  ft <- width(ft, j = "Total_Errors", width = 0.5)
  ft <- width(ft, j = "ErrorRate", width = 0.5)
  ft <- width(ft, j = "Total_LL_Failures", width = 0.5)
  ft <- width(ft, j = "LL_Failure_Perc", width = 0.5)
  ft <- width(ft, j = "Total_True_Violations", width = 0.6)
  ft <- width(ft, j = "True_Violation_Perc", width = 0.6)
  ft <- width(ft, j = "Adjusted_Replications_Needed", width = 0.6)

 ft <- colformat_num(
  ft,
  j = c("Percentage_Violations", "ErrorRate", "LL_Failure_Perc", "True_Violation_Perc" ),  
  suffix = "%"  # ‚úÖ Adds percentage symbol
)
  # Add padding below the subheaders
#ft <- ft %>%
 # padding(part = "header", padding = c(0, 0, 6, 0))  # Adjust as needed for top, right, bottom, and left padding

  # Enable autofit
  ft <- set_table_properties(ft, layout = "fixed")

  # Center all cells
  ft <- align(ft, align = "center", part = "all")

  # Align header text at the bottom of the cells
  #ft <- valign(ft, part = "header", valign = "bottom")

  # Merge vertically identical rows in the "N_numeric" column
  ft <- merge_v(ft, j = "N_numeric")

  # Apply font to the entire table
  ft <- font(ft, fontname = "Avenir Next", part = "all")

  ft <- compose(
    ft,
    part = "body",
    j = "N_numeric",
    i = ~ !duplicated(N_numeric),
    value = as_paragraph(
      as_i("N"),  
      " =\u2009",  # THIN SPACE (Unicode U+2009)
      as.character(format(N_numeric, big.mark = ",", scientific = FALSE))  # Keeps proper formatting
    )
  )

  # Add subheader row
  ft <- add_header_row(
    ft,
    values = c("N Reps = 500", "Violations", "Errors", "LL Replication", "True Violations", "Adjustments"),  
    colwidths = c(2, 2, 2, 2, 2, 1))

  # Define a transparent border
  no_border <- fp_border(color = "transparent", width = 0)

  # **Remove ONLY the bottom border under the first three columns (the blank subheader)**
  ft <- hline(ft, i = 1, j = 1:2, border = no_border, part = "header")

  # Adding color with a correct method
  total_rows <- nrow(data)  # Get the total number of rows in your data
  color_rows <- rep(FALSE, total_rows)  # Initialize a logical vector for coloring rows
  for (i in seq(1, total_rows, by = 12)) {
    color_rows[i:(i+5)] <- TRUE  # Apply color to every 6 rows
  }

  # Apply background color with a lighter shade of gray
  ft <- bg(ft, i = color_rows, bg = "#f0f0f0", part = "body")

  return(ft)
}

# Generate formatted flextables for each subset
ft_200 <- create_flextable(subset_200)
ft_300 <- create_flextable(subset_300)
ft_400 <- create_flextable(subset_400)
ft_600 <- create_flextable(subset_600)
ft_700 <- create_flextable(subset_700)
ft_800 <- create_flextable(subset_800)

# Render tables one by one
ft_200
ft_300
ft_400
ft_600
ft_700
ft_800

```

Save Tables

```{r}
#| label: "render-violation-tables"
#| echo: true
#| message: false
#| warning: false

# Save each flextable as an SVG file
save_as_image(ft_200, here("Simulations", "STUDY_1", "3 Time Points", "zErrors", "3t_r_l_e&v_200.svg"))
save_as_image(ft_300, here("Simulations", "STUDY_1", "3 Time Points", "zErrors", "3t_r_l_e&v_300.svg"))
save_as_image(ft_400, here("Simulations", "STUDY_1", "3 Time Points", "zErrors", "3t_r_l_e&v_400.svg"))
save_as_image(ft_600, here("Simulations", "STUDY_1", "3 Time Points", "zErrors", "3t_r_l_e&v_600.svg"))
save_as_image(ft_700, here("Simulations", "STUDY_1", "3 Time Points", "zErrors", "rt_r_l_e&v_700.svg"))
save_as_image(ft_800, here("Simulations", "STUDY_1", "3 Time Points","zErrors", "3t_r_l_e&v_800.svg"))

```

------------------------------------------------------------------------

# Re-Run Simulations

------------------------------------------------------------------------

### Re-Run Simulation with Dynamic Replication Conditions

```{r,eval = FALSE}
#| label: "rilta-lta-simulation2"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

  # Define the Mplus object with the dynamic replications
rilta_lta_func <- function(N_numeric, TPs, Lambda, Adjusted_Replications_Needed) {
  
  RILTA_LTA <- mplusObject(
    TITLE = glue("Generate RILTA_LTA_N_{N_numeric}_TP_{TPs}_TH_1_Lambda_{Lambda}"),

    MONTECARLO =
      glue("NAMES = u11-u15 u21-u25 u31-u35;
      GENERATE = u11-u15 u21-u25 u31-u35(1);
      CATEGORICAL = u11-u15 u21-u25 u31-u35;
      GENCLASSES = c1(2) c2(2) c3(2);
      CLASSES = c1(2) c2(2) c3(2);
      NOBSERVATIONS = {N_numeric};
      SEED = 07252005;
      NREPS = {Adjusted_Replications_Needed};
      !!SAVE = repM1*.dat;
      RESULTS = RILTA_LTA_N_{N_numeric}_TP_{TPs}_TH_1_Lambda_{Lambda}.csv;"),

    ANALYSIS =
      "TYPE = MIXTURE;
      algorithm = integration;
      processors = 24;
      starts= 600 250;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    OUTPUT = "TECH9",

    MODELPOPULATION = glue("	
        %OVERALL%

        [c1#1-c3#1*0];
        c2#1 on c1#1*{TPs};
        c3#1 on c2#1*0;
      	
     f by  u11-u15*{Lambda} (p1-p5)
               u21-u25*{Lambda} (p1-p5)
               u31-u35*{Lambda} (p1-p5);
          
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
        %c1#1%
     [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);

        %c1#2%
     [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);

        %c2#2%
     [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
     
     MODEL POPULATION-c3:  
        %c3#1%
     [u31$1*1 u32$1*1 u33$1*1 u34$1*1 u35$1*1] (p111-p115);

        %c3#2%
     [u31$1*-1 u32$1*-1 u33$1*-1 u34$1*-1 u35$1*-1] (p121-p125);
       "),
     

    MODEL =
      glue("	
        %OVERALL%
          [c1#1-c3#1*0](par1-par3);
        	c2#1 on c1#1*{TPs} (par11);
        	c3#1 on c2#1*0;

     MODEL c1:
        %c1#1%
     [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);

        %c1#2%
     [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);

    MODEL c2: 	
        %c2#1%
     [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);

        %c2#2%
     [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
     
    MODEL c3:  
        %c3#1%
     [u31$1*1 u32$1*1 u33$1*1 u34$1*1 u35$1*1] (p111-p115);

        %c3#2%
     [u31$1*-1 u32$1*-1 u33$1*-1 u34$1*-1 u35$1*-1] (p121-p125);
	      "),
      

    MODELCONSTRAINT =
      if (TPs == 1.385) {
        glue("
        New(
        trans11*.80 trans12*.20 trans21*.5 trans22*.5
        prob11*.5 prob12*.5 prob21*.65 prob22*.35);
        trans11 = 1/(1+exp(-(par2+par11)));
        trans12 = 1-trans11;
        trans21 = 1/(1+exp(-par2));
        trans22 = 1- trans21;
        !marginal probabilities at T1 and T2:
        prob11 = 1/(1+exp(-par1));
        prob12 = 1 - prob11;
        prob21 = prob11*trans11+prob12*trans21;
        prob22 = 1- prob21;
        ")
      } 
             else if (TPs == .85) {
        glue("
        New(
        trans11*.70 trans12*.30 trans21*.5 trans22*.5
        prob11*.5 prob12*.5 prob21*.60 prob22*.4);
        trans11 = 1/(1+exp(-(par2+par11)));
        trans12 = 1-trans11;
        trans21 = 1/(1+exp(-par2));
        trans22 = 1- trans21;
        !marginal probabilities at T1 and T2:
        prob11 = 1/(1+exp(-par1));
        prob12 = 1 - prob11;
        prob21 = prob11*trans11+prob12*trans21;
        prob22 = 1- prob21;
        ")
              } 
            else  if (TPs == .41) {
        glue("
        New(
        trans11*.60 trans12*.40 trans21*.5 trans22*.5
        prob11*.5 prob12*.5 prob21*.55 prob22*.45);
        trans11 = 1/(1+exp(-(par2+par11)));
        trans12 = 1-trans11;
        trans21 = 1/(1+exp(-par2));
        trans22 = 1- trans21;
        !marginal probabilities at T1 and T2:
        prob11 = 1/(1+exp(-par1));
        prob12 = 1 - prob11;
        prob21 = prob11*trans11+prob12*trans21;
        prob22 = 1- prob21;
        ")
              } 
             else if (TPs == -.41) {
        glue("
        New(
        trans11*.40 trans12*.60 trans21*.5 trans22*.5
        prob11*.5 prob12*.5 prob21*.45 prob22*.55);
        trans11 = 1/(1+exp(-(par2+par11)));
        trans12 = 1-trans11;
        trans21 = 1/(1+exp(-par2));
        trans22 = 1- trans21;
        !marginal probabilities at T1 and T2:
        prob11 = 1/(1+exp(-par1));
        prob12 = 1 - prob11;
        prob21 = prob11*trans11+prob12*trans21;
        prob22 = 1- prob21;
        ")
              } 
             else if (TPs == -.85) {
        glue("
        New(
        trans11*.30 trans12*.70 trans21*.5 trans22*.5
        prob11*.5 prob12*.5 prob21*.40 prob22*.60);
        trans11 = 1/(1+exp(-(par2+par11)));
        trans12 = 1-trans11;
        trans21 = 1/(1+exp(-par2));
        trans22 = 1- trans21;
        !marginal probabilities at T1 and T2:
        prob11 = 1/(1+exp(-par1));
        prob12 = 1 - prob11;
        prob21 = prob11*trans11+prob12*trans21;
        prob22 = 1- prob21;
        ")
              } 
        
        else if (TPs == -1.385) {
        glue("
         New(
        trans11*.20 trans12*.80 trans21*.5 trans22*.5
        prob11*.5 prob12*.5 prob21*.35 prob22*.65);

        trans11 = 1/(1+exp(-(par2+par11)));
        trans12 = 1-trans11;
        trans21 = 1/(1+exp(-par2));
        trans22 = 1- trans21;
        !marginal probabilities at T1 and T2:
        prob11 = 1/(1+exp(-par1));
        prob12 = 1 - prob11;
        prob21 = prob11*trans11+prob12*trans21;
        prob22 = 1- prob21;")
      }
  )

  # Run Mplus model
  RILTA_LTA_Model<- mplusModeler(RILTA_LTA, 
                                   dataout = here('Simulations', 'STUDY_1', '3 Time Points', '7_3T_RILTA_GEN_LTA_ANALYZED_REP', glue("RILTA_LTA_N_{N_numeric}_TP_{TPs}_TH_1_Lambda_{Lambda}.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_1', '3 Time Points', '7_3T_RILTA_GEN_LTA_ANALYZED_REP', "RILTA_LTA_N_{N_numeric}_TP_{TPs}_TH_1_Lambda_{Lambda}.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
  
return(RILTA_LTA_Model)
}

library(parallel)
# Start the cluster
num_cores <- detectCores() - 1

# Step 2: Select the cluster type based on the system (PSOCK for Windows, FORK for macOS/Linux)
cluster_type <- ifelse(.Platform$OS.type == "windows", "PSOCK", "FORK")


cl <- makeCluster(num_cores, type = cluster_type)
# Export necessary objects to the cluster
clusterExport(cl, c("rilta_lta_func", "violation_summary", "here", "glue", "mplusModeler", "mplusObject"))

# Ensure required libraries are loaded on each node
clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
})

result_list <- parLapply(cl, 1:nrow(violation_summary), function(i) {
  rilta_lta_func(
    violation_summary$N_numeric[i], 
    violation_summary$TPs[i],  
    violation_summary$Lambda[i], 
    violation_summary$Adjusted_Replications_Needed[i]
  )
})



# Stop the cluster after the simulation
stopCluster(cl)


```

------------------------------------------------------------------------

## Check for Label Switching and Errors - Part 2

> In this section: we re conduct the steps for aggregating the label switching and errors to guarantee that we will have at minimum 500 replications per condition.

------------------------------------------------------------------------

*Load all CSV files and combine them into a single data frame.*

```{r}
#| label: "combine-csv-files-parallel2"
#| echo: true
#| message: false
#| warning: false
#| code-fold: false

# Step 1: Set the correct CSV directory
csv_directory <- here('Simulations', 'STUDY_1', '3 Time Points', '7_3T_RILTA_GEN_LTA_ANALYZED_REP')

# Step 2: Source the child document
source(here('Child_Docs', 'data_scraping.R'))

# Will populate combine_data in global environment
```

*Extract data from the appropriate rows from each 9-row chunk and prepare the data for further processing.*

```{r}
#| label: "scrape-rows-process-data-parallel2"
#| echo: true
#| message: false
#| warning: false
#| code-fold: false

# Step 2: Process the data using the child script
source(here('Child_Docs', 'step2_3t_LTA.R'))

final_combined_data <- final_combined_data %>%
  mutate(
    TRANS11 = as.numeric(TRANS11),
    SE_11 = as.numeric(SE_11),
    across(starts_with("Ec"), as.numeric),  # Convert all Ec columns
    ll_csv = as.numeric(ll_csv)  # Convert Log-Likelihood values
  )

# Will will populate final_combined data in global environment
```

*Convert the logits to probabilities and add the known actual values to each row.*

```{r}
#| label: "convert-logits-to-probabilities2"
#| echo: true
#| message: false
#| warning: false
#| code-fold: false

# Step 3: Process the data and return results
source(here('Child_Docs', 'step_3.R'))

# The objects `final_data_with_actuals` and `violators` should now be in the global environment
```

### *Scrape Output Files for Errors*

```{r}
#| label: "process-out-files-parallel2"
#| echo: true
#| message: false
#| warning: false

# Step 1: Set the correct output directory for .out files
output_folder <- here('Simulations', 'STUDY_1', '2 Time Points', '3_2T_RILTA_GEN_LTA_ANALYZED_REP')

## Step 2: Source the child document that processes .out files
source(here('Child_Docs', 'out_scraping.R'))

# ===================================================== #
#  ‚úÖ SECTION 1 Generate Replication Summary Table
# ===================================================== #
replication_summary_table <- replication_summary %>%
  gt() %>%
  tab_header(
    title = "Replication Summary",
    subtitle = paste0("Folder: ", output_folder)
  ) %>%
  fmt_number(
    columns = c("Total", "Replicated_Yes", "Replicated_No", "Error_Count"),
    decimals = 0
  ) %>%
  cols_label(
    FileName = "File Name",
    Total = "Total Replications",
    Replicated_Yes = "LL Replicated",
    Replicated_No = "LL Not Replicated",
    Error_Count = "Errors"
  ) %>%
  cols_align(
    align = "center",
    columns = everything()
  ) %>%
  tab_options(
    table.font.size = "small",
    heading.title.font.size = "medium",
    heading.subtitle.font.size = "small",
    table.width = pct(80)
  )

# Display the table
replication_summary_table

# ===================================================== #
#  ‚úÖ SECTION 2 Row Count Validation
# ===================================================== #
cat("Rows in final_data_with_actuals:", nrow(final_data_with_actuals), "\n")
cat("Rows in final_results:", nrow(final_results), "\n")
cat("Rows in replication_summary:", nrow(replication_summary), "\n")

###CHECK EXTRA ROWS
# Identify extra rows that are in final_results but not in final_data_with_actuals
extra_rows <- anti_join(final_results, final_data_with_actuals, by = c("FileName", "Replication"))

# Check if all extra rows have ErrorFlag == 1
all_errors <- all(extra_rows$ErrorFlag == 1, na.rm = TRUE)

# Message instead of printing raw data
if (all_errors) {
  message("‚úÖ All extra rows have errors (ErrorFlag == 1).")
} else {
  message("‚ö†Ô∏è Some extra rows do NOT have errors. Manual inspection needed.")
}

```

```{r}
#| label: "delete-extra-rows"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Identify extra rows that are in final_results but not in final_data_with_actuals
extra_rows <- anti_join(final_results, final_data_with_actuals, by = c("FileName", "Replication"))

# Filter to keep only extra rows where ErrorFlag == 1
rows_to_delete <- extra_rows %>% filter(ErrorFlag == 1)

# Delete only the extra rows with errors
if (nrow(rows_to_delete) > 0) {
  final_results <- anti_join(final_results, rows_to_delete, by = c("FileName", "Replication"))
  cat("‚úÖ Deleted", nrow(rows_to_delete), "extra rows with errors.\n")
} else {
  cat("‚úÖ No extra rows with errors were found. No deletions made.\n")
}

cat("Rows in final_data_with_actuals:", nrow(final_data_with_actuals), "\n")
cat("Rows in final_results:", nrow(final_results), "\n")

```

### Merge Errors with Main Data File

*Combine error information with main data file*

```{r}
#| label: "merge-errors"
#| echo: true
#| message: false
#| warning: false

final_data_with_actuals <- final_data_with_actuals %>%
  left_join(
    final_results %>% dplyr::select(FileName, Replication, ll_out, LL_Replicated, ErrorFlag), 
    by = c("FileName", "Replication")
  ) %>%
  mutate(
    Any_Violation = ifelse(is.na(Any_Violation), 0, Any_Violation),
    ErrorFlag = ifelse(is.na(ErrorFlag), 0, ErrorFlag),
    LL_Replicated = ifelse(LL_Replicated == "Yes", 1, 0),  # ‚úÖ Convert Yes/No to 1/0

    # üîπ Create a new True Violation column
    True_Violation = case_when(
      Any_Violation == 1 | ErrorFlag == 1 | LL_Replicated == 0 ~ 1,  # ‚úÖ At least one violation
      TRUE ~ 0
    )
  )

```

Visualize differences between ll_out and ll_csv

```{r}

ll_check <- final_data_with_actuals %>%
  mutate(diff = round(ll_out - ll_csv, 3)) %>%  # Round before counting
  count(diff)

ll_check_table <- ll_check %>%
  gt() %>%
  tab_header(
    title = "LL Difference Summary",
    subtitle = "Comparison of LL values between CSV and OUT files"
  ) %>%
  cols_label(
    diff = "LL Difference",
    n = "Count"
  ) %>%
  fmt_number(
    columns = diff,
    decimals = 3
  ) %>%
  cols_align(
    align = "center",
    columns = everything()
  ) %>%
  tab_options(
    table.font.size = "small",
    heading.title.font.size = "medium",
    heading.subtitle.font.size = "small",
    table.width = pct(50)
  )

# Display the table
ll_check_table
```

Create DF of LL differences from .out and .csv files for inspection at the replication level

```{r}
# Create a dataframe with only rows where ll_out and ll_csv differ
ll_mismatch <- final_data_with_actuals %>%
  mutate(diff = round(ll_out - ll_csv, 3)) %>%
  filter(diff != 0) %>%
  dplyr::select(FileName, Replication, ll_out, ll_csv, diff)


```

### *Create Column Names from the File Name*

```{r}
#| label: "create-column-names-from-filename2"
#| echo: true
#| message: false
#| warning: false
#| code-fold: false

# Add new columns based on the information in the FileName and set factors
final_data_with_actuals <- final_data_with_actuals %>%
  mutate(
    # Extract the sample size (N) from the FileName with the correct values
    N = case_when(
      grepl("n_4000", FileName) ~ 4,  # Correct value for N_4000
      grepl("n_500", FileName) ~ 1,   
      grepl("n_1000", FileName) ~ 2,  
      grepl("n_2000", FileName) ~ 3,  
      TRUE ~ NA_integer_
    ),
    # Map the TPs from the FileName to the appropriate Population labels
    Population = case_when(
      grepl("tp_1.385", FileName) ~ ".800",
      grepl("tp_0.85", FileName) ~ ".700",
      grepl("tp_0.41", FileName) ~ ".600",
      grepl("tp_-0.41", FileName) ~ ".400",
      grepl("tp_-0.85", FileName) ~ ".300",
      grepl("tp_-1.385", FileName) ~ ".200",
      TRUE ~ NA_character_
    ),
Lambda = case_when(
  grepl("lambda_0\\.2", FileName) ~ "0.2",  # Match 'Lambda_0.2'
  grepl("lambda_0\\.4", FileName) ~ "0.4",  # Match 'Lambda_0.4'
  grepl("lambda_0\\.6", FileName) ~ "0.6",  # Match 'Lambda_0.6'
  grepl("lambda_0\\.8", FileName) ~ "0.8",  # Match 'Lambda_0.8'
  grepl("lambda_1(\\.|$)", FileName) ~ "1", # Match 'Lambda_1'
  grepl("lambda_0(\\.|$)", FileName) ~ "0", # Match 'Lambda_0'
  TRUE ~ NA_character_
),

    # Create the Transitions variable based on Population values before Population is a factor
    Transitions = case_when(
      Population %in% c(".200", ".300", ".400") ~ 1,  # Assign 1 for Population .200, .300, .400
      Population %in% c(".600", ".700", ".800") ~ 2,  # Assign 2 for Population .600, .700, .800
      TRUE ~ NA_integer_
    )
  ) %>%
  # Convert columns to factors, ordering N_4000 first in the factor levels
  mutate(
    N = factor(N, levels = c(4, 1, 2, 3), labels = c("N = 4000", "N = 500", "N = 1000", "N = 2000")),
    Population = factor(Population, levels = c(".800", ".700", ".600", ".400", ".300", ".200")),
    Transitions = factor(Transitions, levels = c(1, 2), labels = c("Mover", "Stayer"))
  )

```

*Calculate Violation Percentages per Condition*

```{r}
#| label: "calculate-violations2"
#| echo: true
#| message: false
#| warning: false
#| code-fold: false

violation_summary2 <- final_data_with_actuals %>%
  mutate(
    N_numeric = as.numeric(gsub("N = ", "", as.character(N))),
    N_numeric = ifelse(is.na(N_numeric), 0, N_numeric)
  ) %>%
  group_by(FileName, Population, N, N_numeric, Lambda) %>%
  summarize(
    Total_Rows = n(),
    Total_Violations = sum(Any_Violation, na.rm = TRUE),   
    Total_Errors = sum(ErrorFlag, na.rm = TRUE),           
    Total_LL_Failures = sum(LL_Replicated == 0, na.rm = TRUE),  
    Total_True_Violations = sum(True_Violation, na.rm = TRUE),  
    Percentage_Violations = round((Total_Violations / Total_Rows) * 100, 1),  
    True_Violation_Perc = round((Total_True_Violations / Total_Rows) * 100, 1),  
    ErrorRate = round((Total_Errors / Total_Rows) * 100, 1),  
    LL_Failure_Perc = round((Total_LL_Failures / Total_Rows) * 100, 1),  
    .groups = "drop"
  ) %>%
  mutate(
    GoodReplications = Total_Rows - Total_True_Violations,
    GoodReplications = ifelse(GoodReplications < 0, 0, GoodReplications),
    Reanalysis_Needed = if_else(GoodReplications >= 500, "No", "Yes"),
Adjusted_Replications_Needed = case_when(
  True_Violation_Perc >= 100 ~ NA_real_,  
  TRUE ~ ceiling(500 / (1 - (True_Violation_Perc / 100)) + 50)
),
Adjusted_Replications_Needed = if_else(
  is.na(Adjusted_Replications_Needed) | Adjusted_Replications_Needed < 500, 
  500, 
  Adjusted_Replications_Needed
),
    TPs = case_when(
      Population == ".800" ~ 1.385,
      Population == ".700" ~ 0.85,
      Population == ".600" ~ 0.41,
      Population == ".400" ~ -0.41,
      Population == ".300" ~ -0.85,
      Population == ".200" ~ -1.385,
      TRUE ~ NA_real_
    )
  ) %>%
  arrange(
    factor(N_numeric, levels = c(500, 1000, 2000, 4000)), 
    Lambda, 
    as.numeric(Population)
  ) %>%
  mutate(
    N = factor(N, levels = c("N = 500", "N = 1000", "N = 2000", "N = 4000")),
    Population = factor(Population, levels = c(".200", ".300", ".400", ".600", ".700", ".800"))
  ) %>%
  dplyr::select(
    FileName, Population, TPs, N, N_numeric, Lambda,  
    Total_Rows,  
    Total_Violations, Percentage_Violations,  
    Total_Errors, ErrorRate,  
    Total_LL_Failures, LL_Failure_Perc,  
    Total_True_Violations, True_Violation_Perc,  
    GoodReplications,  
    Reanalysis_Needed,
    Adjusted_Replications_Needed
  ) %>%
  arrange(N_numeric, Lambda, Population) %>%
  mutate(N_numeric = trimws(as.numeric(N_numeric)))

# Write CSV
write.csv(violation_summary2, here("Simulations", "STUDY_1", "3 Time Points", 'zdata', "violation_summary2_r_l_3t.csv"), row.names = FALSE)

```

```{r}
#| label: "subset-violation-summary2"
#| echo: true
#| message: false
#| warning: false

# Read in the second-stage summary file
violation_summary2 <- read.csv(here("Simulations", "STUDY_1", "3 Time Points", "zdata", "violation_summary2_r_l_3t.csv"))

# üîß Recode Population numeric ‚Üí proper character labels
violation_summary2 <- violation_summary2 %>%
  mutate(Population = case_when(
    Population == 0.2 ~ ".200",
    Population == 0.3 ~ ".300",
    Population == 0.4 ~ ".400",
    Population == 0.6 ~ ".600",
    Population == 0.7 ~ ".700",
    Population == 0.8 ~ ".800",
    TRUE ~ as.character(Population)
  ))

# ‚úÖ Subset each transition group
subset_200 <- violation_summary2 %>% filter(Population == ".200")
subset_300 <- violation_summary2 %>% filter(Population == ".300")
subset_400 <- violation_summary2 %>% filter(Population == ".400")
subset_600 <- violation_summary2 %>% filter(Population == ".600")
subset_700 <- violation_summary2 %>% filter(Population == ".700")
subset_800 <- violation_summary2 %>% filter(Population == ".800")

# Store in list for looping or table generation
transition_subsets <- list(
  "TP_200" = subset_200,
  "TP_300" = subset_300,
  "TP_400" = subset_400,
  "TP_600" = subset_600,
  "TP_700" = subset_700,
  "TP_800" = subset_800
)

```

*Summarize & Visualize Label Switching Percentage Results*

```{r}
#| label: "summarize-violations-errors2"
#| echo: true
#| message: false
#| warning: false

create_flextable <- function(data) {
  
  # Ensure only the required columns are used
  data <- data %>%
    dplyr::select(
      N_numeric,  
      Lambda,  # Replace Population with Lambda
      Total_Violations,
      Percentage_Violations,
      Total_Errors,
      ErrorRate,
      Total_LL_Failures,
      LL_Failure_Perc,
      Total_True_Violations,
      True_Violation_Perc,
      GoodReplications,
      Reanalysis_Needed
    ) %>%
    as.data.frame()  # Ensures proper structure before passing to flextable
  
  # Create the flextable
  ft <- flextable(data) %>%
    set_header_labels(
      N_numeric = "N",
      Lambda = "\u03BB",  # Display Lambda symbol
      Total_Violations = "V",
      Percentage_Violations = "V %",
      Total_Errors = "\u03B5",  # Epsilon
      ErrorRate = "\u03B5 %",
      Total_LL_Failures = "\u2112\u2097",  # ‚Ñí‚Çó
      LL_Failure_Perc = "\u2112\u2097 %",  # ‚Ñí‚Çó%
      Total_True_Violations = "\u03C4\u1D65",  # Tau subscript v (ùúè·µ•)
      True_Violation_Perc = "\u03C4\u1D65 %",
      GoodReplications = "Good Reps",
      Reanalysis_Needed = "Reanalysis Needed?"
    )

  # Apply special formatting to headers
  ft <- compose(ft, part = "header", j = "N_numeric", value = as_paragraph(as_i("N")))
  ft <- compose(ft, part = "header", j = "Lambda", value = as_paragraph(as_i("\u03BB")))  
  ft <- compose(ft, part = "header", j = "Total_Violations", value = as_paragraph(as_i("V")))
  ft <- compose(ft, part = "header", j = "Percentage_Violations", value = as_paragraph(as_i("V"), "%"))
  ft <- compose(ft, part = "header", j = "Total_Errors", value = as_paragraph(as_i("\u03B5")))  
  ft <- compose(ft, part = "header", j = "ErrorRate", value = as_paragraph(as_i("\u03B5"), "%"))
  ft <- compose(ft, part = "header", j = "Total_LL_Failures", value = as_paragraph(as_i("\u2112"), as_sub("r")))
  ft <- compose(ft, part = "header", j = "LL_Failure_Perc", value = as_paragraph(as_i("\u2112"), as_sub("r"), "%"))
  ft <- compose(ft, part = "header", j = "Total_True_Violations", value = as_paragraph(as_i("\u03C4"), as_sub(as_i("v"))))  
  ft <- compose(ft, part = "header", j = "True_Violation_Perc", value = as_paragraph(as_i("\u03C4"), as_sub(as_i("v")), "%"))  
  ft <- compose(ft, part = "header", j = "GoodReplications", value = as_paragraph("Good", "\n", "Reps"))
  ft <- compose(ft, part = "header", j = "Reanalysis_Needed", value = as_paragraph("Reanalysis", "\n", "Needed?"))

  # Apply width settings
  ft <- width(ft, j = "N_numeric", width = 1.0)
  ft <- width(ft, j = "Lambda", width = 0.6)  
  ft <- width(ft, j = "Total_Violations", width = 0.6)
  ft <- width(ft, j = "Percentage_Violations", width = 0.6)
  ft <- width(ft, j = "Total_Errors", width = 0.5)
  ft <- width(ft, j = "ErrorRate", width = 0.5)
  ft <- width(ft, j = "Total_LL_Failures", width = 0.6)
  ft <- width(ft, j = "LL_Failure_Perc", width = 0.6)
  ft <- width(ft, j = "Total_True_Violations", width = 0.6)
  ft <- width(ft, j = "True_Violation_Perc", width = 0.6)
  ft <- width(ft, j = "GoodReplications", width = 0.6)
  ft <- width(ft, j = "Reanalysis_Needed", width = 0.7)

  # Format numeric columns
  ft <- colformat_num(
    ft,
    j = c("Percentage_Violations", "ErrorRate", "LL_Failure_Perc", "True_Violation_Perc"),  
    suffix = "%"  # ‚úÖ Adds percentage symbol
  )
  
  # Enable autofit
  ft <- set_table_properties(ft, layout = "fixed")

  # Center all cells
  ft <- align(ft, align = "center", part = "all")

  # Merge vertically identical rows in the "N_numeric" column
  ft <- merge_v(ft, j = "N_numeric")

  # Apply font to the entire table
  ft <- font(ft, fontname = "Avenir Next", part = "all")

  # Format `N_numeric` properly with thin space
  ft <- compose(
    ft,
    part = "body",
    j = "N_numeric",
    i = ~ !duplicated(N_numeric),
    value = as_paragraph(
      as_i("N"),  
      " =\u2009",  # THIN SPACE (Unicode U+2009)
      as.character(format(N_numeric, big.mark = ",", scientific = FALSE))  # Keeps proper formatting
    )
  )

  # Add subheader row
  ft <- add_header_row(
    ft,
    values = c("N Reps = Varies", "Violations", "Errors", "LL Replication", "True Violations", "Success?"),
    colwidths = c(2, 2, 2, 2, 2, 2)  
  )

  # Define a transparent border
  no_border <- fp_border(color = "transparent", width = 0)

  # **Remove ONLY the bottom border under the first three columns (the blank subheader)**
  ft <- hline(ft, i = 1, j = 1:2, border = no_border, part = "header")

  # Background color adjustments
  total_rows <- nrow(data)  # Get the total number of rows in your data
  color_rows <- rep(FALSE, total_rows)  # Initialize a logical vector for coloring rows
  for (i in seq(1, total_rows, by = 12)) {
    color_rows[i:(i+5)] <- TRUE  # Apply color to every 6 rows
  }

  # Apply background color with a lighter shade of gray
  ft <- bg(ft, i = color_rows, bg = "#f0f0f0", part = "body")

  return(ft)
}
  
# Generate formatted flextables for each subset
ft_200 <- create_flextable(subset_200)
ft_300 <- create_flextable(subset_300)
ft_400 <- create_flextable(subset_400)
ft_600 <- create_flextable(subset_600)
ft_700 <- create_flextable(subset_700)
ft_800 <- create_flextable(subset_800)

# Render tables one by one
ft_200
ft_300
ft_400
ft_600
ft_700
ft_800

```

```{r}
#| label: "render-violation-tables"
#| echo: true
#| message: false
#| warning: false

# Save each flextable as an SVG file
save_as_image(ft_200, here("Simulations", "STUDY_1", "3 Time Points", "zErrors", "z3t_r_l_e&v_200_final.svg"))
save_as_image(ft_300, here("Simulations", "STUDY_1", "3 Time Points", "zErrors", "z3t_r_l_e&v_300_final.svg"))
save_as_image(ft_400, here("Simulations", "STUDY_1", "3 Time Points", "zErrors", "z3t_r_l_e&v_400_final.svg"))
save_as_image(ft_600, here("Simulations", "STUDY_1", "3 Time Points", "zErrors", "z3t_r_l_e&v_600_final.svg"))
save_as_image(ft_700, here("Simulations", "STUDY_1", "3 Time Points", "zErrors", "z3t_r_l_e&v_700_final.svg"))
save_as_image(ft_800, here("Simulations", "STUDY_1", "3 Time Points", "zErrors", "z3t_r_l_e&v_800_final.svg"))

```

```{r}
#| label: "prepare-data-final-table"
#| echo: true
#| message: false
#| warning: false

# Prepare violation_summary2
violation_summary2 <- read.csv(here("Simulations", "STUDY_1", "3 Time Points", "zdata", "violation_summary2_r_l_3t.csv")) %>%
  mutate(
    Population = case_when(
      Population == 0.2 ~ ".200",
      Population == 0.3 ~ ".300",
      Population == 0.4 ~ ".400",
      Population == 0.6 ~ ".600",
      Population == 0.7 ~ ".700",
      Population == 0.8 ~ ".800",
      TRUE ~ as.character(Population)
    ),
    Lambda = as.numeric(Lambda),
    N_numeric = as.integer(N_numeric)  # ‚úÖ Ensure it's integer
  ) %>%
  rename_with(~ paste0(.x, "_2"), -c(Population, N, N_numeric, Lambda))  # Keep join keys

# Prepare violation_summary
violation_summary_final <- violation_summary %>%
  mutate(
    Lambda = as.numeric(Lambda),
    N_numeric = as.integer(N_numeric)  # ‚úÖ Match type with above
  ) %>%
  left_join(violation_summary2, by = c("Population", "N", "N_numeric", "Lambda")) %>%
  mutate(
    Total_Rows = Total_Rows,
    Violation_Rate = Percentage_Violations,  
    Final_Violation_Rate = Percentage_Violations_2,
    LL_Failure_Rate = LL_Failure_Perc,
    Final_LL_Failure_Rate = LL_Failure_Perc_2,
    Error_Rate = ErrorRate,
    Final_Error_Rate = ErrorRate_2,
    True_Violation_Rate = True_Violation_Perc,
    Final_True_Violation_Rate = True_Violation_Perc_2,
    Reps_Needed_for_Success = Adjusted_Replications_Needed,
    Successful_Replications = GoodReplications_2,
    Status = if_else(Successful_Replications >= 500, "‚úÖ Fixed", "‚ö†Ô∏è Additional Runs Required")
  ) %>%
  dplyr::select(
    N_numeric, Population, Lambda, Total_Rows, 
    Violation_Rate, LL_Failure_Rate, Error_Rate, True_Violation_Rate,
    Final_Violation_Rate, Final_LL_Failure_Rate, Final_Error_Rate, Final_True_Violation_Rate,
    Reps_Needed_for_Success, Successful_Replications, Status
  ) %>%
  arrange(factor(N_numeric, levels = c(500, 1000, 2000, 4000)), Population, Lambda)

# Save result
write.csv(violation_summary_final, here("Simulations", "STUDY_1", "3 Time Points", "zdata", "violation_summary_final_r_l_3t.csv"), row.names = FALSE)

```

Prepare Subsets for Visualization 2

```{r}
#| label: "creat-subsets-for-final-error-table"
#| echo: true
#| message: false
#| warning: false

violation_summary_final <- read.csv(
  here("Simulations", "STUDY_1", "3 Time Points", "zdata", "violation_summary_final_r_l_3t.csv")
)
violation_summary_final <- violation_summary_final %>%
  mutate(
    Population = factor(Population, 
      levels = c(0.2, 0.3, 0.4, 0.6, 0.7, 0.8),
      labels = c(".200", ".300", ".400", ".600", ".700", ".800")
    )
  )


# Ensure Population remains a factor but subset correctly
# Ensure Population is treated as factor and filter using matching factor level
subset_200 <- filter(violation_summary_final, Population == factor(".200", levels = levels(violation_summary_final$Population)))
subset_300 <- filter(violation_summary_final, Population == factor(".300", levels = levels(violation_summary_final$Population)))
subset_400 <- filter(violation_summary_final, Population == factor(".400", levels = levels(violation_summary_final$Population)))
subset_600 <- filter(violation_summary_final, Population == factor(".600", levels = levels(violation_summary_final$Population)))
subset_700 <- filter(violation_summary_final, Population == factor(".700", levels = levels(violation_summary_final$Population)))
subset_800 <- filter(violation_summary_final, Population == factor(".800", levels = levels(violation_summary_final$Population)))


# Store subsets in a list for easy access
transition_subsets <- list(
  "TP_200" = subset_200,
  "TP_300" = subset_300,
  "TP_400" = subset_400,
  "TP_600" = subset_600,
  "TP_700" = subset_700,
  "TP_800" = subset_800
)
```

Create flextable Function for Final Table

```{r}
#| label: "creat-final-error-table"
#| echo: true
#| message: false
#| warning: false

create_flextable <- function(data, title = NULL) {
  
  # Keep only the required columns
  data <- data %>%
    dplyr::select(
      N_numeric,
      Lambda,  
      #Total_Rows,
      Violation_Rate,
      LL_Failure_Rate,
      Error_Rate,
      True_Violation_Rate,   # ‚úÖ NEW
      Reps_Needed_for_Success,
      Final_Violation_Rate,
      Final_LL_Failure_Rate,
      Final_Error_Rate,
      Final_True_Violation_Rate,   # ‚úÖ NEW
      Successful_Replications
    ) %>%
    as.data.frame()  

  # Create the flextable
  ft <- flextable(data) %>%
    set_header_labels(
      N_numeric = "N",
      Lambda = "\u03BB",  # Display Lambda symbol
      #Total_Rows = "N Reps",
      Violation_Rate = "V %",
      LL_Failure_Rate = "‚Ñí‚Çó %",
      Error_Rate = "\u03B5 %",
      True_Violation_Rate = "\u03C4·µ• %",   # ‚úÖ NEW
      Reps_Needed_for_Success = "Reps Needed",
      Final_Violation_Rate = "V %",
      Final_LL_Failure_Rate = "‚Ñí‚Çó %",
      Final_Error_Rate = "\u03B5 %",
      Final_True_Violation_Rate = "\u03C4·µ• %",  # ‚úÖ NEW
      Successful_Replications = "Successful Reps"
    )

  # Apply special formatting to headers
  ft <- compose(ft, part = "header", j = "N_numeric", value = as_paragraph(as_i("N")))
  ft <- compose(ft, part = "header", j = "Lambda", value = as_paragraph(as_i("\u03BB")))  
  #ft <- compose(ft, part = "header", j = "Total_Rows", value = as_paragraph(as_i("N"), "\n", "Reps"))
  ft <- compose(ft, part = "header", j = "Violation_Rate", value = as_paragraph(as_i("V"), "%"))
  ft <- compose(ft, part = "header", j = "LL_Failure_Rate", value = as_paragraph(as_i("‚Ñí"), as_sub("r"), "%"))
  ft <- compose(ft, part = "header", j = "Error_Rate", value = as_paragraph(as_i("\u03B5"), "%"))
  ft <- compose(ft, part = "header", j = "True_Violation_Rate", value = as_paragraph(as_i("\u03C4"), as_sub("v"), "%"))  # ‚úÖ NEW
  ft <- compose(ft, part = "header", j = "Final_Violation_Rate", value = as_paragraph(as_i("V"), "%"))
  ft <- compose(ft, part = "header", j = "Final_LL_Failure_Rate", value = as_paragraph(as_i("‚Ñí"), as_sub("r"), "%"))
  ft <- compose(ft, part = "header", j = "Final_Error_Rate", value = as_paragraph(as_i("\u03B5"), "%"))
  ft <- compose(ft, part = "header", j = "Final_True_Violation_Rate", value = as_paragraph(as_i("\u03C4"), as_sub("v"), "%"))  # ‚úÖ NEW
  ft <- compose(ft, part = "header", j = "Reps_Needed_for_Success", value = as_paragraph("Reps", "\n", "Needed"))
  ft <- compose(ft, part = "header", j = "Successful_Replications", value = as_paragraph("Final", "\n", "Reps"))

    # Set column widths
  ft <- width(ft, j = "N_numeric", width = .6)
  ft <- width(ft, j = "Lambda", width = 0.6)  
  #ft <- width(ft, j = "Total_Rows", width = 0.6) 
  ft <- width(ft, j = "Violation_Rate", width = 0.6)
  ft <- width(ft, j = "LL_Failure_Rate", width = 0.6)
  ft <- width(ft, j = "Error_Rate", width = 0.4)
  ft <- width(ft, j = "True_Violation_Rate", width = 0.6)  # ‚úÖ NEW
  ft <- width(ft, j = "Reps_Needed_for_Success", width = .8)
  ft <- width(ft, j = "Final_Violation_Rate", width = 0.6)
  ft <- width(ft, j = "Final_LL_Failure_Rate", width = 0.6)
  ft <- width(ft, j = "Final_Error_Rate", width = 0.4)
  ft <- width(ft, j = "Final_True_Violation_Rate", width = 0.6)  # ‚úÖ NEW
  ft <- width(ft, j = "Successful_Replications", width = .6)

  # **Correct vertical centering: Merge "N = _" across 6-row blocks**
  ft <- merge_v(ft, j = "N_numeric")  

  # **Ensure "N = ..." appears only ONCE in the center of the 6-row block**
  #ft <- compose(
  #  ft,
  #  part = "body",
  #  j = "N_numeric",
  #  i = seq(1, nrow(data), by = 6),  # Every 6th row
  #  value = as_paragraph(
  #    as_i("N"),  
  #    " =\u2009",  # THIN SPACE (Unicode U+2009)
  #    format(N_numeric, big.mark = ",", scientific = FALSE)  # Updated
  #  )
  #)

  # **Fully remove duplicate N values in merged rows**
  ft <- compose(
    ft,
    part = "body",
    j = "N_numeric",
    i = setdiff(1:nrow(data), seq(1, nrow(data), by = 6)),  
    value = as_paragraph("")
  )

  # **Align vertically centered**
  ft <- valign(ft, j = "N_numeric", valign = "center", part = "body")

  # Center all text
  ft <- align(ft, align = "center", part = "all")

  # Apply percentage formatting
  ft <- colformat_num(
    ft,
    j = c("Violation_Rate", "LL_Failure_Rate", "Error_Rate", "True_Violation_Rate",
          "Final_Violation_Rate", "Final_LL_Failure_Rate", "Final_Error_Rate", "Final_True_Violation_Rate"),  
    suffix = "%"  
  )
  
  ft <- add_header_row(
    ft,
    values = c(" ", "Initial 500 Replications", " ", "Adjusted Replications", " "),
    colwidths = c(2, 4, 1, 4, 1)
  )

  # Apply APA-style border fixes
  thin <- fp_border(color = "black", width = 1)

  ft <- ft %>%
    border_remove() %>%
    border(i = 1, j = 3:6, part = "header", border.bottom = thin) %>%
    border(i = 1, j = 8:11, part = "header", border.bottom = thin) %>%
    hline_top(border = thin, part = "all") %>%
    hline_bottom(border = thin, part = "all") %>%
    font(fontname = "Avenir Next", part = "all") %>%
    fontsize(size = 14, part = "all") %>%
    align(align = "center", part = "all") %>%
    set_table_properties(layout = "fixed")

  # Color every 6-row block
  total_rows <- nrow(data)
  color_rows <- rep(FALSE, total_rows)
  for (i in seq(1, total_rows, by = 12)) {
    color_rows[i:(i+5)] <- TRUE
  }
  ft <- bg(ft, i = color_rows, bg = "#f0f0f0", part = "body")


if (!is.null(title)) {
  ft <- add_header_lines(
    ft,
    values = as_paragraph(
      as_i("T"),
      as_sub("11"),
      as_chunk(" = "),
      as_chunk(title)
    )
  ) |>
    align(i = 1, align = "center", part = "header") |>
    fontsize(i = 1, size = 13, part = "header")  # ‚úÖ removed bold
}

# ‚¨áÔ∏è NOW apply font to ALL parts including the new header line
ft <- font(ft, fontname = "Avenir Next", part = "all")

  return(ft)
}

# Generate formatted flextables for each subset
ft_200 <- create_flextable(subset_200, title = ".200")
ft_300 <- create_flextable(subset_300, title = ".300")
ft_400 <- create_flextable(subset_400, title = ".400")
ft_600 <- create_flextable(subset_600, title = ".600")
ft_700 <- create_flextable(subset_700, title = ".700")
ft_800 <- create_flextable(subset_800, title = ".800")


# Render tables one by one
ft_200
ft_300
ft_400
ft_600
ft_700
ft_800


```

Save FINAL table

```{r}

#| label: "render-violation-tables"
#| echo: true
#| message: false
#| warning: false

# Save each flextable as an SVG file
invisible(save_as_image(ft_200, here("Simulations", "STUDY_1", "3 Time Points", "zErrors", "zr_l_e&v_200_FINAL.svg")))
invisible(save_as_image(ft_300, here("Simulations", "STUDY_1", "3 Time Points", "zErrors", "zr_l_e&v_300_FINAL.svg")))
invisible(save_as_image(ft_400, here("Simulations", "STUDY_1", "3 Time Points", "zErrors", "zr_l_e&v_400_FINAL.svg")))
invisible(save_as_image(ft_600, here("Simulations", "STUDY_1", "3 Time Points", "zErrors", "zr_l_e&v_600_FINAL.svg")))
invisible(save_as_image(ft_700, here("Simulations", "STUDY_1", "3 Time Points", "zErrors", "zr_l_e&v_700_FINAL.svg")))
invisible(save_as_image(ft_800, here("Simulations", "STUDY_1", "3 Time Points", "zErrors", "zr_l_e&v_800_FINAL.svg")))

```

# RUN True Violations ANOVA:

```{r}
#| label: "violator-anova"
#| echo: true
#| message: false
#| warning: false
#| fig.width: 6
#| fig.height: 4

# Load libraries
library(ggplot2)
library(emmeans)
library(multcomp)
library(dplyr)
library(car)
library(here)
library(effectsize)

# Load and process data
violation_summary_final <- read.csv(
  here("Simulations", "STUDY_1", "3 Time Points", "zdata", "violation_summary_final_r_l_3t.csv")
) %>%
  filter(!is.na(Population), !is.na(N_numeric), !is.na(Lambda)) %>%
  mutate(
    Population = factor(Population, levels = c(0.2, 0.3, 0.4, 0.6, 0.7, 0.8),
                        labels = c(".200", ".300", ".400", ".600", ".700", ".800")),
    N_numeric = factor(N_numeric),
    # Map numeric Lambda values (0, 0.2, ..., 1) to labels
    Lambda = factor(
      Lambda,
      levels = c(0, 0.2, 0.4, 0.6, 0.8, 1),
      labels = c("Œª = 0", "Œª = 0.2", "Œª = 0.4", "Œª = 0.6", "Œª = 0.8", "Œª = 1")
    ),
    # Create Lambda_label with formatted strings for italicized Œª
    Lambda_label = factor(
      sapply(Lambda, function(x) {
        value <- sub("^Œª\\s*", "", as.character(x))  # Extract "= 0", "= 0.2", etc.
        paste0("italic(Œª) * '", value, "'")  # Format as "italic(Œª) * '= 0'"
      }),
      levels = sapply(c("Œª = 0", "Œª = 0.2", "Œª = 0.4", "Œª = 0.6", "Œª = 0.8", "Œª = 1"), function(x) {
        value <- sub("^Œª\\s*", "", x)
        paste0("italic(Œª) * '", value, "'")
      })
    )
  ) %>%
  droplevels()

# -------------------------------
# MAIN EFFECTS: TYPE II ANOVAs
# -------------------------------

aov_main <- aov(Final_True_Violation_Rate ~ N_numeric + Population + Lambda, data = violation_summary_final)
anova_main_type2 <- Anova(aov_main, type = "II")
print(anova_main_type2)
eta_squared(anova_main_type2, partial = TRUE)

# -------------------------------
# INTERACTIONS: TYPE II ANOVAs
# -------------------------------

aov_np <- aov(Final_True_Violation_Rate ~ N_numeric + Population + N_numeric:Population, data = violation_summary_final)
aov_nl <- aov(Final_True_Violation_Rate ~ N_numeric + Lambda + N_numeric:Lambda, data = violation_summary_final)
aov_pl <- aov(Final_True_Violation_Rate ~ Population + Lambda + Population:Lambda, data = violation_summary_final)

anova_np <- Anova(aov_np, type = "II")
anova_nl <- Anova(aov_nl, type = "II")
anova_pl <- Anova(aov_pl, type = "II")

print(anova_np)
print(anova_nl)
print(anova_pl)

eta_squared(anova_np, partial = TRUE)
eta_squared(anova_nl, partial = TRUE)
eta_squared(anova_pl, partial = TRUE)

# -------------------------------
# PAIRWISE COMPARISONS: MAIN EFFECTS
# -------------------------------

lm_main <- lm(Final_True_Violation_Rate ~ N_numeric + Population + Lambda, data = violation_summary_final)

# Population
em_pop <- emmeans(lm_main, pairwise ~ Population)
pairwise_pop <- summary(em_pop$contrasts, infer = TRUE)
print(pairwise_pop)

# N (Sample Size)
em_n <- emmeans(lm_main, pairwise ~ N_numeric)
pairwise_n <- summary(em_n$contrasts, infer = TRUE)
print(pairwise_n)

# Lambda
em_lam <- emmeans(lm_main, pairwise ~ Lambda)
pairwise_lam <- summary(em_lam$contrasts, infer = TRUE)
print(pairwise_lam)

# -------------------------------
# FINAL PLOT
# -------------------------------

violation_plot <- ggplot(violation_summary_final, aes(x = Population, y = Final_True_Violation_Rate, fill = N_numeric)) +
  stat_summary(fun = mean, geom = "bar", position = position_dodge(0.8), width = 0.7) +
  stat_summary(fun.data = mean_se, geom = "errorbar", position = position_dodge(0.8), width = 0.2) +
  labs(
    x = expression(italic(T)[11]),
    y = "Final True Violation Rate (%)",
    fill = expression(italic(N))
  ) +
  scale_y_continuous(limits = c(0, 100)) +
  facet_wrap(~ Lambda_label, labeller = label_parsed, drop = FALSE) +
  theme_minimal(base_size = 12) +
  theme(
    axis.title = element_text(face = "plain"),
    text = element_text(family = "Avenir Next"),
    legend.position = "bottom",
    legend.title = element_text(face = "plain"),
    legend.text = element_text(size = 10)
  )

print(violation_plot)
```

Save Violator Figure

```{r}
#| label: "save-violator-figure"
#| echo: true
#| message: false
#| warning: false

invisible(ggsave(
  filename = here("Simulations", "STUDY_1", "3 Time Points", "zposthoc", "r_l_3t_violation_visuals", "r_l_3t_violation_plot.svg"),
  plot = violation_plot,
  width = 7,
  height = 5,
  units = "in",
  dpi = 300
))

```

**Create Pairwise Comparisons Function**

```{r}
#| label: "function-format-pairwise"
#| include: false

format_pairwise_ft <- function(df, group_label) {
  df <- df %>%
    mutate(
      Estimate   = round(as.numeric(estimate), 2),
      SE         = round(as.numeric(SE), 2),
      Lower_CL   = round(as.numeric(lower.CL), 2),
      Upper_CL   = round(as.numeric(upper.CL), 2),
      t_val      = round(as.numeric(t.ratio), 2),
      p_val      = round(as.numeric(p.value), 3),
      p          = ifelse(p_val < .001, "< .001", sub("^0", "", format(p_val, nsmall = 3))),
      Effect     = paste0(
        format(Estimate, nsmall = 2), " (",
        format(Lower_CL, nsmall = 2), ", ",
        format(Upper_CL, nsmall = 2), ")"
      )
    )

  pairwise_clean <- df[, c("contrast", "Effect", "SE", "df", "t_val", "p")]
  colnames(pairwise_clean)[colnames(pairwise_clean) == "t_val"] <- "t"

  # Determine contrast formatting based on variable
  contrast_strings <- pairwise_clean$contrast
  is_pop     <- grepl("^Population\\.", contrast_strings)
  is_n       <- grepl("^N_numeric", contrast_strings)
  is_lambda  <- grepl("^Œª = ", contrast_strings)

  if (all(is_pop)) {
    # Format T11 contrasts
    left_right <- stringr::str_match(contrast_strings, "Population\\.(\\d{3}) - Population\\.(\\d{3})")
    ft <- flextable(pairwise_clean) |>
      compose(
        j = "contrast",
        part = "body",
        value = as_paragraph(
          as_i("T"), as_sub("11"), " = .", left_right[, 2],
          " ‚Äì ",
          as_i("T"), as_sub("11"), " = .", left_right[, 3]
        )
      )
  } else if (all(is_n)) {
    # Format N contrasts
    left_right <- stringr::str_match(contrast_strings, "N_numeric(\\d+) - N_numeric(\\d+)")
    ft <- flextable(pairwise_clean) |>
      compose(
        j = "contrast",
        part = "body",
        value = as_paragraph(
          as_i("N"), " = ", left_right[, 2],
          " ‚Äì ",
          as_i("N"), " = ", left_right[, 3]
        )
      )
  } else if (all(is_lambda)) {
    # Format Lambda contrasts
    left_right <- stringr::str_match(contrast_strings, "Œª = ([0-9.]+) - Œª = ([0-9.]+)")
    ft <- flextable(pairwise_clean) |>
      compose(
        j = "contrast",
        part = "body",
        value = as_paragraph(
          as_i("Œª"), " = ", left_right[, 2],
          " ‚Äì ",
          as_i("Œª"), " = ", left_right[, 3]
        )
      )
  } else {
    # Default: use raw text
    ft <- flextable(pairwise_clean)
  }

  # Shared formatting
  ft <- ft |>
    set_header_labels(
      contrast = "Contrast",
      Effect   = "Estimate (95% CI)",
      SE       = "SE",
      df       = "df",
      t        = "t",
      p        = "p"
    ) |>
    compose(part = "header", j = "SE", value = as_paragraph(as_i("SE"))) |>
    compose(part = "header", j = "t",  value = as_paragraph(as_i("t"))) |>
    compose(part = "header", j = "p",  value = as_paragraph(as_i("p"))) |>
    compose(part = "header", j = "df", value = as_paragraph(as_i("df"))) |>
    colformat_num(j = "SE", digits = 2, align = "decimal") |>
    colformat_num(j = "t", digits = 2, align = "decimal") |>
    align(j = c("contrast", "Effect", "df", "p"), align = "center", part = "all") |>
    width(j = "contrast", width = 2.2) |>
    width(j = "Effect", width = 2.5) |>
    line_spacing(space = 0.9, part = "all") |>
    padding(j = "contrast", padding.top = 1, padding.bottom = 1, part = "all")

  # Bold significant p values
  sig_rows <- which(df$p_val < 0.05)
  ft <- bold(ft, i = sig_rows, j = "p", bold = TRUE, part = "body")

  # Borders + header
  thin <- fp_border(color = "black", width = 1)
  ft <- ft |>
    border_remove() |>
    font(fontname = "Avenir Next", part = "all") |>
    fontsize(size = 12, part = "all") |>
    align(align = "center", part = "all") |>
    set_table_properties(layout = "fixed") |>
    hline(i = 1, border = thin, part = "header") |>
    hline_top(border = thin, part = "all") |>
    hline_bottom(border = thin, part = "all") |>
    add_header_row(
      values = group_label,
      colwidths = ncol(pairwise_clean)
    ) |>
    merge_h(part = "header") |>
    line_spacing(i = 1, space = 1.5, part = "header") |>
    padding(i = 1, padding.top = 3, padding.bottom = 3, part = "header") |>
    fontsize(i = 1, size = 12, part = "header")

  return(ft)
}

```

Create T11 Pairwise Tables

```{r}
#| label: "pairwise-comparisons-t11"
#| echo: true
#| message: false
#| warning: false

pairwise_pop_main <- summary(emmeans(lm_main, pairwise ~ Population)$contrasts, infer = TRUE)

ft_population <- format_pairwise_ft(pairwise_pop_main, group_label = as_paragraph("Pairwise Comparisons for ", as_i("T"), as_sub("11")))
ft_population


```

```{r}
#| label: "pairwise-comparisons-n"
#| echo: true
#| message: false
#| warning: false

pairwise_n_main <- summary(emmeans(lm_main, pairwise ~ N_numeric)$contrasts, infer = TRUE)

ft_n <- format_pairwise_ft(pairwise_n_main, group_label = as_paragraph("Pairwise Comparisons for ", as_i("N")))
ft_n

```

```{r}
#| label: "pairwise-comparisons-lambda"
#| echo: true
#| message: false
#| warning: false

pairwise_lambda_main <- summary(emmeans(lm_main, pairwise ~ Lambda)$contrasts, infer = TRUE)

ft_lambda <- format_pairwise_ft(pairwise_lambda_main, group_label = as_paragraph("Pairwise Comparisons for ", as_i("Œª")))
ft_lambda

```

\
Save Pairwise Table

```{r}
#| label: "save-comparisons-table"
#| echo: false
#| message: false
#| warning: false

# Save Population (T11) comparison table
invisible(save_as_image(
  ft_population,
  path = here("Simulations", "STUDY_1", "3 Time Points", "zposthoc", "r_l_3t_violation_visuals", "r_l_3t_pairwise_population.svg")
))

# Save N comparison table
invisible(save_as_image(
  ft_n,
  path = here("Simulations", "STUDY_1", "3 Time Points", "zposthoc", "r_l_3t_violation_visuals", "r_l_3t_pairwise_n.svg")
))

# Save Lambda comparison table
invisible(save_as_image(
  ft_lambda,
  path = here("Simulations", "STUDY_1", "3 Time Points", "zposthoc", "r_l_3t_violation_visuals", "r_l_3t_pairwise_lambda.svg")
))

```

------------------------------------------------------------------------

# Final Data Preparation

------------------------------------------------------------------------

## Filter Cases with Violations and Errors

*Filter out cases with any violations, leaving only the clean data.*

```{r}
#| label: "delete-cases"
#| echo: true
#| message: false
#| warning: false
#| code-fold: false

# Filter out cases with no violations and no errors
filtered_data_with_no_violations <- final_data_with_actuals[
  final_data_with_actuals$True_Violation == 0, ]


# Check the number of remaining rows after filtering
cat("Remaining rows after filtering:", nrow(filtered_data_with_no_violations), "\n")

# Verify if there are any remaining violations, errors, true violations, or LL replication failures
cat("Any remaining label switching violations:", sum(filtered_data_with_no_violations$Any_Violation, na.rm = TRUE), "\n")
cat("Any remaining Mplus errors:", sum(filtered_data_with_no_violations$ErrorFlag, na.rm = TRUE), "\n")
cat("Any remaining LL replication failures:", sum(filtered_data_with_no_violations$LL_Replicated == 0, na.rm = TRUE), "\n")
cat("Any remaining true violations:", sum(filtered_data_with_no_violations$True_Violation, na.rm = TRUE), "\n")


```

### Calculate Monte Carlo Values

*Calculate Monte Carlo values for¬†`TRANS11`, including population values, averages, standard errors, Mean Squared Error (MSE), coverage, and power.*

```{r}
#| label: "compute-mc-values"
#| echo: true
#| message: false
#| warning: false
#| code-fold: false
# 1. Create a function that calculates mc_values from raw replication-level data
calc_mc_values <- function(data) {
  # Step A: Clean and convert columns as needed
  cleaned_data <- data %>%
    mutate(
      Population = as.numeric(as.character(Population)),
      Lambda = as.numeric(as.character(Lambda)),  # Ensure Lambda is numeric
      TRANS11 = as.numeric(as.character(TRANS11)),
      SE_11 = as.numeric(as.character(SE_11))
    )
  
  # Step B: Compute group-level summaries (without grouping by Transitions)
  mc_values <- cleaned_data %>%
    group_by(Population, Lambda, N) %>%  # ‚úÖ Include Lambda in grouping
    summarize(
      group_size   = n(),
      average      = round(mean(TRANS11, na.rm = TRUE), 3),
      average_SE   = round(mean(SE_11, na.rm = TRUE), 3),
      population_sd= round(sd(TRANS11, na.rm = TRUE), 3),
      MSE          = round(mean((TRANS11 - Population)^2, na.rm = TRUE), 3),
      Coverage     = round(mean((Population >= (TRANS11 - 1.96 * SE_11)) &
                                  (Population <= (TRANS11 + 1.96 * SE_11)), na.rm = TRUE), 3),
      Power        = round(mean(TRANS11 / SE_11 > 1.96, na.rm = TRUE), 3),
      Reps_Used    = n(),
      .groups = "drop"
    )
  
  # Step C: Merge in Transitions from the raw data (or from an auxiliary table if needed)
  mc_values <- cleaned_data %>%
    dplyr::select(FileName, Population, Lambda, N, Transitions) %>%
    distinct() %>%
    right_join(mc_values, by = c("Population", "Lambda", "N"))  # ‚úÖ Join by Population, Lambda, and N
  
  # Step D: Calculate bias measures
  mc_values <- mc_values %>%
    mutate(
      Parameter_Bias_boot = round((average - Population) / Population * 100, 2),
      SE_Bias_boot        = round((average_SE - population_sd) / (population_sd + 1e-6) * 100, 2)
    )
  
  return(mc_values)
}

# 2. Create a parallelized bootstrap function that uses the above calculation on bootstrap samples
bootstrap_mc_values <- function(data, n_bootstrap, sample_size) {
  
  # Step A: Detect available cores and create a parallel cluster
  num_cores <- detectCores() - 1  # Use one less than total cores to avoid overloading the system
  cluster_type <- ifelse(.Platform$OS.type == "windows", "PSOCK", "FORK")  # Use FORK for Mac/Linux, PSOCK for Windows
  cl <- makeCluster(num_cores, type = cluster_type)  # Create the cluster
  
  # Step B: Export necessary functions and objects to the cluster workers
  clusterExport(cl, c("calc_mc_values", "sample_n", "%>%", "filtered_data_with_no_violations"))
  clusterEvalQ(cl, { library(dplyr) })  # Ensure each worker loads the required package

  # Step C: Group data by condition variables (Population, Lambda, N, Transitions)
  grouped_data <- data %>%
    group_by(Population, Lambda, N, Transitions) %>%  # ‚úÖ Include Lambda in grouping
    group_split()  # Split data so each group runs separately in parallel
  
  # Step D: Perform bootstrapping in parallel across worker nodes
  boot_results <- parLapply(cl, grouped_data, function(group_data) {
    map_dfr(1:n_bootstrap, function(i) {
      # Step D1: Draw a bootstrap sample (with replacement) from the replications in this condition
      boot_sample <- group_data %>% sample_n(sample_size, replace = TRUE)
      
      # Step D2: Calculate MC values for the bootstrap sample
      boot_mc <- calc_mc_values(boot_sample)
      
      # Step D3: Add Bootstrap Iteration number
      boot_mc %>% mutate(Bootstrap_Iteration = i)
    })
  }) %>%
    bind_rows()  # Step E: Combine results from all parallel workers into a single dataframe

  # Step F: Stop the parallel cluster to free system resources
  stopCluster(cl)

  # Step G: Return the final bootstrapped MC values
  return(boot_results)
}

# 3. Run the bootstrap procedure on your raw replication-level data
set.seed(07252005)
boot_results <- bootstrap_mc_values(filtered_data_with_no_violations, n_bootstrap = 1000, sample_size = 500)

# 4. Aggregate the bootstrap results to get mean bootstrap estimates per condition:
bootstrap_aggregates <- boot_results %>%
  group_by(Population, Lambda, N, Transitions) %>%  # ‚úÖ Include Lambda in grouping
  summarize(
    Parameter_Bias = mean(Parameter_Bias_boot, na.rm = TRUE),
    SE_Bias       = mean(SE_Bias_boot, na.rm = TRUE),
    .groups = "drop"
  )

# 5. Calculate your original mc_values (using the full replication set) for comparison:
original_mc_values <- calc_mc_values(filtered_data_with_no_violations)

# 6. Merge the bootstrap aggregates back to the original values (if desired)
final_mc_values <- original_mc_values %>%
  left_join(bootstrap_aggregates, by = c("Population", "Lambda", "N", "Transitions")) %>%  # ‚úÖ Join by Population, Lambda, and N
  mutate(
    Power_Dic    = ifelse(Power >= 0.8, 1, 0),
    Coverage_Dic = ifelse(Coverage > 0.98 | Coverage < 0.91, 0, 1)
  )

# Save or inspect the results
# Save results
write.csv(final_mc_values, here("Simulations", "STUDY_1", "3 Time Points", "zbootstrapping", "r_l_3t_mc_final_mc_values.csv"), row.names = FALSE)
write.csv(boot_results, here("Simulations", "STUDY_1", "3 Time Points", "zbootstrapping", "r_l_3t_boot_results.csv"), row.names = FALSE)

```

# RUN Parameter Bias ANOVA

```{r}
#| label: "parameter-bias-anova-rilta-lta"
#| echo: true
#| message: false
#| warning: false
#| fig.width: 6
#| fig.height: 4

# Load libraries
library(ggplot2)
library(emmeans)
library(multcomp)
library(dplyr)
library(car)
library(here)
library(effectsize)
library(stringr)

# Load your data and preprocess Lambda for facet labels
final_mc_values <- read.csv(
  here("Simulations", "STUDY_1", "3 Time Points", "zbootstrapping", "r_l_3t_mc_final_mc_values.csv")
) %>%
  filter(!is.na(Population), !is.na(N), !is.na(Lambda)) %>%
  mutate(
    Population = factor(Population, levels = c(0.2, 0.3, 0.4, 0.6, 0.7, 0.8),
                        labels = c(".200", ".300", ".400", ".600", ".700", ".800")),
    N_numeric = as.numeric(str_remove(N, "N = ")),
    N = factor(str_remove(N, "N = "), levels = c("500", "1000", "2000", "4000")),
    Lambda = factor(Lambda, labels = c("Œª = 0", "Œª = 0.2", "Œª = 0.4", "Œª = 0.6", "Œª = 0.8", "Œª = 1")),
    # Create a new column with formatted labels for facet_wrap
    Lambda_label = sapply(Lambda, function(x) {
      value <- sub("^Œª\\s*", "", x)  # Extract "= 0", "= 0.2", etc.
      paste0("italic(Œª) * '", value, "'")  # Format as "italic(Œª) * '= 0'"
    })
  ) %>%
  droplevels()

# Run Type II ANOVAs using explicit interaction terms
anova_np <- Anova(aov(Parameter_Bias ~ N_numeric + Population + N_numeric:Population, data = final_mc_values), type = "II")
anova_nl <- Anova(aov(Parameter_Bias ~ N_numeric + Lambda + N_numeric:Lambda, data = final_mc_values), type = "II")
anova_pl <- Anova(aov(Parameter_Bias ~ Population + Lambda + Population:Lambda, data = final_mc_values), type = "II")

# Print each ANOVA table
print(anova_np)
print(anova_nl)
print(anova_pl)

# Main effects only ANOVA (for pairwise comparisons)
anova_main <- aov(Parameter_Bias ~ N_numeric + Population + Lambda, data = final_mc_values)
anova_main_type2 <- Anova(anova_main, type = "II")
print(anova_main_type2)

# Calculate partial eta squared values
print(eta_squared(anova_main_type2, partial = TRUE))
print(eta_squared(anova_np, partial = TRUE))
print(eta_squared(anova_nl, partial = TRUE))
print(eta_squared(anova_pl, partial = TRUE))

# Pairwise comparisons: Population (collapsed over N and Lambda)
em <- emmeans(anova_main, pairwise ~ Population)
pairwise_results <- summary(em$contrasts, infer = TRUE)

# Plot for Parameter_Bias
bias_plot <- ggplot(final_mc_values, aes(x = Population, y = Parameter_Bias, fill = N)) +
  stat_summary(fun = mean, geom = "bar", position = position_dodge(0.8), width = 0.7) +
  stat_summary(fun.data = mean_se, geom = "errorbar", position = position_dodge(0.8), width = 0.2) +
  labs(
    x = expression(italic(T)[11]),
    y = "Parameter Bias (%)",
    fill = expression(italic(N))
  ) +
  scale_y_continuous(breaks = seq(-20, 160, by = 20)) +
  facet_wrap(~ Lambda_label, drop = FALSE, labeller = label_parsed) +
  theme_minimal(base_size = 12) +
  theme(
    axis.title = element_text(face = "plain"),
    text = element_text(family = "Avenir Next"),
    legend.position = "bottom",
    legend.title = element_text(face = "bold"),
    legend.text = element_text(size = 10)
  )

print(bias_plot)
```

```{r}
#| label: "save-anova-bias-figure-rilta-lta"
#| echo: true
#| message: false
#| warning: false

invisible(ggsave(
  filename = here("Simulations", "STUDY_1", "3 Time Points", "zposthoc", "r_l_3t_bias_visuals", "r_l_3t_ANOVA_BIAS_plot.svg"),
  plot = bias_plot,
  width = 7,
  height = 5,
  units = "in",
  dpi = 300
))
```

Create ANOVA Table

```{r}
#| label: "bias-anova-table"
#| echo: true
#| message: false
#| warning: false

library(dplyr)
library(flextable)
library(broom)
library(effectsize)

# Extract and clean ANOVA results
extract_anova_results <- function(anova_model, model_name) {
  tidy_table <- broom::tidy(anova_model)
  eta_table <- effectsize::eta_squared(anova_model, partial = TRUE)

  merged_table <- left_join(
    tidy_table,
    eta_table,
    by = c("term" = "Parameter")
  )

  df <- merged_table %>%
    dplyr::filter(!term %in% c("Residuals", "(Intercept)")) %>%
    dplyr::mutate(
      ANOVA = model_name,
      df = paste0(df, ", ", merged_table$df[merged_table$term == "Residuals"][1]),
      Effect = dplyr::case_when(
        term == "N_numeric" ~ "N",
        term == "Population" ~ "T‚ÇÅ‚ÇÅ",
        term == "Lambda" ~ "Œª",
        term == "N_numeric:Population" ~ "N:T‚ÇÅ‚ÇÅ",
        term == "N_numeric:Lambda" ~ "N:Œª",
        term == "Population:Lambda" ~ "T‚ÇÅ‚ÇÅ:Œª",
        TRUE ~ term
      )
    ) %>%
    dplyr::select(ANOVA, Effect, df, statistic, p.value, Eta2_partial) %>%
    dplyr::rename(F = statistic, p = p.value, Partial_Eta_Sq = Eta2_partial)

  return(df)
}

# Combine results
anova_results <- dplyr::bind_rows(
  extract_anova_results(anova_main, "Main Effects"),
  extract_anova_results(anova_np, "N √ó T‚ÇÅ‚ÇÅ"),
  extract_anova_results(anova_nl, "N √ó Œª"),
  extract_anova_results(anova_pl, "T‚ÇÅ‚ÇÅ √ó Œª")
)

# Format results
anova_results_fmt <- anova_results %>%
  dplyr::mutate(
    F = round(F, 2),
    p = sapply(p, function(x) {
      if (is.na(x)) return("")
      if (x < 0.001) return("<.001")
      return(sub("^0\\.", ".", sprintf("%.3f", x)))
    }),
    Partial_Eta_Sq = sapply(Partial_Eta_Sq, function(x) {
      if (is.na(x)) return("")
      return(sub("^0\\.", ".", sprintf("%.3f", x)))
    })
  )

# Create table
bias_anova_table <- flextable(anova_results_fmt) %>%
  set_caption("ANOVA Results for Parameter Bias Rate") %>%
  set_header_labels(
    ANOVA = "ANOVA",
    Effect = "Effect",
    df = "df",
    F = "F",
    p = "p",
    Partial_Eta_Sq = "Partial Œ∑¬≤"
  ) %>%
  compose(part = "header", j = "df", value = as_paragraph(as_i("df"))) %>%
  compose(part = "header", j = "F", value = as_paragraph(as_i("F"))) %>%
  compose(part = "header", j = "p", value = as_paragraph(as_i("p"))) %>%
  compose(part = "header", j = "Partial_Eta_Sq", value = as_paragraph("Partial ", as_i("Œ∑¬≤"))) %>%
  compose(part = "body", j = "Effect", i = ~ Effect == "N", value = as_paragraph(as_i("N"))) %>%
  compose(part = "body", j = "Effect", i = ~ Effect == "T‚ÇÅ‚ÇÅ", value = as_paragraph(as_i("T"), as_sub("11"))) %>%
  compose(part = "body", j = "Effect", i = ~ Effect == "Œª", value = as_paragraph(as_i("Œª"))) %>%
  compose(part = "body", j = "Effect", i = ~ Effect == "N:T‚ÇÅ‚ÇÅ", value = as_paragraph(as_i("N"), ":", as_i("T"), as_sub("11"))) %>%
  compose(part = "body", j = "Effect", i = ~ Effect == "N:Œª", value = as_paragraph(as_i("N"), ":", as_i("Œª"))) %>%
  compose(part = "body", j = "Effect", i = ~ Effect == "T‚ÇÅ‚ÇÅ:Œª", value = as_paragraph(as_i("T"), as_sub("11"), ":", as_i("Œª"))) %>%
  compose(part = "body", j = "p", i = ~ grepl("<", p) | as.numeric(p) < 0.05,
          value = as_paragraph(as_b(p))) %>%
  merge_v(j = "ANOVA") %>%
  compose(part = "body", j = "ANOVA", i = ~ ANOVA == "Main Effects", value = as_paragraph("Main Effects")) %>%
  compose(part = "body", j = "ANOVA", i = ~ ANOVA == "N √ó T‚ÇÅ‚ÇÅ", value = as_paragraph(as_i("N"), " √ó ", as_i("T"), as_sub("11"))) %>%
  compose(part = "body", j = "ANOVA", i = ~ ANOVA == "N √ó Œª", value = as_paragraph(as_i("N"), " √ó ", as_i("Œª"))) %>%
  compose(part = "body", j = "ANOVA", i = ~ ANOVA == "T‚ÇÅ‚ÇÅ √ó Œª", value = as_paragraph(as_i("T"), as_sub("11"), " √ó ", as_i("Œª"))) %>%
  valign(j = "ANOVA", valign = "center", part = "body") %>%
  width(j = "ANOVA", width = 1.5) %>%
  width(j = "Effect", width = 2.0) %>%
  width(j = "df", width = 0.8) %>%
  width(j = "F", width = 0.8) %>%
  width(j = "p", width = 0.8) %>%
  width(j = "Partial_Eta_Sq", width = 1.0) %>%
  bg(i = ~ ANOVA %in% c("Main Effects", "N √ó Œª"), bg = "#f0f0f0", part = "body") %>%
  border_remove() %>%
  hline_top(border = fp_border(color = "black", width = 1), part = "all") %>%
  hline_bottom(border = fp_border(color = "black", width = 1), part = "all") %>%
  font(fontname = "Avenir Next", part = "all") %>%
  fontsize(size = 12, part = "all") %>%
  align(align = "center", part = "all") %>%
  padding(padding.top = 2.5, padding.bottom = 2.5, part = "all") %>%
  padding(padding.left = 2.5, padding.right = 2.5, part = "all") %>%
  set_table_properties(layout = "fixed")

# Print
print(bias_anova_table)
```

Save ANOVA Table

```{r}
# Save the anova_table as an SVG in the correct directory
invisible(flextable::save_as_image(bias_anova_table, path = here::here("Simulations", "STUDY_1", "3 Time Points", "zposthoc", "r_l_3t_bias_visuals", "r_l_3t_bias_anova_table.svg")))
```

**Create Pairwise Comparisons Table**

```{r}
#| label: "function-format-pairwise-rilta-lta"
#| include: false

format_pairwise_ft <- function(df, group_label) {


  # Ensure flextable defaults are set
  set_flextable_defaults(word_wrap = FALSE)

  # Step 1: Process the pairwise results dataframe
  df <- df %>%
    dplyr::mutate(
      Estimate   = round(as.numeric(estimate), 2),
      SE         = round(as.numeric(SE), 2),
      Lower_CL   = round(as.numeric(lower.CL), 2),
      Upper_CL   = round(as.numeric(upper.CL), 2),
      t_val      = round(as.numeric(t.ratio), 2),
      p_val      = round(as.numeric(p.value), 3),
      p          = ifelse(p_val < .001, "< .001", sub("^0", "", format(p_val, nsmall = 3))),
      Effect     = paste0(
        format(Estimate, nsmall = 2), " (",
        format(Lower_CL, nsmall = 2), ", ",
        format(Upper_CL, nsmall = 2), ")"
      )
    )

  # Step 2: Format contrast labels in the dataframe
  left_right <- stringr::str_match(df$contrast, "Population\\.(\\d{3}) - Population\\.(\\d{3})")
  df <- df %>%
    dplyr::mutate(
      contrast_formatted = paste0(
        "T‚ÇÅ‚ÇÅ = .", left_right[, 2], " ‚Äì T‚ÇÅ‚ÇÅ = .", left_right[, 3]
      )
    )

  # Step 3: Select columns for the table
  pairwise_clean <- df %>%
    dplyr::select(contrast_formatted, Effect, SE, df, t_val, p) %>%
    dplyr::rename(
      Contrast = contrast_formatted,
      t = t_val
    )

  # Step 4: Create the flextable
  ft <- flextable(pairwise_clean) %>%
    set_header_labels(
      Contrast = "Contrast",
      Effect   = "Estimate (95% CI)",
      SE       = "SE",
      df       = "df",
      t        = "t",
      p        = "p"
    ) %>%
    # Italicize headers using mk_par
    mk_par(part = "header", j = "SE", value = as_paragraph(as_i("SE"))) %>%
    mk_par(part = "header", j = "df", value = as_paragraph(as_i("df"))) %>%
    mk_par(part = "header", j = "t", value = as_paragraph(as_i("t"))) %>%
    mk_par(part = "header", j = "p", value = as_paragraph(as_i("p"))) %>%
    colformat_double(j = c("SE", "t"), digits = 2) %>%
    align(j = c("Contrast", "Effect", "df", "p"), align = "center", part = "all") %>%
    width(j = "Contrast", width = 2.2) %>%
    width(j = "Effect", width = 2.5) %>%
    line_spacing(space = 0.9, part = "all") %>%
    padding(j = "Contrast", padding.top = 1, padding.bottom = 1, part = "all")

  # Step 5: Bold significant p-values
  sig_rows <- which(df$p_val < 0.05)
  ft <- bold(ft, i = sig_rows, j = "p", bold = TRUE, part = "body")

  # Step 6: Apply APA styling
  thin <- fp_border(color = "black", width = 1)
  ft <- ft %>%
    border_remove() %>%
    font(fontname = "Avenir Next", part = "all") %>%
    fontsize(size = 12, part = "all") %>%
    align(align = "center", part = "all") %>%
    set_table_properties(layout = "fixed") %>%
    hline(i = 1, border = thin, part = "header") %>%
    hline_top(border = thin, part = "all") %>%
    hline_bottom(border = thin, part = "all") %>%
    add_header_row(
      values = group_label,
      colwidths = ncol(pairwise_clean)
    ) %>%
    merge_h(part = "header") %>%
    line_spacing(i = 1, space = 1.5, part = "header") %>%
    padding(i = 1, padding.top = 3, padding.bottom = 3, part = "header") %>%
    fontsize(i = 1, size = 11, part = "header")

  return(ft)
}
```

Create Lambda Bias Pairwise Tables

```{r}
#| label: "pairwise-comparisons-lambda-rilta-lta"
#| echo: true
#| message: false
#| warning: false

# Load required packages
library(flextable)
library(dplyr)
library(stringr)
library(officer)

# Refit the model with interactions
anova_main_lambda <- aov(Parameter_Bias ~ N_numeric + Population * Lambda, data = final_mc_values)

# Get all pairwise comparisons by Lambda, explicitly specifying levels
lambda_levels <- c("Œª = 0", "Œª = 0.2", "Œª = 0.4", "Œª = 0.6", "Œª = 0.8", "Œª = 1")
all_comparisons <- summary(emmeans(anova_main_lambda, pairwise ~ Population | Lambda, 
                                   at = list(Lambda = lambda_levels))$contrasts, infer = TRUE)

# Split into list by Lambda
pairwise_list <- split(all_comparisons, all_comparisons$Lambda)

# Create Lambda-specific tables with simplified group labels
flextable_list <- lapply(names(pairwise_list), function(lam) {
  group_label <- lam  # Just use the Lambda value (e.g., "Œª = 0")
  format_pairwise_ft(pairwise_list[[lam]], group_label)
})

# Explicitly print each table
print(flextable_list[[1]])
print(flextable_list[[2]])
print(flextable_list[[3]])
print(flextable_list[[4]])
print(flextable_list[[5]])
print(flextable_list[[6]])
```

\
Save Pairwise Tables

```{r}
#| label: "save-comparisons-table"
#| echo: false
#| message: false
#| warning: false

# Save tables by lambda
invisible(save_as_image(flextable_list[[1]], path = here("Simulations", "STUDY_1", "3 Time Points", "zposthoc", "r_l_3t_bias_visuals", "r_l_3t_pairwise_bias_lambda_0.svg")))
invisible(save_as_image(flextable_list[[2]], path = here("Simulations", "STUDY_1", "3 Time Points", "zposthoc", "r_l_3t_bias_visuals", "r_l_3t_pairwise_bias_lambda_0.2.svg")))
invisible(save_as_image(flextable_list[[3]], path = here("Simulations", "STUDY_1", "3 Time Points", "zposthoc", "r_l_3t_bias_visuals", "r_l_3t_pairwise_bias_lambda_0.4.svg")))
invisible(save_as_image(flextable_list[[4]], path = here("Simulations", "STUDY_1", "3 Time Points", "zposthoc", "r_l_3t_bias_visuals", "r_l_3t_pairwise_bias_lambda_0.6.svg")))
invisible(save_as_image(flextable_list[[5]], path = here("Simulations", "STUDY_1", "3 Time Points", "zposthoc", "r_l_3t_bias_visuals", "r_l_3t_pairwise_bias_lambda_0.8.svg")))
invisible(save_as_image(flextable_list[[6]], path = here("Simulations", "STUDY_1", "3 Time Points", "zposthoc", "r_l_3t_bias_visuals", "r_l_3t_pairwise_bias_lambda_1.svg")))



```

------------------------------------------------------------------------

## Prepare Data for Visualization

### Subset Data for Bias Plots

*Subset the Monte Carlo data into mover transition probabilities (.2, .3, .4) and stayer transition probabilities (.6, .7, .8) based on population values*

```{r}
#| label: "subset-data-for-bias-plots"
#| echo: true
#| message: false
#| warning: false
#| code-fold: false

final_mc_values <- read.csv(here("Simulations", "STUDY_1", "3 Time Points", "zbootstrapping", "r_l_3t_mc_final_mc_values.csv"))

# Assuming Population is numeric in all_data
all_data <- final_mc_values

# Convert N to a factor with the correct labels for plotting
all_data <- all_data %>%
  mutate(N = factor(N,
                    levels = c("N = 500", "N = 1000", "N = 2000", "N = 4000"),  # These are the existing labels
                    labels = c(`1` = "N = 500", 
                               `2` = "N = 1000", 
                               `3` = "N = 2000", 
                               `4` = "N = 4000")))

# Define the labels for N using expression() for italics, which will be used in plotting
n_labels <- c(
  `1` = expression(italic('N') ~ "= 500"),
  `2` = expression(italic('N') ~ "= 1000"),
  `3` = expression(italic('N') ~ "= 2000"),
  `4` = expression(italic('N') ~ "= 4000")
)

# Assign the labels to the levels
all_data$N <- factor(all_data$N, labels = n_labels)
# Now you can use `n_labels` in the plotting code

# Ensure that the Population_Label uses numeric levels without leading zeros but assigns expression-based labels
all_data$Population_Label <- factor(all_data$Population, 
    levels = c(0.2, 0.3, 0.4, 0.6, 0.7, 0.8),  # Numeric levels without leading zeros
    labels = c(
        expression(bold(italic(T))[11] ~ " = .200"),
        expression(bold(italic(T))[11] ~ " = .300"),
        expression(bold(italic(T))[11] ~ " = .400"),
        expression(bold(italic(T))[11] ~ " = .600"),
        expression(bold(italic(T))[11] ~ " = .700"),
        expression(bold(italic(T))[11] ~ " = .800")
    )
)

# Subset for Transitions movers (already correctly defined as "Mover")
subset_mover <- subset(all_data, Transitions == "Mover")
subset_mover <- subset_mover %>%
  mutate(Lambda = as.numeric(as.character(Lambda)))

# Subset for Transitions stayers (already correctly defined as "Stayer")
subset_stayer <- subset(all_data, Transitions == "Stayer")
subset_stayer <- subset_stayer %>%
  mutate(Lambda = as.numeric(as.character(Lambda)))
```

### Prepare Function for Bias Plots

```{r}
#| label: "plot-bias"
#| echo: true
#| message: false
#| warning: false
#| code-fold: false

# Define common themes and aesthetics
common_theme <- theme_minimal() +
  theme(
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank(),
    panel.grid.minor.y = element_blank(),
    axis.text.x = element_text(size = 10),  # X-axis labels (tick marks)
    axis.text.y = element_text(size = 10),  
    axis.title.x = element_text(size = 11, margin = margin(t = 10, b = 10)),  # X-axis title
    axis.title.y = element_text(size = 11),
    axis.ticks = element_line(color = "black", linewidth = 0.5),
    legend.position = "bottom",
    legend.title = element_blank(),
    legend.text = element_text(size = 11),
    text = element_text(family = "Avenir Next", size = 11),
    legend.margin = margin(t = -10),
    plot.caption = element_text(size = 11, hjust = 0, margin = margin(t = 10)),
    strip.text = element_text(size = 11)
  )

create_plot <- function(data, title_suffix) {
  # Detect which legend items to show
  present_categories <- c("Parameter Bias", "Standard Error Bias")  # Base categories
  if (any(data$Coverage_Dic == 0)) present_categories <- c(present_categories, "Coverage Failure")
  if (any(data$Power_Dic == 0)) present_categories <- c(present_categories, "Power Failure")

  # Define colors and shapes for different categories
  colors <- c("Parameter Bias" = "#7030A0", "Standard Error Bias" = "#C830CC", 
              "Coverage Failure" = "#7030A0", "Power Failure" = "black")
  shapes <- c("Parameter Bias" = 16, "Standard Error Bias" = 18, 
              "Coverage Failure" = 1, "Power Failure" = 4)

  # Filter colors and shapes based on detected categories
  filtered_colors <- colors[present_categories]
  filtered_shapes <- shapes[present_categories]

  base_plot <- ggplot(data, aes(x = Lambda, y = Parameter_Bias, color = "Parameter Bias", group = Population_Label)) +
    geom_line(aes(group = Population_Label), linewidth = .7, linetype = "solid") +
    geom_line(aes(y = SE_Bias, group = Population_Label, color = "Standard Error Bias"), linewidth = .7, linetype = "solid") +
    geom_point(aes(y = Parameter_Bias), shape = shapes["Parameter Bias"], size = 1.5, fill = colors["Parameter Bias"], alpha = 1) +
    geom_point(aes(y = SE_Bias, color = "Standard Error Bias"), shape = shapes["Standard Error Bias"], size = 2, fill = colors["Standard Error Bias"], alpha = 1) +
    geom_point(data = subset(data, Coverage_Dic == 0), aes(y = Parameter_Bias, color = "Coverage Failure"), shape = shapes["Coverage Failure"], size = 2.5, fill = colors["Coverage Failure"], alpha = 1) +
    geom_point(data = subset(data, Power_Dic == 0), aes(y = Parameter_Bias, color = "Power Failure"), shape = shapes["Power Failure"], size = 2, fill = colors["Power Failure"], alpha = 1) +
scale_color_manual(values = filtered_colors, labels = present_categories, breaks = present_categories, guide = guide_legend(override.aes = list(shape = filtered_shapes))
) +
    labs(
      x = "Lambda Loadings on the Random Intercept",
      y = "Bias (%)",
      color = "",
      title = paste("RILTA Generated, LTA Analyzed with", title_suffix, "Transition Probabilities")
    ) +
    facet_grid(Population_Label ~ N, scales = "free_x", labeller = label_parsed) +
    scale_x_continuous(breaks = seq(0, 1, by = 0.2), labels = scales::number_format(accuracy = 0.1)) +
    common_theme +
    geom_hline(yintercept = c(-10, 10), linetype = "dashed", color = "#7030A0", linewidth = 0.4) +
    geom_hline(yintercept = c(-5, 5), linetype = "dashed", color = "#C830CC", linewidth = 0.4)

# Set y-axis limits based on the plot type
if (title_suffix == "Stayer") {
  base_plot <- base_plot + scale_y_continuous(limits = c(-20, 40), breaks = seq(-20, 40, by = 20))
} else {  # Assume "Mover"
  # Manually specify breaks to include 160
  base_plot <- base_plot + scale_y_continuous(limits = c(-20, 160), breaks = c(-20, 40, 80, 120, 160))
}
  return(base_plot)
}
```

### Render Bias Figures

```{r}
#| label: "plot-movers"
#| echo: true
#| message: false
#| warning: false
#| code-fold: false

# Create and print plot for Mover
plot_mover <- create_plot(subset_mover, "Mover")
#| column: screen
#| fig-format: svg
print(plot_mover)

# Remove title for the saved version
plot_mover_no_title <- plot_mover + labs(title = NULL)

# Save Mover plot without title as .svg
ggsave(here('Simulations', 'STUDY_1', "3 Time Points", "zFigures", "x3t_rilta_lta_plots", "plot_mover.svg"), plot = plot_mover_no_title, width = 6, height = 4, dpi = 300, device = "svg")
```

```{r}
#| label: "plot-stayers"
#| echo: true
#| message: false
#| warning: false
#| code-fold: false

plot_stayer <-  create_plot(subset_stayer, "Stayer")

#| column: screen
#| fig-format: svg
print(plot_stayer)

# Remove title for the saved version
plot_stayer_no_title <- plot_stayer + labs(title = NULL)

# Save Stayer plot without title as .svg
ggsave(here('Simulations', 'STUDY_1', "3 Time Points", "zFigures", "x3t_rilta_lta_plots", "plot_stayer.svg"), plot = plot_stayer_no_title, width = 6, height = 4, dpi = 300, device = "svg")
```

------------------------------------------------------------------------

## **Prepare Data for Heat Maps**

*Prepare data for heat map creation by ensuring correct formatting for population values, and subsetting the data based on class proportions and sample sizes.*

```{r}
#| label: "prepare-data-for-heatmaps"
#| echo: true
#| message: false
#| warning: false
#| code-fold: false

# Prepare heatmap data
heatmap_data <- all_data %>%
  # Create a markdown-formatted N_Label column
  mutate(
    N_Label = case_when(
      N == levels(N)[1] ~ "*N* = 500",
      N == levels(N)[2] ~ "*N* = 1000",
      N == levels(N)[3] ~ "*N* = 2000",
      N == levels(N)[4] ~ "*N* = 4000",
      TRUE ~ NA_character_
    ),
    # Extract numeric part of N for correct sorting
    N_numeric = as.numeric(str_remove(N_Label, "\\*N\\* = ")),
    # Convert Population to plain-text factor levels
    Population = factor(
      Population,
      levels = c(0.2, 0.3, 0.4, 0.6, 0.7, 0.8),
      labels = c(".200", ".300", ".400", ".600", ".700", ".800")
    )
  ) %>%
  # Arrange by Lambda, then numeric N, then Population
  arrange(Lambda, N_numeric, Population)

# Clean up data for heatmaps
heatmap_data_clean <- heatmap_data %>%
  dplyr::select(N_Label, Population, average, Coverage, Power, Parameter_Bias, SE_Bias)

# Define the population values as characters
population_values <- c(".200", ".300", ".400", ".600", ".700", ".800")

# Function to subset the data for a specific population value
subset_data <- function(data, pop_value) {
  data %>%
    filter(Population == pop_value)
}

# Apply the function to each population value
subset_list <- lapply(population_values, function(x) subset_data(heatmap_data_clean, x))

# Access the subsets for each population value
subset_02 <- subset_list[[1]]  # Subset for population value .200
subset_03 <- subset_list[[2]]  # Subset for population value .300
subset_04 <- subset_list[[3]]  # Subset for population value .400
subset_06 <- subset_list[[4]]  # Subset for population value .600
subset_07 <- subset_list[[5]]  # Subset for population value .700
subset_08 <- subset_list[[6]]  # Subset for population value .800

```

### Prepare Function for Heat Map Creation

```{r}
#| label: "create-heatmap-function"
#| echo: true
#| message: false
#| warning: false
#| code-fold: false

create_table <- function(subset, transition_probability) {

  gt_table <- subset %>%
    gt() %>%
    opt_table_font(font = "Avenir Next") %>%
    fmt_markdown(columns = "N_Label") %>%
    cols_label(
      N_Label        = "Sample Size",
      Population = md("*T*<sub>11</sub>"),
      average        = md("Estimated<br>*T*<sub>11</sub>"),
      Coverage       = "Coverage",
      Power          = "Power",
      Parameter_Bias = "Parameter<br>Bias",
      SE_Bias        = "SE<br>Bias",
      .fn            = md
    ) %>%
    tab_spanner(
      label   = "Bias",
      columns = c("Parameter_Bias", "SE_Bias")
    ) %>%
    tab_row_group(label = "Lambda RI Loading of 0 (Œª)",  rows =  1: 4) %>%
    tab_row_group(label = "Lambda RI Loading of .2 (Œª)", rows =  5: 8) %>%
    tab_row_group(label = "Lambda RI Loading of .4 (Œª)", rows =  9:12) %>%
    tab_row_group(label = "Lambda RI Loading of .6 (Œª)", rows = 13:16) %>%
    tab_row_group(label = "Lambda RI Loading of .8 (Œª)", rows = 17:20) %>%
    tab_row_group(label = "Lambda RI Loading of 1 (Œª)", rows = 21:24) %>%
    tab_style(
      style     = cell_text(weight = "normal", style = "italic"),
      locations = cells_row_groups()
    ) %>%
    fmt_number(columns = c("Parameter_Bias","SE_Bias"), decimals = 2) %>%
    fmt_number(columns = 3, decimals = 3) %>%
text_transform(
  locations = cells_body(columns = c("average", "Coverage", "Power")),
  fn = function(x) sub("^0\\.", ".", x)
) %>%
    tab_options(
      # striping off, sizing & padding
      row.striping.include_table_body    = FALSE,
      table.width                         = pct(75),
      data_row.padding                    = px(0),
      heading.padding                     = px(0),
      column_labels.padding               = px(0),
      row_group.padding                   = px(0),

      # remove default GT hlines
      table_body.hlines.color             = "white",

      # **fix the two stray grey lines**: make table‚Äêbody borders 1px black
      table_body.border.top.color         = "black",
      table_body.border.top.width         = px(1),
      table_body.border.bottom.color      = "black",
      table_body.border.bottom.width      = px(1),

      # outer box
      table.border.top.color              = "black",
      table.border.top.width              = px(1),
      table.border.bottom.color           = "black",
      table.border.bottom.width           = px(1),

      # title underline
      heading.border.bottom.color         = "black",
      heading.border.bottom.width         = px(1),

      # column‚Äêlabel box
      column_labels.border.top.color      = "black",
      column_labels.border.top.width      = px(1),
      column_labels.border.bottom.color   = "black",
      column_labels.border.bottom.width   = px(1),

      # row‚Äêgroup separators
      row_group.border.top.color          = "black",
      row_group.border.top.width          = px(1),
      row_group.border.bottom.color       = "black",
      row_group.border.bottom.width       = px(1)
    ) %>%
    cols_align(
      align   = "center",
      columns = everything()
    ) %>%
    # thin only the "Bias" spanner borders
    tab_style(
      style     = cell_borders(sides = c("top","bottom"), weight = px(1), color = "black"),
      locations = cells_column_spanners()
    ) %>%
    # ensure the underline under the title is black 1px
    tab_style(
      style     = cell_borders(sides = "bottom", weight = px(1), color = "black"),
      locations = cells_title(groups = "title")
    ) %>%
    # ensure the top border above each Lambda‚ÄëRI group is black 1px
    tab_style(
      style     = cell_borders(sides = "top", weight = px(1), color = "black"),
      locations = cells_row_groups()
    )

  # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî your existing color logic ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
  if (any(!(subset$Parameter_Bias >= -9.99 & subset$Parameter_Bias <= 9.99), na.rm = TRUE)) {
    gt_table <- gt_table %>%
      data_color(
        columns = "Parameter_Bias",
        rows    = .data$Parameter_Bias < -9.99 | .data$Parameter_Bias > 9.99,
        method  = "numeric",
        palette = c("#113386","#DAE3FA","#113386"),
        domain  = c(-160,166)
      ) %>%
      tab_footnote(
        footnote  = md("Darker blue indicates larger deviations from zero *Parameter Bias* beyond the ¬±9.99 threshold."),
        locations = cells_column_labels(columns = "Parameter_Bias")
      )
  }

  if (any(!(subset$SE_Bias >= -4.99 & subset$SE_Bias <= 4.99), na.rm = TRUE)) {
    gt_table <- gt_table %>%
      data_color(
        columns = "SE_Bias",
        rows    = .data$SE_Bias < -4.99 | .data$SE_Bias > 4.99,
        method  = "numeric",
        palette = c("#781049","#FDEAF4","#781049"),
        domain  = c(-80,80)
      ) %>%
      tab_footnote(
        footnote  = md("Darker red indicates larger deviations from zero *Standard Error Bias* beyond the ¬±4.99 threshold."),
        locations = cells_column_labels(columns = "SE_Bias")
      )
  }

  if (any(subset$Coverage < 0.93 | subset$Coverage > 0.979, na.rm = TRUE)) {
    gt_table <- gt_table %>%
      data_color(
        columns = "Coverage",
        rows    = subset$Coverage < 0.91 | subset$Coverage > 0.979,
        method  = "numeric",
        palette = c("#93C6B1","white"),
        domain  = c(0,1)
      ) %>%
      tab_footnote(
        footnote  = md("Green indicates failure to achieve adequate *Coverage*."),
        locations = cells_column_labels(columns = "Coverage")
      )
  }

  if (any(subset$Power < 0.8, na.rm = TRUE)) {
    gt_table <- gt_table %>%
      data_color(
        columns = "Power",
        rows    = subset$Power < 0.8,
        method  = "numeric",
        palette = c("#502CD1","white"),
        domain  = c(0,1)
      ) %>%
      tab_footnote(
        footnote  = md("Purple indicates failure to achieve adequate *Power*."),
        locations = cells_column_labels(columns = "Power")
      )
  }

  return(gt_table)
}

```

### Render Heat maps

#### TABLE FOR TRANSITION PROBABILITIES OF .200

```{r}
#| label: "create-heatmap-tabe-.200"
#| echo: true
#| message: false
#| warning: false
#| code-fold: false

subset_02_table <- create_table(subset_02, ".200")

subset_02_table

subset_02_table |>  tab_options(table.width = pct(75)) |> gtsave(here('Simulations', 'STUDY_1', '3 Time Points', "zHeatmaps", "z3t_r_l_heatmaps", "3t_r_l_.200.png"))
```

#### TABLE FOR TRANSITION PROBABILITIES OF .300

```{r}
#| label: "create-heatmap-tabe-.300"
#| echo: true
#| message: false
#| warning: false
#| code-fold: false


subset_03_table <- create_table(subset_03, ".300")
subset_03_table
subset_03_table |>  tab_options(table.width = pct(75)) |> gtsave(here('Simulations', 'STUDY_1', '3 Time Points', "zHeatmaps", "z3t_r_l_heatmaps","3T_R_L_.300.png"))
```

#### TABLE FOR TRANSITION PROBABILITIES OF .400

```{r}
#| label: "create-heatmap-tabe-.400"
#| echo: true
#| message: false
#| warning: false
#| code-fold: false

subset_04_table <- create_table(subset_04, ".400")
subset_04_table
subset_04_table |>  tab_options(table.width = pct(75)) |> gtsave(here('Simulations', 'STUDY_1', '3 Time Points', "zHeatmaps", "z3t_r_l_heatmaps","3T_R_L_.400.png"))
```

#### TABLE FOR TRANSITION PROBABILITIES OF .600

```{r}
#| label: "create-heatmap-tabe-.600"
#| echo: true
#| message: false
#| warning: false
#| code-fold: false


subset_06_table <- create_table(subset_06, ".600")
subset_06_table
subset_06_table |>  tab_options(table.width = pct(75)) |> gtsave(here('Simulations', 'STUDY_1', '3 Time Points', "zHeatmaps", "z3t_r_l_heatmaps","3T_R_L_.600.png"))
```

#### TABLE FOR TRANSITION PROBABILITIES OF .700

```{r}
#| label: "create-heatmap-tabe-.700"
#| echo: true
#| message: false
#| warning: false
#| code-fold: false

subset_07_table <- create_table(subset_07, ".700")
subset_07_table
subset_07_table |>  tab_options(table.width = pct(75)) |> gtsave(here('Simulations', 'STUDY_1', '3 Time Points', "zHeatmaps","z3t_r_l_heatmaps","3T_R_L_.700.png"))
```

#### TABLE FOR TRANSITION PROBABILITIES OF .800

```{r}
#| label: "create-heatmap-tabe-.800"
#| echo: true
#| message: false
#| warning: false
#| code-fold: false


subset_08_table <- create_table(subset_08, ".800")

subset_08_table

subset_08_table |>  tab_options(table.width = pct(75)) |> gtsave(here('Simulations', 'STUDY_1', '3 Time Points', "zHeatmaps", "z3t_r_l_heatmaps","3T_R_L_.800.png"))
```
