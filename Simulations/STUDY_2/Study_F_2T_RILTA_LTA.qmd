---
title: "Understanding the Performance of Random Intercepts Latent Transition Analysis (RI-LTA): A Monte Carlo Simulation Study using MplusAutomation"
subtitle: "Study 2.3: RILTA Generated, LTA Analyzed with 3 Classes and  2 Timepoints"
author: "Delwin Carter"
date: "`r format(Sys.time(), '%B %d, %Y')`"

format:
  html:
    toc: true
    toc-title: "Overview"
    toc-depth: 3
    toc-float:
      collapsed: false
      smooth-scroll: true
    theme: flatly
    fig-format: svg
    font:
      main: "Avenir Next LT Pro, Arial, sans-serif"
    page-layout: full
    code-tools: true

editor: visual

knitr:
  opts_chunk:
    echo: true
    out.width: "100%"
    fig.align: "center"
---

------------------------------------------------------------------------

::: {layout-ncol="2"}
![](images/LVG%20FINAL.png){width="300"}

![](images/UCSB_Gauchos_logo_PNG2.png){width="300"}
:::

------------------------------------------------------------------------

## Study 2.3: RILTA Generated, RILTA Analyzed

------------------------------------------------------------------------

![](images/LTA_LTA-01.png){width="324"}

------------------------------------------------------------------------

Load Packages

```{r}
#| label: "load-libraries"
#| echo: true
#| message: false
#| warning: false

library(tidyverse)
library(MplusAutomation)
library(here)
library(gt)
library(janitor)
library(glue)
library(ggtext)
library(rlang)
library(knitr)
library(parallel)
library(tools)
library(webshot2)
library(flextable)
library(officer)
```

------------------------------------------------------------------------

# Simulation

------------------------------------------------------------------------

## Part 1: Conduct Simulation

> In this section, I am conducting a simulation where I am generating data as Latent Transition Analysis and analyzing it as Latent Transition Analysis to fully explore the model's performance. The simulation consists of over with 48 conditions including 3 different models, four sample sizes (N = 500, 1000, 2000, 4000)n six transition probabilities linked to logits (*betas;* 3.179, 0.407), corresponding to probabilities of .8 and .2., and 2 mixing proportions (even; 33.3%,, 33.3%, 33.3%), (uneven; 10%, 30%, 60%). These conditions are iterated over programmatically using MplusAutomation to set up and execute the models. To speed up the process, I employ parallel processing, which distributes computations across multiple CPU cores, enabling efficient completion of the simulations across all scenarios.

Conditions:

Sample Size: N = 500, 1000, 2500, 5000

Mixing Proportion: Even (33.3%,, 33.3%, 33.3%), Uneven (10%, 30%, 60%)

Transition logit (Probability): TPs = 3.179 (Stayer), 0.407 (Mover)

![](images/clipboard-2891141057.png){width="352"}

RI Loadings: Lambda = (Incremental; .3, .5, .7, 9) and (Varied; A, B, C, D)

Segment 1: Models 1 - 3 = Incremental Lambdas

![](images/clipboard-2109977150.png){width="554"}

Segment 2: Models 1A - 1D

Segment 3: Models 2A - 2D

Segment 4; Models 3A - 3D

![](images/clipboard-236077840.png){width="556"}

------------------------------------------------------------------------

### Setting up the Simulation Conditions

```{r}
#| label: "simulation-conditions-1"
#| echo: true
#| message: false
#| warning: false

# Define the simulation conditions
p1 <- expand.grid(N = c(500, 1000, 2500, 5000),
TPs = c(3.179, 0.407),
lambda = c(.3, .5, .7, .9), 
mix = c(1, 2))
       
# Display the matrix using gt
p1 %>%
  gt() %>%
  tab_header(
    title = "Simulation Conditions Matrix",
    subtitle = "Combinations of Sample Sizes, Transition Probabilities, Lambdas, and Mixing Propotions"
  ) %>%
  cols_align(
    align = "center",
    columns = everything() # Centers all columns
  )

```

```{r}
#| label: "simulation-conditions-1"
#| echo: true
#| message: false
#| warning: false

# Define all simulation conditions
p1 <- expand.grid(N = c(500, 1000, 2500, 5000),
                  TPs = c(3.179, 0.407),
                  lambda = c(0.3, 0.5, 0.7, 0.9), 
                  mix = c(1, 2, 3))

# Subsets for each computer (uncomment the line for the desired computer)

# Laptop: 24 conditions (N = 5000, all TPs, lambda, mix) - 11 cores available
p1 <- p1[p1$N == 5000, ]

# Desktop 1: 14 conditions (N = 500, TPs = 3.179, lambda = 0.3, 0.5, 0.7 + N = 1000, TPs = 0.407, mix = 1) - 5 cores available
#p1 <- p1[(p1$N == 500 & p1$TPs == 3.179 & p1$lambda %in% c(0.3, 0.5, 0.7)) | 
#         (p1$N == 1000 & p1$TPs == 0.407 & p1$mix == 1), ]

# Desktop 2: 14 conditions (N = 500, TPs = 0.407 + N = 1000, TPs = 3.179, mix = 1, lambda = 0.3, 0.5) - 5 cores available
#p1 <- p1[(p1$N == 500 & p1$TPs == 0.407) | 
#         (p1$N == 1000 & p1$TPs == 3.179 & p1$mix == 1 & p1$lambda %in% c(0.3, 0.5)), ]

# Desktop 3: 14 conditions (N = 1000, TPs = 3.179, mix = 2, 3 + N = 2500, TPs = 0.407, mix = 1, lambda = 0.3, 0.5 + N = 1000, TPs = 0.407, mix = 1) - 5 cores available
#p1 <- p1[(p1$N == 1000 & p1$TPs == 3.179 & p1$mix %in% c(2, 3)) | 
#         (p1$N == 2500 & p1$TPs == 0.407 & p1$mix == 1 & p1$lambda %in% c(0.3, 0.5)) | 
#         (p1$N == 1000 & p1$TPs == 0.407 & p1$mix == 1), ]

# Desktop 4: 14 conditions (N = 1000, TPs = 0.407, mix = 2, 3 + N = 2500, TPs = 3.179, mix = 1, lambda = 0.3, 0.5 + N = 2500, TPs = 0.407, mix = 2, lambda = 0.3, 0.5, 0.7) - 5 cores available
#p1 <- p1[(p1$N == 1000 & p1$TPs == 0.407 & p1$mix %in% c(2, 3)) | 
#         (p1$N == 2500 & p1$TPs == 3.179 & p1$mix == 1 & p1$lambda %in% c(0.3, 0.5)) | 
#         (p1$N == 2500 & p1$TPs == 0.407 & p1$mix == 2 & p1$lambda %in% c(0.3, 0.5, 0.7)), ]

# Desktop 5: 14 conditions (N = 2500, TPs = 3.179, mix = 2, 3 + N = 2500, TPs = 0.407, mix = 3, lambda = 0.3, 0.5 + N = 2500, TPs = 0.407, mix = 1, lambda = 0.7, 0.9) - 5 cores available
#p1 <- p1[(p1$N == 2500 & p1$TPs == 3.179 & p1$mix %in% c(2, 3)) | 
#         (p1$N == 2500 & p1$TPs == 0.407 & p1$mix == 3 & p1$lambda %in% c(0.3, 0.5)) | 
#         (p1$N == 2500 & p1$TPs == 0.407 & p1$mix == 1 & p1$lambda %in% c(0.7, 0.9)), ]
```

# Segment 1: Models 1 - 3

## Model 1:

Thresholds= Model 1

![](images/clipboard-1751288251.png){width="353"}

\_Figure 1: Probability Plot for Model 1\_

```{r,eval = FALSE}
#| label: "rilta-lta-simulation-Model 1"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Step 1: Create the cluster (use PSOCK for Windows)
num_cores <- detectCores() - 1  # Detect number of cores
cl <- makeCluster(num_cores, type = "PSOCK")    # Create the cluster with PSOCK

# Step 2: Define the function for the simulation
rilta_lta_func <- function(N, TPs, mix, lambda) {
  
  # Step 2.1: Construct the MODELPOPULATION argument based on the value of 'mix'
  MODELPOPULATION <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*-1.897] ;
      [c1#2*-0.798] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      
   f by u11-u15*{lambda} (p1-p5)
        u21-u25*{lambda} (p1-p5);
    f@1;
    [f@0];
    
      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      
   f by u11-u15*{lambda} (p1-p5)
        u21-u25*{lambda} (p1-p5);
    f@1;
    [f@0];
    

      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  } else if (mix == 3) { 
    glue("	
      %OVERALL%
      [c1#1*1.792] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      
     f by u11-u15*{lambda} (p1-p5)
          u21-u25*{lambda} (p1-p5);
    f@1;
    [f@0];
    
      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*-1.897] ;
      [c1#2*-0.798] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);

      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2: 	
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);

      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2: 	
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  } else if (mix == 3) {
    glue("	
      %OVERALL%
      [c1#1*1.792] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);

      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  }

  # Step 2.3: Construct the MODELCONSTRAINT argument based on the value of 'TPs'
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);

    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  }

  # Step 3: Construct the Mplus object
  RILTA_LTA <- mplusObject(
    TITLE = glue("RILTA_LTA_M1_N_{N}_TP_{TPs}_M_{mix}_L_{lambda}"),
    MONTECARLO = glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N};
      SEED = 07252005;
      NREPS = 500;
      !SAVE = repM1*.dat;
      RESULTS = RILTA_LTA_M1_N_{N}_TP_{TPs}_M_{mix}_L_{lambda}.csv;"),
    
      ANALYSIS =
      "TYPE = MIXTURE;
      algorithm = integration;
      INTEGRATION = STANDARD(20);
      processors = 24;
      miterations = 1000; 
      starts= 250 100;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    OUTPUT = "TECH9",
    
    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Step 4: Run Mplus model
  RILTA_LTA_Model <- mplusModeler(
    RILTA_LTA, 
    dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', glue("RILTA_LTA_M1_N_{N}_TP_{TPs}_M_{mix}_L_{lambda}.dat")),
    modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', "RILTA_LTA_M1_N_{N}_TP_{TPs}_M_{mix}_L_{lambda}.inp")),
    check = TRUE, run = TRUE, hashfilename = FALSE
  )
  return(RILTA_LTA_Model)
}

# Step 5: Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func", "p1")))

# Ensure that the packages are loaded on each cluster node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

# Step 6: Run the simulation in parallel using the cluster
result_list <- parLapply(cl, 1:nrow(p1), function(i) {
  rilta_lta_func(p1$N[i], p1$TPs[i], p1$mix[i], p1$lambda[i])
})

stopCluster(cl)
```

## Model 2:

Thresholds: Model 2

![](images/clipboard-3529114057.png){width="318"}

\_Figure 2: Probability Plot of Model 2\_

```{r, eval = FALSE}
#| label: "rilta-lta-simulation-Model 2"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true
# Step 1: Create the cluster (use PSOCK for Windows)
num_cores <- detectCores() - 1  # Detect number of cores
cl <- makeCluster(num_cores, type = "PSOCK")    # Create the cluster with PSOCK

rilta_lta_func2 <- function(N, TPs, mix, lambda) {
  
  # Step 2.1: Construct the MODELPOPULATION argument based on 'mix'
  MODELPOPULATION <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*-1.897] ;
      [c1#2*-0.798] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      
   f by u11-u15*{lambda} (p1-p5)
        u21-u25*{lambda} (p1-p5);
    f@1;
    [f@0];

      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);
      %c1#2%
      [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
      %c1#3%
      [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);
      
      MODEL POPULATION-c2:
      %c2#1%
      [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);
      %c2#2%
      [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
      %c2#3%
      [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
  } else if (mix == 2) {
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      
   f by u11-u15*{lambda} (p1-p5)
        u21-u25*{lambda} (p1-p5);
    f@1;
    [f@0];
    
      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);
      %c1#2%
      [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
      %c1#3%
      [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);
      
      MODEL POPULATION-c2:
      %c2#1%
      [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);
      %c2#2%
      [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
      %c2#3%
      [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
  } else if (mix == 3) {
    glue("	
      %OVERALL%
      [c1#1*1.792] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      
   f by u11-u15*{lambda} (p1-p5)
        u21-u25*{lambda} (p1-p5);
    f@1;
    [f@0];

      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);
      %c1#2%
      [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
      %c1#3%
      [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);
      
      MODEL POPULATION-c2:
      %c2#1%
      [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);
      %c2#2%
      [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
      %c2#3%
      [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*-1.897] ;
      [c1#2*-0.798] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);

     MODEL c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
	      ")      
      
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);
        
     MODEL c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
	      ")      
  } else if (mix == 3) {
    glue("	
      %OVERALL%
      [c1#1*1.792] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);

      MODEL c1:
      %c1#1%
      [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);
      %c1#2%
      [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
      %c1#3%
      [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);
      
      MODEL c2:
      %c2#1%
      [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);
      %c2#2%
      [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
      %c2#3%
      [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
  }
  
  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  }
  
  RILTA_LTA2 <- mplusObject(
    TITLE = glue("Generate RILTA_LTA_M2_N_{N}_TP_{TPs}_M_{mix}_L_{lambda}"),

    MONTECARLO =
      glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N};
      SEED = 07252005;
      NREPS = 500;
      !SAVE = repM2*.dat;
      RESULTS = RILTA_LTA_M2_N_{N}_TP_{TPs}_M_{mix}_L_{lambda}.csv;"),
    
    
      ANALYSIS =
      "TYPE = MIXTURE;
      algorithm = integration;
      INTEGRATION = STANDARD(20);
      processors = 24;
      miterations = 1000; 
      starts= 250 100;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    OUTPUT = "TECH9",

    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_LTA_Model2<- mplusModeler(RILTA_LTA2, 
                                   dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', glue("RILTA_LTA_M2_N_{N}_TP_{TPs}_M_{mix}_L_{lambda}.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', "RILTA_LTA_M2_N_{N}_TP_{TPs}_M_{mix}_L_{lambda}.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_LTA_Model2)
}

# Step 3: Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func2", "p1")))

# Ensure that the packages are loaded on each cluster node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(p1), function(i) {
  rilta_lta_func2(p1$N[i], p1$TPs[i], p1$mix[i], p1$lambda[i])
})

stopCluster(cl)
```

## Model 3:

Thresholds: Model 3

![](images/clipboard-1996559007.png){width="344"}

\_Figure 3: Probability Plot for Model 3\_

```{r, eval = FALSE}

#| label: "rilta-lta-simulation-Model 3"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Step 1: Create the cluster (use PSOCK for Windows)
num_cores <- detectCores() - 1  # Detect number of cores
cl <- makeCluster(num_cores, type = "PSOCK")    # Create the cluster with PSOCK

rilta_lta_func3 <- function(N, TPs, mix, lambda) {
  
  # Step 2.1: Construct the MODELPOPULATION argument for Model 3 based on 'mix'
  MODELPOPULATION <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*-1.897] ;
      [c1#2*-0.798] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;

   f by u11-u15*{lambda} (p1-p5)
        u21-u25*{lambda} (p1-p5);
    f@1;
    [f@0];
  
      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);
      %c1#2%
      [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
      %c1#3%
      [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);
      %c2#2%
      [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
      %c2#3%
      [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
    ")
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;

   f by u11-u15*{lambda} (p1-p5)
        u21-u25*{lambda} (p1-p5);
    f@1;
    [f@0];
      
      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);
      %c1#2%
      [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
      %c1#3%
      [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);
      %c2#2%
      [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
      %c2#3%
      [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
    ")
  } else if (mix == 3) { 
    glue("	
      %OVERALL%
      [c1#1*1.792] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      
   f by u11-u15*{lambda} (p1-p5)
        u21-u25*{lambda} (p1-p5);
    f@1;
    [f@0];
      
      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);
      %c1#2%
      [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
      %c1#3%
      [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);
      %c2#2%
      [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
      %c2#3%
      [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
    ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*-1.897] ;
      [c1#2*-0.798] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);

     MODEL c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
	      ")      
      
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);
 
     MODEL c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
	      ")      
  } else if (mix == 3) {
    glue("	
      %OVERALL%
      [c1#1*1.792] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);

      MODEL c1:
      %c1#1%
      [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);
      %c1#2%
      [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
      %c1#3%
      [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);
      
      MODEL c2: 	
      %c2#1%
      [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);
      %c2#2%
      [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
      %c2#3%
      [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
    ")
  }
    
  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  }
  
  RILTA_LTA3 <- mplusObject(
    TITLE = glue("Generate RILTA_LTA_M3_N_{N}_TP_{TPs}_M_{mix}_L_{lambda}"),

    MONTECARLO =
      glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N};
      SEED = 07252005;
      NREPS = 500;
      !SAVE = repM3*.dat;
      RESULTS = RILTA_LTA_M3_N_{N}_TP_{TPs}_M_{mix}_L_{lambda}.csv;"),
    
      ANALYSIS =
      "TYPE = MIXTURE;
      algorithm = integration;
      INTEGRATION = STANDARD(20);
      processors = 24;
      miterations = 1000; 
      starts= 250 100;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    OUTPUT = "TECH9",

    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_LTA_Model3<- mplusModeler(RILTA_LTA3, 
                                   dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', glue("RILTA_LTA_M3_N_{N}_TP_{TPs}_M_{mix}_L_{lambda}.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', "RILTA_LTA_M3_N_{N}_TP_{TPs}_M_{mix}_L_{lambda}.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_LTA_Model3)
}

# Step 3: Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func3", "p1")))

# Ensure that the packages are loaded on each cluster node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(p1), function(i) {
  rilta_lta_func3(p1$N[i], p1$TPs[i], p1$mix[i], p1$lambda[i])
})

stopCluster(cl)
```

# Segment 2: Models 1A - 1D

Set up Conditions

```{r}
p1 <- expand.grid(N = c(500, 1000, 2500, 5000),
TPs = c(3.179, 0.407),
mix = c(1, 2, 3))

# Display the matrix using gt
p1 %>%
  gt() %>%
  tab_header(
    title = "Simulation Conditions Matrix",
    subtitle = "Combinations of Sample Sizes, Transition Probabilities, Lambdas, and Mixing Propotions"
  ) %>%
  cols_align(
    align = "center",
    columns = everything() # Centers all columns
  )

```

## Model 1A: Varied Lambda Pattern A

```{r,message=FALSE, warning=FALSE, eval = FALSE}
#| label: "rilta-lta-simulation-Model 4"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Step 1: Create the cluster (use PSOCK for Windows)
num_cores <- detectCores() - 1  # Detect number of cores
cl <- makeCluster(num_cores, type = "PSOCK")    # Create the cluster with PSOCK

rilta_lta_func4 <- function(N, TPs, mix) {
  
  # Step 2.1: Construct the MODELPOPULATION argument based on the value of 'mix'
  MODELPOPULATION <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*-1.897] ;
      [c1#2*-0.798] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      
       f by u11*.1 u12*.1 u13*.1 u14*.2 u15*1 (p1-p5)
            u21*.1 u22*.1 u23*.1 u24*.2 u25*1 (p1-p5);
        f@1;
        [f@0];
            
      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      
       f by u11*.1 u12*.1 u13*.1 u14*.2 u15*1 (p1-p5)
            u21*.1 u22*.1 u23*.1 u24*.2 u25*1 (p1-p5);
        f@1;
        [f@0];
            
      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  } else if (mix == 3) { 
    glue("	
      %OVERALL%
      [c1#1*1.792] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      
       f by u11*.1 u12*.1 u13*.1 u14*.2 u15*1 (p1-p5)
            u21*.1 u22*.1 u23*.1 u24*.2 u25*1 (p1-p5);
        f@1;
        [f@0];
            
      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*-1.897] ;
      [c1#2*-0.798] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);

      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2: 	
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);

      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2: 	
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  } else if (mix == 3) {
    glue("	
      %OVERALL%
      [c1#1*1.792] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);

      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  }

  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  }

  # Construct the Mplus object
  RILTA_LTA4 <- mplusObject(
    TITLE = glue("RILTA_LTA_M1_N_{N}_TP_{TPs}_M_{mix}_L_A"),
    MONTECARLO = glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N};
      SEED = 07252005;
      NREPS = 500;
      !SAVE = repM4*.dat;
      RESULTS = RILTA_LTA_M1_N_{N}_TP_{TPs}_M_{mix}_L_A.csv;"),
    
      ANALYSIS =
      "TYPE = MIXTURE;
      algorithm = integration;
      INTEGRATION = STANDARD(20);
      processors = 24;
      miterations = 1000; 
      starts= 250 100;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    OUTPUT = "TECH9",
    
    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_LTA_Model4<- mplusModeler(RILTA_LTA4, 
                                   dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', glue("RILTA_LTA_M1_N_{N}_TP_{TPs}_M_{mix}_L_A.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', "RILTA_LTA_M1_N_{N}_TP_{TPs}_M_{mix}_L_A.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_LTA_Model4)
}

# Step 3: Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func4", "p1")))

# Ensure that the packages are loaded on each cluster node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(p1), function(i) {
  rilta_lta_func4(p1$N[i], p1$TPs[i], p1$mix[i])
               })
stopCluster(cl)
```

## Model 1B: Varied Lambda Pattern B

```{r,message=FALSE, warning=FALSE, eval = FALSE}
#| label: "rilta-lta-simulation-Model 5"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Step 1: Create the cluster (use PSOCK for Windows)
num_cores <- detectCores() - 1  # Detect number of cores
cl <- makeCluster(num_cores, type = "PSOCK")    # Create the cluster with PSOCK

rilta_lta_func5 <- function(N, TPs, mix) {
  
  # Step 2.1: Construct the MODELPOPULATION argument based on the value of 'mix'
  MODELPOPULATION <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*-1.897] ;
      [c1#2*-0.798] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      
       f by u11*.1 u12*.1 u13*.1 u14*.2 u15*2 (p1-p5)
            u21*.1 u22*.1 u23*.1 u24*.2 u25*2 (p1-p5);
        f@1;
        [f@0];

      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      
       f by u11*.1 u12*.1 u13*.1 u14*.2 u15*2 (p1-p5)
            u21*.1 u22*.1 u23*.1 u24*.2 u25*2 (p1-p5);
        f@1;
        [f@0];

      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  } else if (mix == 3) { 
    glue("	
      %OVERALL%
      [c1#1*1.792] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      
       f by u11*.1 u12*.1 u13*.1 u14*.2 u15*2 (p1-p5)
            u21*.1 u22*.1 u23*.1 u24*.2 u25*2 (p1-p5);
        f@1;
        [f@0];

      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  }
  # Construct the MODEL argument based on the value of mix
  MODEL <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*-1.897] ;
      [c1#2*-0.798] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);

      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2: 	
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);

      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2: 	
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  } else if (mix == 3) {
    glue("	
      %OVERALL%
      [c1#1*1.792] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);

      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  }

  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  }

  # Construct the Mplus object
  RILTA_LTA5 <- mplusObject(
    TITLE = glue("RILTA_LTA_M1_N_{N}_TP_{TPs}_M_{mix}_L_B"),
    MONTECARLO = glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N};
      SEED = 07252005;
      NREPS = 500;
      !SAVE = repM5*.dat;
      RESULTS = RILTA_LTA_M1_N_{N}_TP_{TPs}_M_{mix}_L_B.csv;"),
    
      ANALYSIS =
      "TYPE = MIXTURE;
      algorithm = integration;
      INTEGRATION = STANDARD(20);
      processors = 24;
      miterations = 1000; 
      starts= 250 100;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    OUTPUT = "TECH9",
    
    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_LTA_Model5<- mplusModeler(RILTA_LTA5, 
                                   dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', glue("RILTA_LTA_M1_N_{N}_TP_{TPs}_M_{mix}_L_B.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', "RILTA_LTA_M1_N_{N}_TP_{TPs}_M_{mix}_L_B.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_LTA_Model5)
}

# Step 3: Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func5", "p1")))

# Ensure that the packages are loaded on each cluster node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(p1), function(i) {
  rilta_lta_func5(p1$N[i], p1$TPs[i], p1$mix[i])
               })
stopCluster(cl)
```

## Model 1C: Varied Lambda Pattern C

```{r,message=FALSE, warning=FALSE, eval = FALSE}

#| label: "rilta-lta-simulation-Model 6"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Step 1: Create the cluster (use PSOCK for Windows)
num_cores <- detectCores() - 1  # Detect number of cores
cl <- makeCluster(num_cores, type = "PSOCK")    # Create the cluster with PSOCK

rilta_lta_func6 <- function(N, TPs, mix) {
  
  # Step 2.1: Construct the MODELPOPULATION argument based on the value of 'mix'
  MODELPOPULATION <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*-1.897] ;
      [c1#2*-0.798] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      
       f by u11*.1 u12*.1 u13*.1 u14*.2 u15*3 (p1-p5)
            u21*.1 u22*.1 u23*.1 u24*.2 u25*3 (p1-p5);
        f@1;
        [f@0];

      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      
       f by u11*.1 u12*.1 u13*.1 u14*.2 u15*3 (p1-p5)
            u21*.1 u22*.1 u23*.1 u24*.2 u25*3 (p1-p5);
        f@1;
        [f@0];

      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  } else if (mix == 3) { 
    glue("	
      %OVERALL%
      [c1#1*1.792] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      
       f by u11*.1 u12*.1 u13*.1 u14*.2 u15*3 (p1-p5)
            u21*.1 u22*.1 u23*.1 u24*.2 u25*3 (p1-p5);
        f@1;
        [f@0];

      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*-1.897] ;
      [c1#2*-0.798] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);

      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2: 	
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);

      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2: 	
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  } else if (mix == 3) {
    glue("	
      %OVERALL%
      [c1#1*1.792] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);

      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  }

  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      

    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  }

  # Construct the Mplus object
  RILTA_LTA6 <- mplusObject(
    TITLE = glue("RILTA_LTA_M1_N_{N}_TP_{TPs}_M_{mix}_L_C"),
    MONTECARLO = glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N};
      SEED = 07252005;
      NREPS = 500;
      !SAVE = repM6*.dat;
      RESULTS = RILTA_LTA_M1_N_{N}_TP_{TPs}_M_{mix}_L_C.csv;"),
    
      ANALYSIS =
      "TYPE = MIXTURE;
      algorithm = integration;
      INTEGRATION = STANDARD(20);
      processors = 24;
      miterations = 1000; 
      starts= 250 100;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    OUTPUT = "TECH9",
    
    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_LTA_Model6<- mplusModeler(RILTA_LTA6, 
                                   dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', glue("RILTA_LTA_M1_N_{N}_TP_{TPs}_M_{mix}_L_C.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', "RILTA_LTA_M1_N_{N}_TP_{TPs}_M_{mix}_L_C.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_LTA_Model6)
}

# Step 3: Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func6", "p1")))

# Ensure that the packages are loaded on each cluster node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(p1), function(i) {
  rilta_lta_func6(p1$N[i], p1$TPs[i], p1$mix[i])
               })
stopCluster(cl)
```

## Model 1D: Varied Lambda Pattern D

```{r,message=FALSE, warning=FALSE, eval = FALSE}
#| label: "rilta-lta-simulation-Model 7"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Step 1: Create the cluster (use PSOCK for Windows)
num_cores <- detectCores() - 1  # Detect number of cores
cl <- makeCluster(num_cores, type = "PSOCK")    # Create the cluster with PSOCK

rilta_lta_func7 <- function(N, TPs, mix) {
  
  # Step 2.1: Construct the MODELPOPULATION argument based on the value of 'mix'
  MODELPOPULATION <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*-1.897] ;
      [c1#2*-0.798] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      
       f by u11*.1 u12*.1 u13*.1 u14*.2 u15*4 (p1-p5)
            u21*.1 u22*.1 u23*.1 u24*.2 u25*4 (p1-p5);
        f@1;
        [f@0];

      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      
       f by u11*.1 u12*.1 u13*.1 u14*.2 u15*4 (p1-p5)
            u21*.1 u22*.1 u23*.1 u24*.2 u25*4 (p1-p5);
        f@1;
        [f@0];

      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  } else if (mix == 3) { 
    glue("	
      %OVERALL%
      [c1#1*1.792] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      
       f by u11*.1 u12*.1 u13*.1 u14*.2 u15*4 (p1-p5)
            u21*.1 u22*.1 u23*.1 u24*.2 u25*4 (p1-p5);
        f@1;
        [f@0];

      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  }
  
  # Construct the MODEL argument based on the value of mix
  MODEL <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*-1.897] ;
      [c1#2*-0.798] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);

      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2: 	
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);

      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2: 	
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  } else if (mix == 3) {
    glue("	
      %OVERALL%
      [c1#1*1.792] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);

      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  }

  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  }

  # Construct the Mplus object
  RILTA_LTA7 <- mplusObject(
    TITLE = glue("RILTA_LTA_M1_N_{N}_TP_{TPs}_M_{mix}_L_D"),
    MONTECARLO = glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N};
      SEED = 07252005;
      NREPS = 500;
      !SAVE = repM7*.dat;
      RESULTS = RILTA_LTA_M1_N_{N}_TP_{TPs}_M_{mix}_L_D.csv;"),
    
      ANALYSIS =
      "TYPE = MIXTURE;
      algorithm = integration;
      INTEGRATION = STANDARD(20);
      processors = 24;
      miterations = 1000; 
      starts= 250 100;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    OUTPUT = "TECH9",
    
    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_LTA_Model7<- mplusModeler(RILTA_LTA7, 
                                   dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', glue("RILTA_LTA_M1_N_{N}_TP_{TPs}_M_{mix}_L_D.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', "RILTA_LTA_M1_N_{N}_TP_{TPs}_M_{mix}_L_D.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_LTA_Model7)
}

# Step 3: Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func7", "p1")))

# Ensure that the packages are loaded on each cluster node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(p1), function(i) {
  rilta_lta_func7(p1$N[i], p1$TPs[i], p1$mix[i])
               })
stopCluster(cl)
```

# Segment 3: Models 2A - 2D

## Model 2A: Varied Lambda Pattern A

```{r,eval = FALSE}
#| label: "rilta-lta-simulation-Model 8"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Step 1: Create the cluster (use PSOCK for Windows)
num_cores <- detectCores() - 1  # Detect number of cores
cl <- makeCluster(num_cores, type = "PSOCK")    # Create the cluster with PSOCK

rilta_lta_func8 <- function(N, TPs, mix) {
  
  # Step 2.1: Construct the MODELPOPULATION argument based on 'mix'
  MODELPOPULATION <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*-1.897] ;
      [c1#2*-0.798] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      
       f by u11*.1 u12*.1 u13*.1 u14*.2 u15*1 (p1-p5)
            u21*.1 u22*.1 u23*.1 u24*.2 u25*1 (p1-p5);
        f@1;
        [f@0];

      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);
      %c1#2%
      [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
      %c1#3%
      [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);
      
      MODEL POPULATION-c2:
      %c2#1%
      [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);
      %c2#2%
      [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
      %c2#3%
      [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
  } else if (mix == 2) {
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      
       f by u11*.1 u12*.1 u13*.1 u14*.2 u15*1 (p1-p5)
            u21*.1 u22*.1 u23*.1 u24*.2 u25*1 (p1-p5);
        f@1;
        [f@0];

      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);
      %c1#2%
      [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
      %c1#3%
      [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);
      
      MODEL POPULATION-c2:
      %c2#1%
      [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);
      %c2#2%
      [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
      %c2#3%
      [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
  } else if (mix == 3) {
    glue("	
      %OVERALL%
      [c1#1*1.792] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      
       f by u11*.1 u12*.1 u13*.1 u14*.2 u15*1 (p1-p5)
            u21*.1 u22*.1 u23*.1 u24*.2 u25*1 (p1-p5);
        f@1;
        [f@0];

      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);
      %c1#2%
      [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
      %c1#3%
      [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);
      
      MODEL POPULATION-c2:
      %c2#1%
      [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);
      %c2#2%
      [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
      %c2#3%
      [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*-1.897] ;
      [c1#2*-0.798] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);

     MODEL c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
	      ")      
      
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);
        
     MODEL c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
	      ")      
  } else if (mix == 3) {
    glue("	
      %OVERALL%
      [c1#1*1.792] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);

      MODEL c1:
      %c1#1%
      [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);
      %c1#2%
      [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
      %c1#3%
      [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);
      
      MODEL c2:
      %c2#1%
      [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);
      %c2#2%
      [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
      %c2#3%
      [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
  }

  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);

    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  }

  # Construct the Mplus object
  RILTA_LTA8 <- mplusObject(
    TITLE = glue("RILTA_LTA_M2_N_{N}_TP_{TPs}_M_{mix}_L_A"),
    MONTECARLO = glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N};
      SEED = 07252005;
      NREPS = 500;
      !SAVE = repM8*.dat;
      RESULTS = RILTA_LTA_M2_N_{N}_TP_{TPs}_M_{mix}_L_A.csv;"),
    
      ANALYSIS =
      "TYPE = MIXTURE;
      algorithm = integration;
      INTEGRATION = STANDARD(20);
      processors = 24;
      miterations = 1000; 
      starts= 250 100;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    OUTPUT = "TECH9",
    
    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_LTA_Model8<- mplusModeler(RILTA_LTA8, 
                                   dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', glue("RILTA_LTA_M2_N_{N}_TP_{TPs}_M_{mix}_L_A.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', "RILTA_LTA_M2_N_{N}_TP_{TPs}_M_{mix}_L_A.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_LTA_Model8)
}

# Step 3: Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func8", "p1")))

# Ensure that the packages are loaded on each cluster node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(p1), function(i) {
  rilta_lta_func8(p1$N[i], p1$TPs[i], p1$mix[i])
               })

stopCluster(cl)
```

## Model 2B: Varied Lambda Pattern B

```{r, eval = FALSE}
#| label: "rilta-lta-simulation-Model 9"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Step 1: Create the cluster (use PSOCK for Windows)
num_cores <- detectCores() - 1  # Detect number of cores
cl <- makeCluster(num_cores, type = "PSOCK")    # Create the cluster with PSOCK

rilta_lta_func9 <- function(N, TPs, mix) {
  
  # Step 2.1: Construct the MODELPOPULATION argument based on 'mix'
  MODELPOPULATION <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*-1.897] ;
      [c1#2*-0.798] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      
       f by u11*.1 u12*.1 u13*.1 u14*.2 u15*2 (p1-p5)
            u21*.1 u22*.1 u23*.1 u24*.2 u25*2 (p1-p5);
        f@1;
        [f@0];

      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);
      %c1#2%
      [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
      %c1#3%
      [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);
      
      MODEL POPULATION-c2:
      %c2#1%
      [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);
      %c2#2%
      [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
      %c2#3%
      [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
  } else if (mix == 2) {
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      
       f by u11*.1 u12*.1 u13*.1 u14*.2 u15*2 (p1-p5)
            u21*.1 u22*.1 u23*.1 u24*.2 u25*2 (p1-p5);
        f@1;
        [f@0];

      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);
      %c1#2%
      [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
      %c1#3%
      [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);
      
      MODEL POPULATION-c2:
      %c2#1%
      [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);
      %c2#2%
      [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
      %c2#3%
      [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
  } else if (mix == 3) {
    glue("	
      %OVERALL%
      [c1#1*1.792] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      
       f by u11*.1 u12*.1 u13*.1 u14*.2 u15*2 (p1-p5)
            u21*.1 u22*.1 u23*.1 u24*.2 u25*2 (p1-p5);
        f@1;
        [f@0];

      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);
      %c1#2%
      [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
      %c1#3%
      [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);
      
      MODEL POPULATION-c2:
      %c2#1%
      [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);
      %c2#2%
      [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
      %c2#3%
      [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*-1.897] ;
      [c1#2*-0.798] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);

     MODEL c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
	      ")      
      
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);
        
     MODEL c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
	      ")      
  } else if (mix == 3) {
    glue("	
      %OVERALL%
      [c1#1*1.792] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);

      MODEL c1:
      %c1#1%
      [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);
      %c1#2%
      [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
      %c1#3%
      [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);
      
      MODEL c2:
      %c2#1%
      [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);
      %c2#2%
      [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
      %c2#3%
      [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
  }

  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  }

  # Construct the Mplus object
  RILTA_LTA9 <- mplusObject(
    TITLE = glue("RILTA_LTA_M2_N_{N}_TP_{TPs}_M_{mix}_L_B"),
    MONTECARLO = glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N};
      SEED = 07252005;
      NREPS = 500;
      !SAVE = repM9*.dat;
      RESULTS = RILTA_LTA_M2_N_{N}_TP_{TPs}_M_{mix}_L_B.csv;"),
    
      ANALYSIS =
      "TYPE = MIXTURE;
      algorithm = integration;
      INTEGRATION = STANDARD(20);
      processors = 24;
      miterations = 1000; 
      starts= 250 100;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    OUTPUT = "TECH9",
    
    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_LTA_Model9<- mplusModeler(RILTA_LTA9, 
                                   dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', glue("RILTA_LTA_M2_N_{N}_TP_{TPs}_M_{mix}_L_B.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', "RILTA_LTA_M2_N_{N}_TP_{TPs}_M_{mix}_L_B.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_LTA_Model9)
}

# Step 3: Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func9", "p1")))

# Ensure that the packages are loaded on each cluster node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(p1), function(i) {
  rilta_lta_func9(p1$N[i], p1$TPs[i], p1$mix[i])
               })

stopCluster(cl)
```

## Model 2C: Varied Lambda Pattern C

```{r, eval = FALSE}
#| label: "rilta-lta-simulation-Model 10"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Step 1: Create the cluster (use PSOCK for Windows)
num_cores <- detectCores() - 1  # Detect number of cores
cl <- makeCluster(num_cores, type = "PSOCK")    # Create the cluster with PSOCK

rilta_lta_func10 <- function(N, TPs, mix) {
  
  # Step 2.1: Construct the MODELPOPULATION argument based on 'mix'
  MODELPOPULATION <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*-1.897] ;
      [c1#2*-0.798] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      
       f by u11*.1 u12*.1 u13*.1 u14*.2 u15*3 (p1-p5)
            u21*.1 u22*.1 u23*.1 u24*.2 u25*3 (p1-p5);
        f@1;
        [f@0];

      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);
      %c1#2%
      [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
      %c1#3%
      [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);
      
      MODEL POPULATION-c2:
      %c2#1%
      [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);
      %c2#2%
      [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
      %c2#3%
      [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
  } else if (mix == 2) {
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      
       f by u11*.1 u12*.1 u13*.1 u14*.2 u15*3 (p1-p5)
            u21*.1 u22*.1 u23*.1 u24*.2 u25*3 (p1-p5);
        f@1;
        [f@0];

      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);
      %c1#2%
      [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
      %c1#3%
      [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);
      
      MODEL POPULATION-c2:
      %c2#1%
      [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);
      %c2#2%
      [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
      %c2#3%
      [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
  } else if (mix == 3) {
    glue("	
      %OVERALL%
      [c1#1*1.792] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      
       f by u11*.1 u12*.1 u13*.1 u14*.2 u15*3 (p1-p5)
            u21*.1 u22*.1 u23*.1 u24*.2 u25*3 (p1-p5);
        f@1;
        [f@0];

      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);
      %c1#2%
      [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
      %c1#3%
      [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);
      
      MODEL POPULATION-c2:
      %c2#1%
      [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);
      %c2#2%
      [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
      %c2#3%
      [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*-1.897] ;
      [c1#2*-0.798] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);

     MODEL c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
	      ")      
      
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);
        
     MODEL c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
	      ")      
  } else if (mix == 3) {
    glue("	
      %OVERALL%
      [c1#1*1.792] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);

      MODEL c1:
      %c1#1%
      [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);
      %c1#2%
      [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
      %c1#3%
      [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);
      
      MODEL c2:
      %c2#1%
      [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);
      %c2#2%
      [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
      %c2#3%
      [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
  }

  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  }

  # Construct the Mplus object
  RILTA_LTA10 <- mplusObject(
    TITLE = glue("RILTA_LTA_M2_N_{N}_TP_{TPs}_M_{mix}_L_C"),
    MONTECARLO = glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N};
      SEED = 07252005;
      NREPS = 500;
      !SAVE = repM10*.dat;
      RESULTS = RILTA_LTA_M2_N_{N}_TP_{TPs}_M_{mix}_L_C.csv;"),
    
      ANALYSIS =
      "TYPE = MIXTURE;
      algorithm = integration;
      INTEGRATION = STANDARD(20);
      processors = 24;
      miterations = 1000; 
      starts= 250 100;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    OUTPUT = "TECH9",
    
    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_LTA_Model10<- mplusModeler(RILTA_LTA10, 
                                   dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', glue("RILTA_LTA_M2_N_{N}_TP_{TPs}_M_{mix}_L_C.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', "RILTA_LTA_M2_N_{N}_TP_{TPs}_M_{mix}_L_C.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_LTA_Model10)
}

# Step 3: Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func10", "p1")))

# Ensure that the packages are loaded on each cluster node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(p1), function(i) {
  rilta_lta_func10(p1$N[i], p1$TPs[i], p1$mix[i])
               })

stopCluster(cl)
```

## Model 2D: Varied Lambda Pattern D

```{r, eval = FALSE}
#| label: "rilta-lta-simulation-Model 11"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Step 1: Create the cluster (use PSOCK for Windows)
num_cores <- detectCores() - 1  # Detect number of cores
cl <- makeCluster(num_cores, type = "PSOCK")    # Create the cluster with PSOCK

rilta_lta_func11 <- function(N, TPs, mix) {
  
  # Step 2.1: Construct the MODELPOPULATION argument based on 'mix'
  MODELPOPULATION <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*-1.897] ;
      [c1#2*-0.798] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      
       f by u11*.1 u12*.1 u13*.1 u14*.2 u15*4 (p1-p5)
            u21*.1 u22*.1 u23*.1 u24*.2 u25*4 (p1-p5);
        f@1;
        [f@0];

      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);
      %c1#2%
      [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
      %c1#3%
      [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);
      
      MODEL POPULATION-c2:
      %c2#1%
      [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);
      %c2#2%
      [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
      %c2#3%
      [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
  } else if (mix == 2) {
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      
       f by u11*.1 u12*.1 u13*.1 u14*.2 u15*4 (p1-p5)
            u21*.1 u22*.1 u23*.1 u24*.2 u25*4 (p1-p5);
        f@1;
        [f@0];

      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);
      %c1#2%
      [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
      %c1#3%
      [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);
      
      MODEL POPULATION-c2:
      %c2#1%
      [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);
      %c2#2%
      [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
      %c2#3%
      [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
  } else if (mix == 3) {
    glue("	
      %OVERALL%
      [c1#1*1.792] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      
       f by u11*.1 u12*.1 u13*.1 u14*.2 u15*4 (p1-p5)
            u21*.1 u22*.1 u23*.1 u24*.2 u25*4 (p1-p5);
        f@1;
        [f@0];

      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);
      %c1#2%
      [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
      %c1#3%
      [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);
      
      MODEL POPULATION-c2:
      %c2#1%
      [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);
      %c2#2%
      [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
      %c2#3%
      [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*-1.897] ;
      [c1#2*-0.798] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);

     MODEL c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
	      ")      
      
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);
        
     MODEL c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
	      ")      
  } else if (mix == 3) {
    glue("	
      %OVERALL%
      [c1#1*1.792] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);

      MODEL c1:
      %c1#1%
      [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);
      %c1#2%
      [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
      %c1#3%
      [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);
      
      MODEL c2:
      %c2#1%
      [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);
      %c2#2%
      [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
      %c2#3%
      [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
  }

  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  }

  # Construct the Mplus object
  RILTA_LTA11 <- mplusObject(
    TITLE = glue("RILTA_LTA_M2_N_{N}_TP_{TPs}_M_{mix}_L_D"),
    MONTECARLO = glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N};
      SEED = 07252005;
      NREPS = 500;
      !SAVE = repM11*.dat;
      RESULTS = RILTA_LTA_M2_N_{N}_TP_{TPs}_M_{mix}_L_D.csv;"),
    
      ANALYSIS =
      "TYPE = MIXTURE;
      algorithm = integration;
      INTEGRATION = STANDARD(20);
      processors = 24;
      miterations = 1000; 
      starts= 250 100;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    OUTPUT = "TECH9",
    
    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_LTA_Model11<- mplusModeler(RILTA_LTA11, 
                                   dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', glue("RILTA_LTA_M2_N_{N}_TP_{TPs}_M_{mix}_L_D.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', "RILTA_LTA_M2_N_{N}_TP_{TPs}_M_{mix}_L_D.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_LTA_Model11)
}

# Step 3: Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func11", "p1")))

# Ensure that the packages are loaded on each cluster node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(p1), function(i) {
  rilta_lta_func11(p1$N[i], p1$TPs[i], p1$mix[i])
               })

stopCluster(cl)
```

# Segment 4: Models 3A - 3D

## Model 3A: Varied Lambda Pattern A

```{r, eval = FALSE}
#| label: "rilta-lta-simulation-Model 12"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Step 1: Create the cluster (use PSOCK for Windows)
num_cores <- detectCores() - 1  # Detect number of cores
cl <- makeCluster(num_cores, type = "PSOCK")    # Create the cluster with PSOCK

rilta_lta_func12 <- function(N, TPs, mix) {
  
  # Step 2.1: Construct the MODELPOPULATION argument for Model 3 based on 'mix'
  MODELPOPULATION <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*-1.897] ;
      [c1#2*-0.798] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;

       f by u11*.1 u12*.1 u13*.1 u14*.2 u15*1 (p1-p5)
            u21*.1 u22*.1 u23*.1 u24*.2 u25*1 (p1-p5);
        f@1;
        [f@0];

      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);
      %c1#2%
      [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
      %c1#3%
      [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);
      %c2#2%
      [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
      %c2#3%
      [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
    ")
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;

       f by u11*.1 u12*.1 u13*.1 u14*.2 u15*1 (p1-p5)
            u21*.1 u22*.1 u23*.1 u24*.2 u25*1 (p1-p5);
        f@1;
        [f@0];

      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);
      %c1#2%
      [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
      %c1#3%
      [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);
      %c2#2%
      [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
      %c2#3%
      [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
    ")
  } else if (mix == 3) { 
    glue("	
      %OVERALL%
      [c1#1*1.792] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      
       f by u11*.1 u12*.1 u13*.1 u14*.2 u15*1 (p1-p5)
            u21*.1 u22*.1 u23*.1 u24*.2 u25*1 (p1-p5);
        f@1;
        [f@0];

      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);
      %c1#2%
      [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
      %c1#3%
      [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);
      %c2#2%
      [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
      %c2#3%
      [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
    ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*-1.897] ;
      [c1#2*-0.798] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);

     MODEL c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
	      ")      
      
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);
 
     MODEL c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
	      ")      
  } else if (mix == 3) {
    glue("	
      %OVERALL%
      [c1#1*1.792] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);

      MODEL c1:
      %c1#1%
      [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);
      %c1#2%
      [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
      %c1#3%
      [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);
      
      MODEL c2: 	
      %c2#1%
      [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);
      %c2#2%
      [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
      %c2#3%
      [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
    ")
  }
    
  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  }
  
  RILTA_LTA12 <- mplusObject(
    TITLE = glue("Generate RILTA_LTA_M3_N_{N}_TP_{TPs}_M_{mix}_L_A"),

    MONTECARLO =
      glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N};
      SEED = 07252005;
      NREPS = 500;
      !SAVE = repM12*.dat;
      RESULTS = RILTA_LTA_M3_N_{N}_TP_{TPs}_M_{mix}_L_A.csv;"),
    
      ANALYSIS =
      "TYPE = MIXTURE;
      algorithm = integration;
      INTEGRATION = STANDARD(20);
      processors = 24;
      miterations = 1000; 
      starts= 250 100;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    OUTPUT = "TECH9",

    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_LTA_Model12<- mplusModeler(RILTA_LTA12, 
                                   dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', glue("RILTA_LTA_M3_N_{N}_TP_{TPs}_M_{mix}_L_A.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', "RILTA_LTA_M3_N_{N}_TP_{TPs}_M_{mix}_L_A.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_LTA_Model12)
}

# Step 3: Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func12", "p1")))

# Ensure that the packages are loaded on each cluster node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(p1), function(i) {
  rilta_lta_func12(p1$N[i], p1$TPs[i], p1$mix[i])
})

stopCluster(cl)
```

## Model 3B: Varied Lambda Pattern B

```{r, eval = FALSE}
#| label: "rilta-lta-simulation-Model 13"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Step 1: Create the cluster (use PSOCK for Windows)
num_cores <- detectCores() - 1  # Detect number of cores
cl <- makeCluster(num_cores, type = "PSOCK")    # Create the cluster with PSOCK

rilta_lta_func13 <- function(N, TPs, mix) {
  
  # Step 2.1: Construct the MODELPOPULATION argument for Model 3 based on 'mix'
  MODELPOPULATION <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*-1.897] ;
      [c1#2*-0.798] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;

       f by u11*.1 u12*.1 u13*.1 u14*.2 u15*2 (p1-p5)
            u21*.1 u22*.1 u23*.1 u24*.2 u25*2 (p1-p5);
        f@1;
        [f@0];

      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);
      %c1#2%
      [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
      %c1#3%
      [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);
      %c2#2%
      [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
      %c2#3%
      [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
    ")
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;

       f by u11*.1 u12*.1 u13*.1 u14*.2 u15*2 (p1-p5)
            u21*.1 u22*.1 u23*.1 u24*.2 u25*2 (p1-p5);
        f@1;
        [f@0];
 
      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);
      %c1#2%
      [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
      %c1#3%
      [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);
      %c2#2%
      [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
      %c2#3%
      [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
    ")
  } else if (mix == 3) { 
    glue("	
      %OVERALL%
      [c1#1*1.792] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      
       f by u11*.1 u12*.1 u13*.1 u14*.2 u15*2 (p1-p5)
            u21*.1 u22*.1 u23*.1 u24*.2 u25*2 (p1-p5);
        f@1;
        [f@0];

      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);
      %c1#2%
      [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
      %c1#3%
      [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);
      %c2#2%
      [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
      %c2#3%
      [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
    ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*-1.897] ;
      [c1#2*-0.798] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);

     MODEL c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
	      ")      
      
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);
 
     MODEL c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
	      ")      
  } else if (mix == 3) {
    glue("	
      %OVERALL%
      [c1#1*1.792] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);

      MODEL c1:
      %c1#1%
      [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);
      %c1#2%
      [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
      %c1#3%
      [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);
      
      MODEL c2: 	
      %c2#1%
      [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);
      %c2#2%
      [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
      %c2#3%
      [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
    ")
  }
    
  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);

    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);

    ")
  }
  
  RILTA_LTA13 <- mplusObject(
    TITLE = glue("Generate RILTA_LTA_M3_N_{N}_TP_{TPs}_M_{mix}_L_B"),

    MONTECARLO =
      glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N};
      SEED = 07252005;
      NREPS = 500;
      !SAVE = repM13*.dat;
      RESULTS = RILTA_LTA_M3_N_{N}_TP_{TPs}_M_{mix}_L_B.csv;"),
    
      ANALYSIS =
      "TYPE = MIXTURE;
      algorithm = integration;
      INTEGRATION = STANDARD(20);
      processors = 24;
      miterations = 1000; 
      starts= 250 100;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    OUTPUT = "TECH9",

    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_LTA_Model13<- mplusModeler(RILTA_LTA13, 
                                   dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', glue("RILTA_LTA_M3_N_{N}_TP_{TPs}_M_{mix}_L_B.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', "RILTA_LTA_M3_N_{N}_TP_{TPs}_M_{mix}_L_B.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_LTA_Model13)
}

# Step 3: Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func13", "p1")))

# Ensure that the packages are loaded on each cluster node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(p1), function(i) {
  rilta_lta_func13(p1$N[i], p1$TPs[i], p1$mix[i])
})

stopCluster(cl)
```

## Model 3C: Varied Lambda Pattern C

```{r, eval = FALSE}
#| label: "rilta-lta-simulation-Model 14"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Step 1: Create the cluster (use PSOCK for Windows)
num_cores <- detectCores() - 1  # Detect number of cores
cl <- makeCluster(num_cores, type = "FORK")    # Create the cluster with PSOCK

rilta_lta_func14 <- function(N, TPs, mix) {
  
  # Step 2.1: Construct the MODELPOPULATION argument for Model 3 based on 'mix'
  MODELPOPULATION <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*-1.897] ;
      [c1#2*-0.798] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;

       f by u11*.1 u12*.1 u13*.1 u14*.2 u15*3 (p1-p5)
            u21*.1 u22*.1 u23*.1 u24*.2 u25*3 (p1-p5);
        f@1;
        [f@0];

      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);
      %c1#2%
      [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
      %c1#3%
      [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);
      %c2#2%
      [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
      %c2#3%
      [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
    ")
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;

       f by u11*.1 u12*.1 u13*.1 u14*.2 u15*3 (p1-p5)
            u21*.1 u22*.1 u23*.1 u24*.2 u25*3 (p1-p5);
        f@1;
        [f@0];

      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);
      %c1#2%
      [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
      %c1#3%
      [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);
      %c2#2%
      [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
      %c2#3%
      [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
    ")
  } else if (mix == 3) { 
    glue("	
      %OVERALL%
      [c1#1*1.792] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      
       f by u11*.1 u12*.1 u13*.1 u14*.2 u15*3 (p1-p5)
            u21*.1 u22*.1 u23*.1 u24*.2 u25*3 (p1-p5);
        f@1;
        [f@0];

      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);
      %c1#2%
      [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
      %c1#3%
      [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);
      %c2#2%
      [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
      %c2#3%
      [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
    ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*-1.897] ;
      [c1#2*-0.798] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);

     MODEL c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
	      ")      
      
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);
 
     MODEL c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
	      ")      
  } else if (mix == 3) {
    glue("	
      %OVERALL%
      [c1#1*1.792] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);

      MODEL c1:
      %c1#1%
      [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);
      %c1#2%
      [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
      %c1#3%
      [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);
      
      MODEL c2: 	
      %c2#1%
      [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);
      %c2#2%
      [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
      %c2#3%
      [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
    ")
  }
    
  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);

    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);

    ")
  }
  
  RILTA_LTA14 <- mplusObject(
    TITLE = glue("Generate RILTA_LTA_M3_N_{N}_TP_{TPs}_M_{mix}_L_B"),

    MONTECARLO =
      glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N};
      SEED = 07252005;
      NREPS = 500;
      !SAVE = repM14*.dat;
      RESULTS = RILTA_LTA_M3_N_{N}_TP_{TPs}_M_{mix}_L_C.csv;"),
    
      ANALYSIS =
      "TYPE = MIXTURE;
      algorithm = integration;
      INTEGRATION = STANDARD(20);
      processors = 24;
      miterations = 1000; 
      starts= 250 100;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    OUTPUT = "TECH9",

    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_LTA_Model14<- mplusModeler(RILTA_LTA14, 
                                   dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', glue("RILTA_LTA_M3_N_{N}_TP_{TPs}_M_{mix}_L_C.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', "RILTA_LTA_M3_N_{N}_TP_{TPs}_M_{mix}_L_C.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_LTA_Model14)
}

# Step 3: Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func14", "p1")))

# Ensure that the packages are loaded on each cluster node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(p1), function(i) {
  rilta_lta_func14(p1$N[i], p1$TPs[i], p1$mix[i])
})

stopCluster(cl)
```

## Model 3D: Varied Lambda Pattern D

```{r, eval = FALSE}
#| label: "rilta-lta-simulation-Model 15"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Step 1: Create the cluster (use PSOCK for Windows, FORK for MAC)
num_cores <- detectCores() - 1  # Detect number of cores
cl <- makeCluster(num_cores, type = "FORK") # Create the cluster with FORK or PSOCK

rilta_lta_func15 <- function(N, TPs, mix) {
  
  # Step 2.1: Construct the MODELPOPULATION argument for Model 3 based on 'mix'
  MODELPOPULATION <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*-1.897] ;
      [c1#2*-0.798] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;

       f by u11*.1 u12*.1 u13*.1 u14*.2 u15*4 (p1-p5)
            u21*.1 u22*.1 u23*.1 u24*.2 u25*4 (p1-p5);
        f@1;
        [f@0];

      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);
      %c1#2%
      [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
      %c1#3%
      [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);
      %c2#2%
      [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
      %c2#3%
      [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
    ")
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;

       f by u11*.1 u12*.1 u13*.1 u14*.2 u15*4 (p1-p5)
            u21*.1 u22*.1 u23*.1 u24*.2 u25*4 (p1-p5);
        f@1;
        [f@0];

      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);
      %c1#2%
      [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
      %c1#3%
      [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);
      %c2#2%
      [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
      %c2#3%
      [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
    ")
  } else if (mix == 3) { 
    glue("	
      %OVERALL%
      [c1#1*1.792] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      
       f by u11*.1 u12*.1 u13*.1 u14*.2 u15*4 (p1-p5)
            u21*.1 u22*.1 u23*.1 u24*.2 u25*4 (p1-p5);
        f@1;
        [f@0];

      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);
      %c1#2%
      [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
      %c1#3%
      [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);
      %c2#2%
      [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
      %c2#3%
      [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
    ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*-1.897] ;
      [c1#2*-0.798] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);

     MODEL c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
	      ")      
      
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);
 
     MODEL c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
	      ")      
  } else if (mix == 3) {
    glue("	
      %OVERALL%
      [c1#1*1.792] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);

      MODEL c1:
      %c1#1%
      [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);
      %c1#2%
      [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
      %c1#3%
      [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);
      
      MODEL c2: 	
      %c2#1%
      [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);
      %c2#2%
      [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
      %c2#3%
      [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
    ")
  }
    
  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  }
  
  RILTA_LTA15 <- mplusObject(
    TITLE = glue("Generate RILTA_LTA_M3_N_{N}_TP_{TPs}_M_{mix}_L_D"),

    MONTECARLO =
      glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N};
      SEED = 07252005;
      NREPS = 500;
      !SAVE = repM15*.dat;
      RESULTS = RILTA_LTA_M3_N_{N}_TP_{TPs}_M_{mix}_L_D.csv;"),
    
      ANALYSIS =
      "TYPE = MIXTURE;
      algorithm = integration;
      INTEGRATION = STANDARD(20);
      processors = 24;
      miterations = 1000; 
      starts= 250 100;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    OUTPUT = "TECH9",

    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_LTA_Model15<- mplusModeler(RILTA_LTA15, 
                                   dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', glue("RILTA_LTA_M3_N_{N}_TP_{TPs}_M_{mix}_L_D.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', "RILTA_LTA_M3_N_{N}_TP_{TPs}_M_{mix}_L_D.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_LTA_Model15)
}

# Step 3: Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func15", "p1")))

# Ensure that the packages are loaded on each cluster node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(p1), function(i) {
  rilta_lta_func15(p1$N[i], p1$TPs[i], p1$mix[i])
})

stopCluster(cl)
```

------------------------------------------------------------------------

# Data Processing and Verification

------------------------------------------------------------------------

## Check for Label Switching and Errors

> In this section: .csv files are first merged into a single data frame, from which specific parameters are extracted. Logit values are then converted to probabilities, and known class values are incorporated into the data frame. A subset of cases involving label switching is selected randomly and plotted for visual review. Output files are scanned for errors, which are subsequently merged back into the original data file. Additional columns derived from the file name are added, and the percentage of violations is calculated. Both errors and label switching violations are visually represented, and the total number of corrected replications is reported.

### Scrape Mplus CSV Files

*First, Load all CSV files and combine them into a single data frame.*

```{r}
#| label: "combine-csv-files-parallel"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true


# Step 1: Set the correct CSV directory
csv_directory <- here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED')

# Step 2: Source the child document
source(here('Child_Docs', 'data_scraping.R'))
```

### Slice Data / Extract Parameters

*Extract data from the appropriate rows from each 9-row chunk and prepare the data for further processing.*

```{r}

#| label: "scrape-rows-process-data-parallel"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Step 2: Process the data using the child script
source(here('Child_Docs', 'step2_f_LTA.R'))

#Generates final_combined_data df
```

### Wrangle Data

*Convert the logits to probabilities and add the known actual values to each row.*

```{r}
#| label: "convert-logits-and-flag-vialotors"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Step 3: Process the data and return results
source(here('Child_Docs', 'step_3_3k.R'))

# The objects `final_data_with_actuals` and `violators` should now be in the global environment
```

### Generate Plots of Label Switching

*Generate plots of randomly sampled violators for visual inspection using parallel processing.*

```{r, eval= FALSE}
#| label: "plot-violators"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Set plot dimensions
plot_width <- 8
plot_height <- 6

# Set seed and sample violators
set.seed(123)
sampled_violators <- violators[sample(nrow(violators), 250), ]

# Define the function to create and save plots for violators
plot_violator <- function(i) {
  row_data <- sampled_violators[i, ]
  file_name <- row_data$FileName  # Extract file name
  
  # Extract probabilities for EC1 through AC3
  probabilities <- c(
    as.numeric(row_data[c("Ec1u1", "Ec1u2", "Ec1u3", "Ec1u4", "Ec1u5")]),
    as.numeric(row_data[c("Ec2u1", "Ec2u2", "Ec2u3", "Ec2u4", "Ec2u5")]),
    as.numeric(row_data[c("Ec3u1", "Ec3u2", "Ec3u3", "Ec3u4", "Ec3u5")]),
    as.numeric(row_data[c("Ac1u1", "Ac1u2", "Ac1u3", "Ac1u4", "Ac1u5")]),
    as.numeric(row_data[c("Ac2u1", "Ac2u2", "Ac2u3", "Ac2u4", "Ac2u5")]),
    as.numeric(row_data[c("Ac3u1", "Ac3u2", "Ac3u3", "Ac3u4", "Ac3u5")])
  )
  
  # Create labels for the legend
  labels <- c(
    paste0("EC1: (", round(row_data$Ec1u1, 3), ", ", round(row_data$Ec1u2, 3), ", ", round(row_data$Ec1u3, 3), ", ", round(row_data$Ec1u4, 3), ", ", round(row_data$Ec1u5, 3), ")"),
    paste0("EC2: (", round(row_data$Ec2u1, 3), ", ", round(row_data$Ec2u2, 3), ", ", round(row_data$Ec2u3, 3), ", ", round(row_data$Ec2u4, 3), ", ", round(row_data$Ec2u5, 3), ")"),
    paste0("EC3: (", round(row_data$Ec3u1, 3), ", ", round(row_data$Ec3u2, 3), ", ", round(row_data$Ec3u3, 3), ", ", round(row_data$Ec3u4, 3), ", ", round(row_data$Ec3u5, 3), ")"),
    paste0("AC1: (", round(row_data$Ac1u1, 3), ", ", round(row_data$Ac1u2, 3), ", ", round(row_data$Ac1u3, 3), ", ", round(row_data$Ac1u4, 3), ", ", round(row_data$Ac1u5, 3), ")"),
    paste0("AC2: (", round(row_data$Ac2u1, 3), ", ", round(row_data$Ac2u2, 3), ", ", round(row_data$Ac2u3, 3), ", ", round(row_data$Ac2u4, 3), ", ", round(row_data$Ac2u5, 3), ")"),
    paste0("AC3: (", round(row_data$Ac3u1, 3), ", ", round(row_data$Ac3u2, 3), ", ", round(row_data$Ac3u3, 3), ", ", round(row_data$Ac3u4, 3), ", ", round(row_data$Ac3u5, 3), ")")
  )

  # Create data frame for plotting
  plot_data <- data.frame(
    Items = rep(1:5, 6),
    Probabilities = probabilities,
    Class = rep(labels, each = 5)
  )

  # Generate the plot
  p <- ggplot(plot_data, aes(x = Items, y = Probabilities, color = Class, group = Class)) +
    geom_line(size = 1.2) +
    geom_point(size = 3) +
    labs(title = file_name, x = "Items", y = "Probabilities") +
    theme_minimal(base_size = 16) +
    theme(
      panel.background = element_rect(fill = "white"),
      plot.background = element_rect(fill = "white"),
      plot.title = element_text(size = 14, hjust = 0.5)
    ) +
    scale_color_manual(values = c(
      "darkblue", "darkgreen", "darkred",  # AC1 to AC3
      "lightblue", "lightgreen", "lightcoral"  # EC1 to EC3
    ))

  # Save the plot to the specified folder
  ggsave(filename = file.path("z2t_lta_rilta_violator_plots", paste0("violator_plot_", i, "_", file_name, ".png")),
         plot = p, width = plot_width, height = plot_height)
}

# Generate and save plots for each sampled violator
invisible(lapply(1:nrow(sampled_violators), plot_violator))

```

------------------------------------------------------------------------

### Error Handling

------------------------------------------------------------------------

### Scrape for Errors

*Scrape output files for errors*

```{r}
#| label: "summarize-errors"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Step 1: Set the correct output directory for .out files
output_folder <- here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP')

# Step 2: Source the child document that processes .out files
source(here('Child_Docs', 'out_scraping.R'))

# ===================================================== #
#   SECTION 1 Generate Replication Summary Table
# ===================================================== #
replication_summary_table <- replication_summary %>%
  gt() %>%
  tab_header(
    title = "Replication Summary",
    subtitle = paste0("Folder: ", output_folder)
  ) %>%
  fmt_number(
    columns = c("Total", "Replicated_Yes", "Replicated_No", "Error_Count"),
    decimals = 0
  ) %>%
  cols_label(
    FileName = "File Name",
    Total = "Total Replications",
    Replicated_Yes = "LL Replicated",
    Replicated_No = "LL Not Replicated",
    Error_Count = "Errors"
  ) %>%
  cols_align(
    align = "center",
    columns = everything()
  ) %>%
  tab_options(
    table.font.size = "small",
    heading.title.font.size = "medium",
    heading.subtitle.font.size = "small",
    table.width = pct(80)
  )

# Display the table
replication_summary_table

# ===================================================== #
#   SECTION 2 Row Count Validation
# ===================================================== #
cat("Rows in final_data_with_actuals:", nrow(final_data_with_actuals), "\n")
cat("Rows in final_results:", nrow(final_results), "\n")
cat("Rows in replication_summary:", nrow(replication_summary), "\n")
print(if (any(replication_summary$LL_Not_Replicated > 0, na.rm = TRUE)) {
  " WARNING: Some LL values were NOT replicated! Check the Replication Summary table."
} else {
  " All LL values were successfully replicated."
})
all.equal(final_data_with_actuals$ll_csv, final_results$ll_out, tolerance = 1e-4)


```

#### Merge Errors with Main Data File

*Combine error information with main data file*

```{r}
#| label: "merge-errors"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

final_data_with_actuals <- final_data_with_actuals %>%
  left_join(final_results %>% select(FileName, Replication, ll_out, ErrorFlag),
            by = c("FileName", "Replication"))
```

Visualize differences between ll_out and ll_csv

```{r}
ll_check <- final_data_with_actuals %>%
  mutate(diff = round(ll_out - ll_csv, 3)) %>%  # Round before counting
  count(diff)

ll_check_table <- ll_check %>%
  gt() %>%
  tab_header(
    title = "LL Difference Summary",
    subtitle = "Comparison of LL values between CSV and OUT files"
  ) %>%
  cols_label(
    diff = "LL Difference",
    n = "Count"
  ) %>%
  fmt_number(
    columns = diff,
    decimals = 3
  ) %>%
  cols_align(
    align = "center",
    columns = everything()
  ) %>%
  tab_options(
    table.font.size = "small",
    heading.title.font.size = "medium",
    heading.subtitle.font.size = "small",
    table.width = pct(50)
  )

# Display the table
ll_check_table
```

### Scrape File Name Components

*Create Column Names from the file name*

```{r}
#| label: "prepare-data-for-plotting-bias"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true


# Add new columns based on the information in the FileName
final_data_with_actuals <- final_data_with_actuals %>%
  mutate(
    Model = case_when(
      grepl("m1", FileName) ~ "1",
      grepl("m2", FileName) ~ "2",
      grepl("m3", FileName) ~ "3",
      TRUE ~ NA_character_
    ),
    N = case_when(
      grepl("n_5000", FileName) ~ 4,  # Convert to factor level 4
      grepl("n_500", FileName) ~ 1,   # Convert to factor level 1
      grepl("n_1000", FileName) ~ 2,  # Convert to factor level 2
      grepl("n_2500", FileName) ~ 3,  # Convert to factor level 3
      TRUE ~ NA_integer_
    ),
    Mixing_proportion = case_when(
      grepl("m_1", FileName) ~ 1,  # Even Class Proportions as factor level 1
      grepl("m_2", FileName) ~ 2,  # Uneven Proportions as factor level 2
      TRUE ~ NA_integer_
    ),
    Lambda_values = case_when(
      grepl("l_0.3", FileName) ~ "0.3",
      grepl("l_0.5", FileName) ~ "0.5",
      grepl("l_0.7", FileName) ~ "0.7",
      grepl("l_0.9", FileName) ~ "0.9",
      grepl("l_a", FileName) ~ "A",
      grepl("l_b", FileName) ~ "B",
      grepl("l_c", FileName) ~ "C",
      grepl("l_d", FileName) ~ "D",
      TRUE ~ NA_character_
    ),
    # Add Population column based on FileName and convert it to a factor with formatted labels
    Population = case_when(
      grepl("tp_0.407", FileName) ~ ".200",
      grepl("tp_3.179", FileName) ~ ".800",
      TRUE ~ NA_character_
    )
  )

# Convert N, Mixing_proportion, and Model columns to factors
final_data_with_actuals <- final_data_with_actuals %>%
  mutate(
    Model = factor(Model, levels = c(1, 2, 3), labels = c("Model 1", "Model 2", "Model 3")),
    N = factor(N, levels = c(1, 2, 3, 4), labels = c("N = 500", "N = 1000", "N = 2500", "N = 5000")),
    Mixing_proportion = factor(Mixing_proportion, levels = c(1, 2), labels = c("Even Proportions", "Uneven Proportions"))
  )

```

### Calculate Violations

*Calculate Violation Percentages per Condition*

```{r}
#| label: "calculate-violations"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Step 6 Part 2: Summarize Violations and Adjust for Errors

# 1. Summarize violations per condition
violation_summary <- final_data_with_actuals %>%
  mutate(
    Any_Violation = ifelse(is.na(Any_Violation), 0, Any_Violation),
    ErrorFlag = ifelse(is.na(ErrorFlag), 0, ErrorFlag)  # Ensure no missing values for ErrorFlag
  ) %>%
  group_by(FileName, Model, Population, N, Mixing_proportion, Lambda_values) %>%
  summarize(
    Total_Rows = n(),                                # Total runs
    Total_Violations = sum(Any_Violation, na.rm = TRUE), # Total violations
    Total_Errors = sum(ErrorFlag, na.rm = TRUE),         # Total errors from ErrorFlag
    Percentage_Violations = (Total_Violations / Total_Rows) * 100, # % violations
    .groups = "drop"
  ) %>%
  # 2. Calculate Replications Needed for label switching
  mutate(
    N_numeric = as.numeric(gsub("N = ", "", as.character(N))), 
    Additional_Runs = (500 + Total_Violations) * (Percentage_Violations / 100), 
    Replications_Needed = ceiling(500 + Total_Violations + Additional_Runs + 20),
    Replications_Needed = if_else(Replications_Needed < 500, 500, Replications_Needed),
    ErrorRate = Total_Errors / Total_Rows,  # Calculate ErrorRate directly
    Adjusted_Replications_Needed = ceiling(Replications_Needed / (1 - ErrorRate)),
    Adjusted_Replications_Needed = if_else(Adjusted_Replications_Needed < 500, 500, Adjusted_Replications_Needed)
  ) %>%
  select(
    FileName, Model, Population, N, N_numeric, Mixing_proportion,
    Lambda_values, Total_Rows, Total_Violations, Total_Errors,
    ErrorRate, Percentage_Violations, Replications_Needed,
    Adjusted_Replications_Needed
  )

```

### Create APA Flextable of Label Switching, Errors, and Replications Needed for PART 2

```{r}

#| label: "summarize-violations"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true


# Update violation_summary to include TPs, Mix, and adjusted replications
violation_summary <- violation_summary %>%
  mutate(
    # Transition Probabilities based on Population
    TPs = case_when(
      Population == ".800" ~ 3.179,
      Population == ".200" ~ 0.407,
      TRUE ~ NA_real_
    ),
    
    # Numeric Mix column
    Mix = case_when(
      Mixing_proportion == "Even Proportions" ~ 1,
      Mixing_proportion == "Uneven Proportions" ~ 2,
      TRUE ~ NA_integer_
    )
  )

# Function to create datasets based on model and lambda values
create_combined_model_data <- function(data, model, lambda_values) {
  data %>%
    filter(Model == model, Lambda_values %in% lambda_values) %>%
    select(
      `Transition Probability` = Population,             
      TPs,                                    # Numeric transition probabilities
      N,                                      # Categorical sample size
      N_numeric,                              # Numeric sample size
      `Mixing Proportion` = Mixing_proportion, # Even/Uneven proportions
      Mix,                                    # Numeric mix column
      Lambda = Lambda_values,                 # Lambda column
      `Total Mplus Runs` = Total_Rows,        # Total rows
      `Total Violations` = Total_Violations,  # Total Violations
      `% of Violations` = Percentage_Violations, # Violation percentage
      `Total Errors` = Total_Errors,           #Total Eerrors
      `Error Rate` = ErrorRate,               # Error Rate
      `Replications Needed` = Replications_Needed, # Original replications needed
       Adjusted_Replications_Needed           # Final replications
    )
}

# Datasets with multiple lambdas
model1_data <- create_combined_model_data(violation_summary, "Model 1", c("0.3", "0.5", "0.7", "0.9"))
model2_data <- create_combined_model_data(violation_summary, "Model 2", c("0.3", "0.5", "0.7", "0.9"))
model3_data <- create_combined_model_data(violation_summary, "Model 3", c("0.3", "0.5", "0.7", "0.9"))

# Datasets with single lambdas
model4_data <- create_combined_model_data(violation_summary, "Model 1", c("A"))
model5_data <- create_combined_model_data(violation_summary, "Model 1", c("B"))
model6_data <- create_combined_model_data(violation_summary, "Model 1", c("C"))
model7_data <- create_combined_model_data(violation_summary, "Model 1", c("D"))

model8_data <- create_combined_model_data(violation_summary, "Model 2", c("A"))
model9_data <- create_combined_model_data(violation_summary, "Model 2", c("B"))
model10_data <- create_combined_model_data(violation_summary, "Model 2", c("C"))
model11_data <- create_combined_model_data(violation_summary, "Model 2", c("D"))

model12_data <- create_combined_model_data(violation_summary, "Model 3", c("A"))
model13_data <- create_combined_model_data(violation_summary, "Model 3", c("B"))
model14_data <- create_combined_model_data(violation_summary, "Model 3", c("C"))
model15_data <- create_combined_model_data(violation_summary, "Model 3", c("D"))

# Define a function to create `gt` tables for models
create_gt_table <- function(data, model, Lambda) {
  data %>%
    gt() %>%
    tab_header(
      title = paste(model, ": Monte Carlo Results"),
      subtitle = paste("Lambda =", paste(Lambda, collapse = ", "), "- Label Switching and Errors Adjusted")
    ) %>%
    fmt_number(
      columns = c(`% of Violations`, `Error Rate`),
      decimals = 2
    ) %>%
    cols_align(align = "center", columns = everything()) %>%
    tab_options(
      table.font.size = "small",
      heading.title.font.size = "medium",
      heading.subtitle.font.size = "small"
    ) %>%
    tab_style(style = cell_text(align = "center"), locations = cells_column_labels(everything()))
}

# Generate tables for each data frame
model1_table <- create_gt_table(model1_data, "Model 1", c("0.3", "0.5", "0.7", "0.9"))
model2_table <- create_gt_table(model2_data, "Model 2", c("0.3", "0.5", "0.7", "0.9"))
model3_table <- create_gt_table(model3_data, "Model 3", c("0.3", "0.5", "0.7", "0.9"))

model4_table <- create_gt_table(model4_data, "Model 1", c("A"))
model5_table <- create_gt_table(model5_data, "Model 1", c("B"))
model6_table <- create_gt_table(model6_data, "Model 1", c("C"))
model7_table <- create_gt_table(model7_data, "Model 1", c("D"))

model8_table <- create_gt_table(model8_data, "Model 2", c("A"))
model9_table <- create_gt_table(model9_data, "Model 2", c("B"))
model10_table <- create_gt_table(model10_data, "Model 2", c("C"))
model11_table <- create_gt_table(model11_data, "Model 2", c("D"))

model12_table <- create_gt_table(model12_data, "Model 3", c("A"))
model13_table <- create_gt_table(model13_data, "Model 3", c("B"))
model14_table <- create_gt_table(model14_data, "Model 3", c("C"))
model15_table <- create_gt_table(model15_data, "Model 3", c("D"))


# Print each table by name
model1_table
model2_table
model3_table
model4_table
model5_table
model6_table
model7_table
model8_table
model9_table
model10_table
model11_table
model12_table
model13_table
model14_table
model15_table

```

#### Step 5: Part 4 Summarize Violations

*Create Iterator files with adjusted_replications_needed for part two SIMULATION that **ONLY** have cases with errors.*

```{r}
# Filter violation_summary for conditions with both non-zero violations and non-zero error rates
filtered_violation_summary <- violation_summary %>%
  filter(Percentage_Violations > 0, ErrorRate > 0)

# Ensure the `Transition Probability` column is consistently handled
filtered_violation_summary <- filtered_violation_summary %>%
  mutate(
    # Transition Probabilities based on Population
    TPs = case_when(
      Population == ".800" ~ 3.179,
      Population == ".200" ~ 0.407,
      TRUE ~ NA_real_
    ),
    
    # Numeric Mix column
    Mix = case_when(
      Mixing_proportion == "Even Proportions" ~ 1,
      Mixing_proportion == "Uneven Proportions" ~ 2,
      TRUE ~ NA_integer_
    )
  ) %>%
  rename(
    `Transition Probability` = Population # Rename column for clarity
  )

# Proceed with table creation as per the earlier code


# Function to create datasets based on model and lambda values
create_combined_model_data <- function(data, model, lambda_values) {
  data %>%
    filter(Model == model, Lambda_values %in% lambda_values) %>%
    select(
      `Transition Probability`,               # Already renamed earlier
      TPs,                                    # Numeric transition probabilities
      N_numeric,                              # Sample size as numeric
      `Mixing Proportion` = Mixing_proportion, # Correct column name for Even/Uneven proportions
      Mix,                                    # Numeric mix column
      Lambda = Lambda_values,                 # Lambda column
      `Total Mplus Runs` = Total_Rows,        # Total rows
      `Total Violations` = Total_Violations,  # Total Violations
      `% of Violations` = Percentage_Violations, # Violation percentage
      `Error Rate` = ErrorRate,               # Error Rate
      `Replications Needed` = Replications_Needed, # Original replications needed
      Adjusted_Replications_Needed            # Final replications
    )
}


# Datasets with multiple lambdas
model1_data <- create_combined_model_data(filtered_violation_summary, "Model 1", c("0.3", "0.5", "0.7", "0.9"))
model2_data <- create_combined_model_data(filtered_violation_summary, "Model 2", c("0.3", "0.5", "0.7", "0.9"))
model3_data <- create_combined_model_data(filtered_violation_summary, "Model 3", c("0.3", "0.5", "0.7", "0.9"))

# Datasets with single lambdas
model4_data <- create_combined_model_data(filtered_violation_summary, "Model 1", c("A"))
model5_data <- create_combined_model_data(filtered_violation_summary, "Model 1", c("B"))
model6_data <- create_combined_model_data(filtered_violation_summary, "Model 1", c("C"))
model7_data <- create_combined_model_data(filtered_violation_summary, "Model 1", c("D"))

model8_data <- create_combined_model_data(filtered_violation_summary, "Model 2", c("A"))
model9_data <- create_combined_model_data(filtered_violation_summary, "Model 2", c("B"))
model10_data <- create_combined_model_data(filtered_violation_summary, "Model 2", c("C"))
model11_data <- create_combined_model_data(filtered_violation_summary, "Model 2", c("D"))

model12_data <- create_combined_model_data(filtered_violation_summary, "Model 3", c("A"))
model13_data <- create_combined_model_data(filtered_violation_summary, "Model 3", c("B"))
model14_data <- create_combined_model_data(filtered_violation_summary, "Model 3", c("C"))
model15_data <- create_combined_model_data(filtered_violation_summary, "Model 3", c("D"))

# Function to generate a gt table for display
create_gt_table <- function(data, model, lambda) {
  data %>%
    gt() %>%
    tab_header(
      title = paste(model, ": Monte Carlo Results (Filtered)"),
      subtitle = paste("Lambda =", paste(lambda, collapse = ", "), "- Label Switching and Errors Included")
    ) %>%
    cols_align(align = "center", columns = everything()) %>%
    tab_options(data_row.padding = px(4)) %>%
    tab_style(style = cell_text(align = "center"), locations = cells_column_labels(everything()))
}

# Generate tables for each data frame
model1_table <- create_gt_table(model1_data, "Model 1", c("0.3", "0.5", "0.7", "0.9"))
model2_table <- create_gt_table(model2_data, "Model 2", c("0.3", "0.5", "0.7", "0.9"))
model3_table <- create_gt_table(model3_data, "Model 3", c("0.3", "0.5", "0.7", "0.9"))

model4_table <- create_gt_table(model4_data, "Model 1", c("A"))
model5_table <- create_gt_table(model5_data, "Model 1", c("B"))
model6_table <- create_gt_table(model6_data, "Model 1", c("C"))
model7_table <- create_gt_table(model7_data, "Model 1", c("D"))

model8_table <- create_gt_table(model8_data, "Model 2", c("A"))
model9_table <- create_gt_table(model9_data, "Model 2", c("B"))
model10_table <- create_gt_table(model10_data, "Model 2", c("C"))
model11_table <- create_gt_table(model11_data, "Model 2", c("D"))

model12_table <- create_gt_table(model12_data, "Model 3", c("A"))
model13_table <- create_gt_table(model13_data, "Model 3", c("B"))
model14_table <- create_gt_table(model14_data, "Model 3", c("C"))
model15_table <- create_gt_table(model15_data, "Model 3", c("D"))

# Print each table by name
model1_table
model2_table
model3_table
model4_table
model5_table
model6_table
model7_table
model8_table
model9_table
model10_table
model11_table
model12_table
model13_table
model14_table
model15_table


```

Save Tables

```{r}
#| label: "render-violation-tables"
#| echo: true
#| message: false
#| warning: false

invisible(save_as_image(violation_summary_table, path = here('Simulations', 'STUDY_1', "2 Time Points", "zErrors", "l_l_e&v_1.svg"))
   )
```

------------------------------------------------------------------------

# PART 2 Re-Run Simulations

------------------------------------------------------------------------

### Re-Run Simulation with Dynamic Replication Conditions

## Model 1

```{r,eval = FALSE}
#| label: "rilta-lta-simulation-Model 1b"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true


  # Define the Mplus object with the dynamic replications
rilta_lta_func <- function(N_numeric, TPs, Lambda, Mix, Adjusted_Replications_Needed) {
  
  # Step 2.1: Construct the MODELPOPULATION argument based on the value of 'mix'
  MODELPOPULATION <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      
       f by u11-u15*{Lambda} (p1-p5)
            u21-u25*{Lambda} (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;

       f by u11-u15*{Lambda} (p1-p5)
            u21-u25*{Lambda} (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  }

  # Step 2.2: Construct the MODEL argument based on the value of 'mix'
  MODEL <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2: 	
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2: 	
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  }

  # Step 2.3: Construct the MODELCONSTRAINT argument based on the value of 'TPs'
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);

      
    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
      
    ")
  }

  # Step 3: Construct the Mplus object
  RILTA_LTA <- mplusObject(
    TITLE = glue("RILTA_LTA_M1_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_{Lambda}"),
    MONTECARLO = glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N_numeric};
      SEED = 07252005;
      NREPS = {Adjusted_Replications_Needed};
      !SAVE = repM1*.dat;
      RESULTS = RILTA_LTA_M1_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_{Lambda}.csv;"),
    
    
      ANALYSIS =
      "TYPE = MIXTURE;
      algorithm = integration;
      INTEGRATION = STANDARD(20);
      processors = 24;
      miterations = 1000; 
      starts= 250 100;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    OUTPUT = "TECH9",
    
    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Step 4: Run Mplus model
  RILTA_LTA_Model <- mplusModeler(
    RILTA_LTA, 
    dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', glue("RILTA_LTA_M1_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_{Lambda}.dat")),
    modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', "RILTA_LTA_M1_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_{Lambda}.inp")),
    check = TRUE, run = TRUE, hashfilename = FALSE
  )
  return(RILTA_LTA_Model)
}

library(parallel)

# Start the cluster
num_cores <- detectCores() - 1

# Step 2: Select the cluster type based on the system (PSOCK for Windows, FORK for macOS/Linux)
cluster_type <- ifelse(.Platform$OS.type == "windows", "PSOCK", "FORK")


cl <- makeCluster(num_cores, type = cluster_type)

# Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func", "model1_data", "here", "glue", "mplusModeler", "mplusObject")))

# Ensure required libraries are loaded on each node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(model1_data), function(i) {
  rilta_lta_func(
    model1_data$N_numeric[i], 
    model1_data$TPs[i], 
    model1_data$Lambda[i], 
    model1_data$Mix[i],  
    model1_data$Adjusted_Replications_Needed[i]
  )
})

# Stop the cluster after the simulation
stopCluster(cl)
```

## Model 2

```{r, eval = FALSE}

#| label: "rilta-lta-simulation-Model 2b"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true


  # Define the Mplus object with the dynamic replications
rilta_lta_func2 <- function(N_numeric, TPs, Lambda, Mix, Adjusted_Replications_Needed) {
  
    # Construct the MODELPOPULATION argument based on the value of mix
  MODELPOPULATION <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
       
       f by u11-u15*{Lambda} (p1-p5)
            u21-u25*{Lambda} (p1-p5);
        f@1;
        [f@0];
        
        MODEL POPULATION-c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
       ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      
       f by u11-u15*{Lambda} (p1-p5)
            u21-u25*{Lambda} (p1-p5);
        f@1;
        [f@0];
        
     MODEL POPULATION-c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
       ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

     MODEL c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
	      ")      
      
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	      

     MODEL c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
	      ")      
  }
  
  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  }
  
  RILTA_LTA2 <- mplusObject(
    TITLE = glue("Generate RILTA_LTA_M2_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_{Lambda}"),

    MONTECARLO =
      glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N_numeric};
      SEED = 07252005;
      NREPS = {Adjusted_Replications_Needed};
      !SAVE = repM2*.dat;
      RESULTS = RILTA_LTA_M2_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_{Lambda}.csv;"),
    
    
      ANALYSIS =
      "TYPE = MIXTURE;
      algorithm = integration;
      INTEGRATION = STANDARD(20);
      processors = 24;
      miterations = 1000; 
      starts= 250 100;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    OUTPUT = "TECH9",

    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_LTA_Model2<- mplusModeler(RILTA_LTA2, 
                                   dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', glue("RILTA_LTA_M2_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_{Lambda}.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', "RILTA_LTA_M2_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_{Lambda}.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_LTA_Model2)
}

library(parallel)

# Start the cluster
num_cores <- detectCores() - 1

# Step 2: Select the cluster type based on the system (PSOCK for Windows, FORK for macOS/Linux)
cluster_type <- ifelse(.Platform$OS.type == "windows", "PSOCK", "FORK")


cl <- makeCluster(num_cores, type = cluster_type)

# Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func2", "model2_data", "here", "glue", "mplusModeler", "mplusObject")))

# Ensure required libraries are loaded on each node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(model2_data), function(i) {
  rilta_lta_func2(
    model2_data$N_numeric[i], 
    model2_data$TPs[i], 
    model2_data$Lambda[i], 
    model2_data$Mix[i],  
    model2_data$Adjusted_Replications_Needed[i]
  )
})

# Stop the cluster after the simulation
stopCluster(cl)
```

## Model 3

```{r, eval = FALSE}

#| label: "rilta-lta-simulation-Model 3b"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

  # Define the Mplus object with the dynamic replications
rilta_lta_func3 <- function(N_numeric, TPs, Lambda, Mix, Adjusted_Replications_Needed) {
  
    # Construct the MODELPOPULATION argument based on the value of mix
  MODELPOPULATION <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11-u15*{Lambda} (p1-p5)
            u21-u25*{Lambda} (p1-p5);
        f@1;
        [f@0];
          
        MODEL POPULATION-c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
       ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11-u15*{Lambda} (p1-p5)
            u21-u25*{Lambda} (p1-p5);
        f@1;
        [f@0];
              
     MODEL POPULATION-c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
       ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

     MODEL c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
	      ")      
      
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	      

     MODEL c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
	      ")      
  }
    
  
  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  }
  
  RILTA_LTA3 <- mplusObject(
    TITLE = glue("Generate RILTA_LTA_M3_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_{Lambda}"),

    MONTECARLO =
      glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N_numeric};
      SEED = 07252005;
      NREPS = {Adjusted_Replications_Needed};
      !SAVE = repM3*.dat;
      RESULTS = RILTA_LTA_M3_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_{Lambda}.csv;"),
    
    
      ANALYSIS =
      "TYPE = MIXTURE;
      algorithm = integration;
      INTEGRATION = STANDARD(20);
      processors = 24;
      miterations = 1000; 
      starts= 250 100;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    OUTPUT = "TECH9",

    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_LTA_Model3<- mplusModeler(RILTA_LTA3, 
                                   dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', glue("RILTA_LTA_M3_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_{Lambda}.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', "RILTA_LTA_M3_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_{Lambda}.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_LTA_Model3)
}

library(parallel)

# Start the cluster
num_cores <- detectCores() - 1

# Step 2: Select the cluster type based on the system (PSOCK for Windows, FORK for macOS/Linux)
cluster_type <- ifelse(.Platform$OS.type == "windows", "PSOCK", "FORK")


cl <- makeCluster(num_cores, type = cluster_type)

# Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func3", "model3_data", "here", "glue", "mplusModeler", "mplusObject")))

# Ensure required libraries are loaded on each node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(model3_data), function(i) {
  rilta_lta_func3(
    model3_data$N_numeric[i], 
    model3_data$TPs[i], 
    model3_data$Lambda[i], 
    model3_data$Mix[i],  
    model3_data$Adjusted_Replications_Needed[i]
  )
})

# Stop the cluster after the simulation
stopCluster(cl)
```

## Model 1A: Varied Lambda Pattern A

```{r,message=FALSE, warning=FALSE, eval = FALSE}
#| label: "rilta-lta-simulation-Model 1A-2"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

  # Define the Mplus object with the dynamic replications
rilta_lta_func4 <- function(N_numeric, TPs, Mix, Adjusted_Replications_Needed) {
  
  # Construct the MODELPOPULATION argument based on the value of mix
  MODELPOPULATION <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      
      	
       f by u11*.1 u12*.1 u13*.1 u14*.2 u15*1 (p1-p5)
            u21*.1 u22*.1 u23*.1 u24*.2 u25*1 (p1-p5);
        f@1;
        [f@0];
        
        
      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;

      	
       f by u11*.1 u12*.1 u13*.1 u14*.2 u15*1 (p1-p5)
            u21*.1 u22*.1 u23*.1 u24*.2 u25*1 (p1-p5);
        f@1;
        [f@0];
        
        
      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2: 	
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2: 	
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  }

  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      

    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      

    ")
  }

  # Construct the Mplus object
  RILTA_LTA4 <- mplusObject(
    TITLE = glue("RILTA_LTA_M1_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_A"),
    MONTECARLO = glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N_numeric};
      SEED = 07252005;
      NREPS = {Adjusted_Replications_Needed};
      !SAVE = repM4*.dat;
      RESULTS = RILTA_LTA_M1_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_A.csv;"),
    
    
      ANALYSIS =
      "TYPE = MIXTURE;
      algorithm = integration;
      INTEGRATION = STANDARD(20);
      processors = 24;
      miterations = 1000; 
      starts= 250 100;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    OUTPUT = "TECH9",
    
    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_LTA_Model4<- mplusModeler(RILTA_LTA4, 
                                   dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', glue("RILTA_LTA_M1_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_A.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', "RILTA_LTA_M1_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_A.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_LTA_Model4)
}

library(parallel)

# Start the cluster
num_cores <- detectCores() - 1

# Step 2: Select the cluster type based on the system (PSOCK for Windows, FORK for macOS/Linux)
cluster_type <- ifelse(.Platform$OS.type == "windows", "PSOCK", "FORK")

cl <- makeCluster(num_cores, type = cluster_type)

# Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func4", "model4_data", "here", "glue", "mplusModeler", "mplusObject")))

# Ensure required libraries are loaded on each node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(model4_data), function(i) {
  rilta_lta_func4(
    model4_data$N_numeric[i], 
    model4_data$TPs[i], 
    model4_data$Mix[i],  
    model4_data$Adjusted_Replications_Needed[i]
  )
})

# Stop the cluster after the simulation
stopCluster(cl)
```

## Model 1B: Varied Lambda Pattern B

```{r,message=FALSE, warning=FALSE, eval = FALSE}
#| label: "rilta-lta-simulation-Model 1B-2"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true


  # Define the Mplus object with the dynamic replications
rilta_lta_func5 <- function(N_numeric, TPs, Mix, Adjusted_Replications_Needed) {
  
  # Construct the MODELPOPULATION argument based on the value of mix
  MODELPOPULATION <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
        	
       f by u11*.3 u12*.2 u13*.3 u14*.7 u15*1 (p1-p5)
            u21*.3 u22*.2 u23*.3 u24*.7 u25*1 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;

      	
       f by u11*.3 u12*.2 u13*.3 u14*.7 u15*1 (p1-p5)
            u21*.3 u22*.2 u23*.3 u24*.7 u25*1 (p1-p5);
        f@1;
        [f@0];
        
        
      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2: 	
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2: 	
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  }

  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    
      
    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  }

  # Construct the Mplus object
  RILTA_LTA5 <- mplusObject(
    TITLE = glue("RILTA_LTA_M1_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_B"),
    MONTECARLO = glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N_numeric};
      SEED = 07252005;
      NREPS = {Adjusted_Replications_Needed};
      !SAVE = repM5*.dat;
      RESULTS = RILTA_LTA_M1_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_B.csv;"),
    
    
      ANALYSIS =
      "TYPE = MIXTURE;
      algorithm = integration;
      INTEGRATION = STANDARD(20);
      processors = 24;
      miterations = 1000; 
      starts= 250 100;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    OUTPUT = "TECH9",
    
    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_LTA_Model5<- mplusModeler(RILTA_LTA5, 
                                   dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', glue("RILTA_LTA_M1_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_B.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', "RILTA_LTA_M1_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_B.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_LTA_Model5)
}

library(parallel)

# Start the cluster
num_cores <- detectCores() - 1

# Step 2: Select the cluster type based on the system (PSOCK for Windows, FORK for macOS/Linux)
cluster_type <- ifelse(.Platform$OS.type == "windows", "PSOCK", "FORK")

cl <- makeCluster(num_cores, type = cluster_type)

# Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func5", "model5_data", "here", "glue", "mplusModeler", "mplusObject")))

# Ensure required libraries are loaded on each node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(model5_data), function(i) {
  rilta_lta_func5(
    model5_data$N_numeric[i], 
    model5_data$TPs[i], 
    model5_data$Mix[i],  
    model5_data$Adjusted_Replications_Needed[i]
  )
})

# Stop the cluster after the simulation
stopCluster(cl)
```

## Model 1C: Varied Lambda Pattern C

```{r,message=FALSE, warning=FALSE, eval = FALSE}

#| label: "rilta-lta-simulation-Model 1C-2"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true


  # Define the Mplus object with the dynamic replications
rilta_lta_func6 <- function(N_numeric, TPs, Mix, Adjusted_Replications_Needed) {
  
  # Construct the MODELPOPULATION argument based on the value of mix
  MODELPOPULATION <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.5 u12*.5 u13*.5 u14*.6 u15*1.4 (p1-p5)
            u21*.5 u22*.5 u23*.5 u24*.6 u25*1.4 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.5 u12*.5 u13*.5 u14*.6 u15*1.4 (p1-p5)
            u21*.5 u22*.5 u23*.5 u24*.6 u25*1.4 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2: 	
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2: 	
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  }

  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      

    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
 
    ")
  }

  # Construct the Mplus object
  RILTA_LTA6 <- mplusObject(
    TITLE = glue("RILTA_LTA_M1_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_C"),
    MONTECARLO = glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N_numeric};
      SEED = 07252005;
      NREPS = {Adjusted_Replications_Needed};
      !SAVE = repM6*.dat;
      RESULTS = RILTA_LTA_M1_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_C.csv;"),
    
    
      ANALYSIS =
      "TYPE = MIXTURE;
      algorithm = integration;
      INTEGRATION = STANDARD(20);
      processors = 24;
      miterations = 1000; 
      starts= 250 100;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    OUTPUT = "TECH9",
    
    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_LTA_Model6<- mplusModeler(RILTA_LTA6, 
                                   dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', glue("RILTA_LTA_M1_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_C.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', "RILTA_LTA_M1_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_C.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_LTA_Model6)
}

library(parallel)

# Start the cluster
num_cores <- detectCores() - 1

# Step 2: Select the cluster type based on the system (PSOCK for Windows, FORK for macOS/Linux)
cluster_type <- ifelse(.Platform$OS.type == "windows", "PSOCK", "FORK")

cl <- makeCluster(num_cores, type = cluster_type)

# Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func6", "model6_data", "here", "glue", "mplusModeler", "mplusObject")))

# Ensure required libraries are loaded on each node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(model6_data), function(i) {
  rilta_lta_func6(
    model6_data$N_numeric[i], 
    model6_data$TPs[i], 
    model6_data$Mix[i],  
    model6_data$Adjusted_Replications_Needed[i]
  )
})

# Stop the cluster after the simulation
stopCluster(cl)
```

## Model 1D: Varied Lambda Pattern D

```{r,message=FALSE, warning=FALSE, eval = FALSE}

#| label: "rilta-lta-simulation-Model 1D-2"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true


  # Define the Mplus object with the dynamic replications
rilta_lta_func7 <- function(N_numeric, TPs, Mix, Adjusted_Replications_Needed) {
  
  # Construct the MODELPOPULATION argument based on the value of mix
  MODELPOPULATION <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.5 u12*.5 u13*.5 u14*.6 u15*2.4 (p1-p5)
            u21*.5 u22*.5 u23*.5 u24*.6 u25*2.4 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.5 u12*.5 u13*.5 u14*.6 u15*2.4 (p1-p5)
            u21*.5 u22*.5 u23*.5 u24*.6 u25*.4 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  }

  # Construct the MODEL argument based on the value of Mix
  MODEL <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2: 	
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2: 	
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  }

  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      

    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      

    ")
  }

  # Construct the Mplus object
  RILTA_LTA7 <- mplusObject(
    TITLE = glue("RILTA_LTA_M1_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_D"),
    MONTECARLO = glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N_numeric};
      SEED = 07252005;
      NREPS = {Adjusted_Replications_Needed};
      !SAVE = repM7*.dat;
      RESULTS = RILTA_LTA_M1_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_D.csv;"),
    
    
      ANALYSIS =
      "TYPE = MIXTURE;
      algorithm = integration;
      INTEGRATION = STANDARD(20);
      processors = 24;
      miterations = 1000; 
      starts= 250 100;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    OUTPUT = "TECH9",
    
    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_LTA_Model7<- mplusModeler(RILTA_LTA7, 
                                   dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', glue("RILTA_LTA_M1_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_D.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', "RILTA_LTA_M1_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_D.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_LTA_Model7)
}

 library(parallel)

# Start the cluster
num_cores <- detectCores() - 1

# Step 2: Select the cluster type based on the system (PSOCK for Windows, FORK for macOS/Linux)
cluster_type <- ifelse(.Platform$OS.type == "windows", "PSOCK", "FORK")

cl <- makeCluster(num_cores, type = cluster_type)

# Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func7", "model7_data", "here", "glue", "mplusModeler", "mplusObject")))

# Ensure required libraries are loaded on each node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(model7_data), function(i) {
  rilta_lta_func7(
    model7_data$N_numeric[i], 
    model7_data$TPs[i], 
    model7_data$Mix[i],  
    model7_data$Adjusted_Replications_Needed[i]
  )
})

# Stop the cluster after the simulation
stopCluster(cl)
```

## Model 2A: Varied Lambda Pattern A

```{r,message=FALSE, warning=FALSE, eval = FALSE}

#| label: "rilta-lta-simulation-Model 2A-2"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true


  # Define the Mplus object with the dynamic replications
rilta_lta_func8 <- function(N_numeric, TPs, Mix, Adjusted_Replications_Needed) {
  
  # Construct the MODELPOPULATION argument based on the value of mix
  MODELPOPULATION <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.1 u12*.1 u13*.1 u14*.2 u15*1 (p1-p5)
            u21*.1 u22*.1 u23*.1 u24*.2 u25*1 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.1 u12*.1 u13*.1 u14*.2 u15*1 (p1-p5)
            u21*.1 u22*.1 u23*.1 u24*.2 u25*1 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
  }

  # Construct the MODEL argument based on the value of Mix
  MODEL <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

      MODEL c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL c2: 	
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

      MODEL c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL c2: 	
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
  }

  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);

    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      

    ")
  }

  # Construct the Mplus object
  RILTA_LTA8 <- mplusObject(
    TITLE = glue("RILTA_LTA_M2_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_A"),
    MONTECARLO = glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N_numeric};
      SEED = 07252005;
      NREPS = {Adjusted_Replications_Needed};
      !SAVE = repM8*.dat;
      RESULTS = RILTA_LTA_M2_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_A.csv;"),
    
    
      ANALYSIS =
      "TYPE = MIXTURE;
      algorithm = integration;
      INTEGRATION = STANDARD(20);
      processors = 24;
      miterations = 1000; 
      starts= 250 100;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    OUTPUT = "TECH9",
    
    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_LTA_Model8<- mplusModeler(RILTA_LTA8, 
                                   dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', glue("RILTA_LTA_M2_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_A.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', "RILTA_LTA_M2_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_A.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_LTA_Model8)
}

library(parallel)

# Start the cluster
num_cores <- detectCores() - 1

# Step 2: Select the cluster type based on the system (PSOCK for Windows, FORK for macOS/Linux)
cluster_type <- ifelse(.Platform$OS.type == "windows", "PSOCK", "FORK")

cl <- makeCluster(num_cores, type = cluster_type)

# Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func8", "model8_data", "here", "glue", "mplusModeler", "mplusObject")))

# Ensure required libraries are loaded on each node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(model8_data), function(i) {
  rilta_lta_func8(
    model8_data$N_numeric[i], 
    model8_data$TPs[i], 
    model8_data$Mix[i],  
    model8_data$Adjusted_Replications_Needed[i]
  )
})

# Stop the cluster after the simulation
stopCluster(cl)
```

## Model 2B: Varied Lambda Pattern B

```{r,message=FALSE, warning=FALSE, eval = FALSE}

#| label: "rilta-lta-simulation-Model-2B-2"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true


  # Define the Mplus object with the dynamic replications
rilta_lta_func9 <- function(N_numeric, TPs, Mix, Adjusted_Replications_Needed) {
  
  # Construct the MODELPOPULATION argument based on the value of mix
  MODELPOPULATION <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.3 u12*.2 u13*.3 u14*.7 u15*1 (p1-p5)
            u21*.3 u22*.2 u23*.3 u24*.7 u25*1 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.3 u12*.2 u13*.3 u14*.7 u15*1 (p1-p5)
            u21*.3 u22*.2 u23*.3 u24*.7 u25*1 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

      MODEL c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL c2: 	
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

      MODEL c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL c2: 	
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
  }

  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      

    ")
  }

  # Construct the Mplus object
  RILTA_LTA9 <- mplusObject(
    TITLE = glue("RILTA_LTA_M2_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_B"),
    MONTECARLO = glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N_numeric};
      SEED = 07252005;
      NREPS = {Adjusted_Replications_Needed};
      !SAVE = repM9*.dat;
      RESULTS = RILTA_LTA_M2_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_B.csv;"),
    
      ANALYSIS =
      "TYPE = MIXTURE;
      algorithm = integration;
      INTEGRATION = STANDARD(20);
      processors = 24;
      miterations = 1000; 
      starts= 250 100;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    OUTPUT = "TECH9",
    
    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_LTA_Model9<- mplusModeler(RILTA_LTA9, 
                                   dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', glue("RILTA_LTA_M2_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_B.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', "RILTA_LTA_M2_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_B.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_LTA_Model9)
}

library(parallel)

# Start the cluster
num_cores <- detectCores() - 1

# Step 2: Select the cluster type based on the system (PSOCK for Windows, FORK for macOS/Linux)
cluster_type <- ifelse(.Platform$OS.type == "windows", "PSOCK", "FORK")

cl <- makeCluster(num_cores, type = cluster_type)

# Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func9", "model9_data", "here", "glue", "mplusModeler", "mplusObject")))

# Ensure required libraries are loaded on each node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(model9_data), function(i) {
  rilta_lta_func9(
    model9_data$N_numeric[i], 
    model9_data$TPs[i], 
    model9_data$Mix[i],  
    model9_data$Adjusted_Replications_Needed[i]
  )
})

# Stop the cluster after the simulation
stopCluster(cl)
```

## Model 2C: Varied Lambda Pattern C

```{r,message=FALSE, warning=FALSE, eval = FALSE}

#| label: "rilta-lta-simulation-Model-2C-2"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

  # Define the Mplus object with the dynamic replications
rilta_lta_func10 <- function(N_numeric, TPs, Mix, Adjusted_Replications_Needed) {
  
  # Construct the MODELPOPULATION argument based on the value of mix
  MODELPOPULATION <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.5 u12*.5 u13*.5 u14*.6 u15*1.4 (p1-p5)
            u21*.5 u22*.5 u23*.5 u24*.6 u25*1.4 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.5 u12*.5 u13*.5 u14*.6 u15*1.4 (p1-p5)
            u21*.5 u22*.5 u23*.5 u24*.6 u25*1.4 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

      MODEL c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL c2: 	
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

      MODEL c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL c2: 	
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
  }

  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      

    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      

    ")
  }

  # Construct the Mplus object
  RILTA_LTA10 <- mplusObject(
    TITLE = glue("RILTA_LTA_M2_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_C"),
    MONTECARLO = glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N_numeric};
      SEED = 07252005;
      NREPS = {Adjusted_Replications_Needed};
      !SAVE = repM10*.dat;
      RESULTS = RILTA_LTA_M2_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_C.csv;"),
    
      ANALYSIS =
      "TYPE = MIXTURE;
      algorithm = integration;
      INTEGRATION = STANDARD(20);
      processors = 24;
      miterations = 1000; 
      starts= 250 100;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    OUTPUT = "TECH9",
    
    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_LTA_Model10<- mplusModeler(RILTA_LTA10, 
                                   dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', glue("RILTA_LTA_M2_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_C.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', "RILTA_LTA_M2_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_C.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_LTA_Model10)
}

library(parallel)

# Start the cluster
num_cores <- detectCores() - 1

# Step 2: Select the cluster type based on the system (PSOCK for Windows, FORK for macOS/Linux)
cluster_type <- ifelse(.Platform$OS.type == "windows", "PSOCK", "FORK")

cl <- makeCluster(num_cores, type = cluster_type)

# Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func10", "model10_data", "here", "glue", "mplusModeler", "mplusObject")))

# Ensure required libraries are loaded on each node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(model10_data), function(i) {
  rilta_lta_func10(
    model10_data$N_numeric[i], 
    model10_data$TPs[i], 
    model10_data$Mix[i],  
    model10_data$Adjusted_Replications_Needed[i]
  )
})

# Stop the cluster after the simulation
stopCluster(cl)
```

## Model 2D: Varied Lambda Pattern D

```{r,eval = FALSE}

#| label: "rilta-lta-simulation-Model-2D-2"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

  # Define the Mplus object with the dynamic replications
rilta_lta_func11 <- function(N_numeric, TPs, Mix, Adjusted_Replications_Needed) {
  
  # Construct the MODELPOPULATION argument based on the value of mix
  MODELPOPULATION <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.5 u12*.5 u13*.5 u14*.6 u15*2.4 (p1-p5)
            u21*.5 u22*.5 u23*.5 u24*.6 u25*2.4 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.5 u12*.5 u13*.5 u14*.6 u15*2.4 (p1-p5)
            u21*.5 u22*.5 u23*.5 u24*.6 u25*2.4 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

      MODEL c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL c2: 	
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

      MODEL c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL c2: 	
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
  }

  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      

    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      

    ")
  }

  # Construct the Mplus object
  RILTA_LTA11 <- mplusObject(
    TITLE = glue("RILTA_LTA_M2_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_D"),
    MONTECARLO = glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N_numeric};
      SEED = 07252005;
      NREPS = {Adjusted_Replications_Needed};
      !SAVE = repM11*.dat;
      RESULTS = RILTA_LTA_M2_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_D.csv;"),
    
      ANALYSIS =
      "TYPE = MIXTURE;
      algorithm = integration;
      INTEGRATION = STANDARD(20);
      processors = 24;
      miterations = 1000; 
      starts= 250 100;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    OUTPUT = "TECH9",
    
    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_LTA_Model11<- mplusModeler(RILTA_LTA11, 
                                   dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', glue("RILTA_LTA_M2_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_D.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', "RILTA_LTA_M2_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_D.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_LTA_Model11)
}

library(parallel)

# Start the cluster
num_cores <- detectCores() - 1

# Step 2: Select the cluster type based on the system (PSOCK for Windows, FORK for macOS/Linux)
cluster_type <- ifelse(.Platform$OS.type == "windows", "PSOCK", "FORK")

cl <- makeCluster(num_cores, type = cluster_type)

# Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func11", "model11_data", "here", "glue", "mplusModeler", "mplusObject")))

# Ensure required libraries are loaded on each node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(model11_data), function(i) {
  rilta_lta_func11(
    model11_data$N_numeric[i], 
    model11_data$TPs[i], 
    model11_data$Mix[i],  
    model11_data$Adjusted_Replications_Needed[i]
  )
})

# Stop the cluster after the simulation
stopCluster(cl)
```

## Model 3A: Varied Lambda Pattern A

```{r,message=FALSE, warning=FALSE, eval = FALSE}

#| label: "rilta-lta-simulation-Model-3A-2"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

  # Define the Mplus object with the dynamic replications
rilta_lta_func12 <- function(N_numeric, TPs, Mix, Adjusted_Replications_Needed) {
  
    # Construct the MODELPOPULATION argument based on the value of mix
  MODELPOPULATION <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.1 u12*.1 u13*.1 u14*.2 u15*1 (p1-p5)
            u21*.1 u22*.1 u23*.1 u24*.2 u25*1 (p1-p5);
        f@1;
        [f@0];
          
        MODEL POPULATION-c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
       ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.1 u12*.1 u13*.1 u14*.2 u15*1 (p1-p5)
            u21*.1 u22*.1 u23*.1 u24*.2 u25*1 (p1-p5);
        f@1;
        [f@0];
              
     MODEL POPULATION-c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
       ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

     MODEL c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
	      ")      
      
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	      

     MODEL c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
	      ")      
  }
    
  
  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      

    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      

    ")
  }
  
  RILTA_LTA12 <- mplusObject(
    TITLE = glue("Generate RILTA_LTA_M3_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_A"),

    MONTECARLO =
      glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N_numeric};
      SEED = 07252005;
      NREPS = {Adjusted_Replications_Needed};
      !SAVE = repM12*.dat;
      RESULTS = RILTA_LTA_M3_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_A.csv;"),
    
    
      ANALYSIS =
      "TYPE = MIXTURE;
      algorithm = integration;
      INTEGRATION = STANDARD(20);
      processors = 24;
      miterations = 1000; 
      starts= 250 100;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    OUTPUT = "TECH9",

    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_LTA_Model12<- mplusModeler(RILTA_LTA12, 
                                   dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', glue("RILTA_LTA_M3_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_A.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', "RILTA_LTA_M3_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_A.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_LTA_Model12)
}

library(parallel)

# Start the cluster
num_cores <- detectCores() - 1

# Step 2: Select the cluster type based on the system (PSOCK for Windows, FORK for macOS/Linux)
cluster_type <- ifelse(.Platform$OS.type == "windows", "PSOCK", "FORK")

cl <- makeCluster(num_cores, type = cluster_type)

# Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func12", "model12_data", "here", "glue", "mplusModeler", "mplusObject")))

# Ensure required libraries are loaded on each node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(model12_data), function(i) {
  rilta_lta_func12(
    model12_data$N_numeric[i], 
    model12_data$TPs[i], 
    model12_data$Mix[i],  
    model12_data$Adjusted_Replications_Needed[i]
  )
})

# Stop the cluster after the simulation
stopCluster(cl)
```

## Model 3B: Varied Lambda Pattern B

```{r,message=FALSE, warning=FALSE, eval = FALSE}

#| label: "rilta-lta-simulation-Model-3B-2"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

  # Define the Mplus object with the dynamic replications
rilta_lta_func13 <- function(N_numeric, TPs, Mix, Adjusted_Replications_Needed) {
  
    # Construct the MODELPOPULATION argument based on the value of mix
  MODELPOPULATION <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.3 u12*.2 u13*.3 u14*.7 u15*1 (p1-p5)
            u21*.3 u22*.2 u23*.3 u24*.7 u25*1 (p1-p5);
        f@1;
        [f@0];
          
        MODEL POPULATION-c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
       ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.3 u12*.2 u13*.3 u14*.7 u15*1 (p1-p5)
            u21*.3 u22*.2 u23*.3 u24*.7 u25*1 (p1-p5);
        f@1;
        [f@0];
              
     MODEL POPULATION-c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
       ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

     MODEL c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
	      ")      
      
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	      

     MODEL c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
	      ")      
  }
    
  
  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);

    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);

    ")
  }
  
  RILTA_LTA13 <- mplusObject(
    TITLE = glue("Generate RILTA_LTA_M3_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_B"),

    MONTECARLO =
      glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N_numeric};
      SEED = 07252005;
      NREPS = {Adjusted_Replications_Needed};
      !SAVE = repM13*.dat;
      RESULTS = RILTA_LTA_M3_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_B.csv;"),
    
    
      ANALYSIS =
      "TYPE = MIXTURE;
      algorithm = integration;
      INTEGRATION = STANDARD(20);
      processors = 24;
      miterations = 1000; 
      starts= 250 100;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    OUTPUT = "TECH9",

    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_LTA_Model13<- mplusModeler(RILTA_LTA13, 
                                   dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', glue("RILTA_LTA_M3_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_B.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', "RILTA_LTA_M3_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_B.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_LTA_Model13)
}

library(parallel)

# Start the cluster
num_cores <- detectCores() - 1

# Step 2: Select the cluster type based on the system (PSOCK for Windows, FORK for macOS/Linux)
cluster_type <- ifelse(.Platform$OS.type == "windows", "PSOCK", "FORK")

cl <- makeCluster(num_cores, type = cluster_type)

# Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func13", "model13_data", "here", "glue", "mplusModeler", "mplusObject")))

# Ensure required libraries are loaded on each node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(model13_data), function(i) {
  rilta_lta_func13(
    model13_data$N_numeric[i], 
    model13_data$TPs[i], 
    model13_data$Mix[i],  
    model13_data$Adjusted_Replications_Needed[i]
  )
})

# Stop the cluster after the simulation
stopCluster(cl)
```

## Model 3C: Varied Lambda Pattern C

```{r,message=FALSE, warning=FALSE, eval = FALSE}

#| label: "rilta-lta-simulation-Model-3C-2"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

  # Define the Mplus object with the dynamic replications
rilta_lta_func14 <- function(N_numeric, TPs, Mix, Adjusted_Replications_Needed) {
  
    # Construct the MODELPOPULATION argument based on the value of mix
  MODELPOPULATION <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.5 u12*.5 u13*.5 u14*.6 u15*1.4 (p1-p5)
            u21*.5 u22*.5 u23*.5 u24*.6 u25*1.4 (p1-p5);
        f@1;
        [f@0];
          
        MODEL POPULATION-c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
       ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.3 u12*.2 u13*.3 u14*.7 u15*1 (p1-p5)
            u21*.3 u22*.2 u23*.3 u24*.7 u25*1 (p1-p5);
        f@1;
        [f@0];
              
     MODEL POPULATION-c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
       ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

     MODEL c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
	      ")      
      
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	      

     MODEL c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
	      ")      
  }
    
  
  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);

    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);

    ")
  }
  
  RILTA_LTA14 <- mplusObject(
    TITLE = glue("Generate RILTA_LTA_M3_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_B"),

    MONTECARLO =
      glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N_numeric};
      SEED = 07252005;
      NREPS = {Adjusted_Replications_Needed};
      !SAVE = repM14*.dat;
      RESULTS = RILTA_LTA_M3_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_C.csv;"),
    
    
      ANALYSIS =
      "TYPE = MIXTURE;
      algorithm = integration;
      INTEGRATION = STANDARD(20);
      processors = 24;
      miterations = 1000; 
      starts= 250 100;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    OUTPUT = "TECH9",

    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_LTA_Model14<- mplusModeler(RILTA_LTA14, 
                                   dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', glue("RILTA_LTA_M3_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_C.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', "RILTA_LTA_M3_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_C.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_LTA_Model14)
}

library(parallel)

# Start the cluster
num_cores <- detectCores() - 1

# Step 2: Select the cluster type based on the system (PSOCK for Windows, FORK for macOS/Linux)
cluster_type <- ifelse(.Platform$OS.type == "windows", "PSOCK", "FORK")

cl <- makeCluster(num_cores, type = cluster_type)

# Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func14", "model14_data", "here", "glue", "mplusModeler", "mplusObject")))

# Ensure required libraries are loaded on each node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(model14_data), function(i) {
  rilta_lta_func14(
    model14_data$N_numeric[i], 
    model14_data$TPs[i], 
    model14_data$Mix[i],  
    model14_data$Adjusted_Replications_Needed[i]
  )
})

# Stop the cluster after the simulation
stopCluster(cl)
```

## Model 3D: Varied Lambda Pattern D

```{r,message=FALSE, warning=FALSE, eval = FALSE}

#| label: "rilta-lta-simulation-Model-3D-2"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

  # Define the Mplus object with the dynamic replications
rilta_lta_func15 <- function(N_numeric, TPs, Mix, Adjusted_Replications_Needed) {
  
    # Step 2: Construct the MODELPOPULATION argument based on the value of mix
  MODELPOPULATION <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.5 u12*.5 u13*.5 u14*.6 u15*2.4 (p1-p5)
            u21*.5 u22*.5 u23*.5 u24*.6 u25*2.4 (p1-p5);
        f@1;
        [f@0];
          
        MODEL POPULATION-c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
       ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.5 u12*.5 u13*.5 u14*.6 u15*2.4 (p1-p5)
            u21*.5 u22*.5 u23*.5 u24*.6 u25*2.4 (p1-p5);
        f@1;
        [f@0];
              
     MODEL POPULATION-c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
       ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

     MODEL c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
	      ")      
      
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	      

     MODEL c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
	      ")      
  }
    
  
  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      

    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
 
    ")
  }
  
  RILTA_LTA15 <- mplusObject(
    TITLE = glue("Generate RILTA_LTA_M3_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_D"),

    MONTECARLO =
      glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N_numeric};
      SEED = 07252005;
      NREPS = {Adjusted_Replications_Needed};
      !SAVE = repM15*.dat;
      RESULTS = RILTA_LTA_M3_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_D.csv;"),
    
    
      ANALYSIS =
      "TYPE = MIXTURE;
      algorithm = integration;
      INTEGRATION = STANDARD(20);
      processors = 24;
      miterations = 1000; 
      starts= 250 100;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    OUTPUT = "TECH9",

    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_LTA_Model15<- mplusModeler(RILTA_LTA15, 
                                   dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', glue("RILTA_LTA_M3_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_D.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', "RILTA_LTA_M3_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_D.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_LTA_Model15)
}

library(parallel)

# Start the cluster
num_cores <- detectCores() - 1

# Step 2: Select the cluster type based on the system (PSOCK for Windows, FORK for macOS/Linux)
cluster_type <- ifelse(.Platform$OS.type == "windows", "PSOCK", "FORK")

cl <- makeCluster(num_cores, type = cluster_type)

# Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func15", "model15_data", "here", "glue", "mplusModeler", "mplusObject")))

# Ensure required libraries are loaded on each node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(model15_data), function(i) {
  rilta_lta_func15(
    model15_data$N_numeric[i], 
    model15_data$TPs[i], 
    model15_data$Mix[i],  
    model15_data$Adjusted_Replications_Needed[i]
  )
})

# Stop the cluster after the simulation
stopCluster(cl)
```

------------------------------------------------------------------------

# Check for Label Switching and Errors - Part 2

> In this section: we re conduct the steps for aggregating the label switching and errors to guarantee that we will have at minimum 500 replications per condition.

------------------------------------------------------------------------

*Load all CSV files and combine them into a single data frame.*

```{r}
#| label: "combine-csv-files-parallel2"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true


# Step 1: Set the correct CSV directory
csv_directory <- here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP')

# Step 2: Source the child document
source(here('Child_Docs', 'data_scraping.R'))
```

*Extract the appropriate rows from each 9-row chunk) and prepare the data for further processing.*

```{r}

#| label: "scrape-rows-process-data-parallel2"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Step 2: Process the data using the child script
source(here('Child_Docs', 'step2_f_LTA.R'))

```

*Convert the logits to probabilities and add the known actual values to each row.*

```{r}
#| label: "convert-logits-and-flags2"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Step 3: Process the data and return results
source(here('Child_Docs', 'step_3.R'))

# The objects `final_data_with_actuals` and `violators` should now be in the global environment
```

*Scrape Output Files for Errors*

```{r}
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Step 1: Set the correct output directory for .out files
output_folder <- here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP')

# Step 2: Source the child document that processes .out files
source(here('Child_Docs', 'out_scraping.R'))

# ===================================================== #
#   SECTION 1 Generate Replication Summary Table
# ===================================================== #
replication_summary_table <- replication_summary %>%
  gt() %>%
  tab_header(
    title = "Replication Summary",
    subtitle = paste0("Folder: ", output_folder)
  ) %>%
  fmt_number(
    columns = c("Total", "Replicated_Yes", "Replicated_No", "Error_Count"),
    decimals = 0
  ) %>%
  cols_label(
    FileName = "File Name",
    Total = "Total Replications",
    Replicated_Yes = "LL Replicated",
    Replicated_No = "LL Not Replicated",
    Error_Count = "Errors"
  ) %>%
  cols_align(
    align = "center",
    columns = everything()
  ) %>%
  tab_options(
    table.font.size = "small",
    heading.title.font.size = "medium",
    heading.subtitle.font.size = "small",
    table.width = pct(80)
  )

# Display the table
replication_summary_table

# ===================================================== #
#   SECTION 2 Row Count Validation
# ===================================================== #
cat("Rows in final_data_with_actuals:", nrow(final_data_with_actuals), "\n")
cat("Rows in final_results:", nrow(final_results), "\n")
cat("Rows in replication_summary:", nrow(replication_summary), "\n")
print(if (any(replication_summary$LL_Not_Replicated > 0, na.rm = TRUE)) {
  " WARNING: Some LL values were NOT replicated! Check the Replication Summary table."
} else {
  " All LL values were successfully replicated."
})
all.equal(final_data_with_actuals$ll_csv, final_results$ll_out, tolerance = 1e-4)


```

*Combine error information with main data file*

```{r}
#| label: "merge-errors2"
#| echo: true
#| message: false
#| warning: false

final_data_with_actuals <- final_data_with_actuals %>%
  left_join(final_results %>% select(FileName, Replication, ll_out, ErrorFlag),
            by = c("FileName", "Replication"))
```

*Visualize differences between ll_out and ll_csv*

```{r}
# Create a dataframe with only rows where ll_out and ll_csv differ
ll_mismatch <- final_data_with_actuals %>%
  mutate(diff = round(ll_out - ll_csv, 3)) %>%
  filter(diff != 0) %>%
  select(FileName, Replication, ll_out, ll_csv, diff)


ll_check <- final_data_with_actuals %>%
  mutate(diff = round(ll_out - ll_csv, 3)) %>%  # Round before counting
  count(diff)

ll_check_table <- ll_check %>%
  gt() %>%
  tab_header(
    title = "LL Difference Summary",
    subtitle = "Comparison of LL values between CSV and OUT files"
  ) %>%
  cols_label(
    diff = "LL Difference",
    n = "Count"
  ) %>%
  fmt_number(
    columns = diff,
    decimals = 3
  ) %>%
  cols_align(
    align = "center",
    columns = everything()
  ) %>%
  tab_options(
    table.font.size = "small",
    heading.title.font.size = "medium",
    heading.subtitle.font.size = "small",
    table.width = pct(50)
  )

# Display the table
ll_check_table
```

*Create Column Names from the File Name*

```{r}
#| label: "prepare-data-for-plotting-bias2"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true


# Add new columns based on the information in the FileName
final_data_with_actuals <- final_data_with_actuals %>%
  mutate(
    Model = case_when(
      grepl("m1", FileName) ~ "1",
      grepl("m2", FileName) ~ "2",
      grepl("m3", FileName) ~ "3",
      TRUE ~ NA_character_
    ),
    N = case_when(
      grepl("n_5000", FileName) ~ 4,  # Convert to factor level 4
      grepl("n_500", FileName) ~ 1,   # Convert to factor level 1
      grepl("n_1000", FileName) ~ 2,  # Convert to factor level 2
      grepl("n_2500", FileName) ~ 3,  # Convert to factor level 3
      TRUE ~ NA_integer_
    ),
    Mixing_proportion = case_when(
      grepl("m_1", FileName) ~ 1,  # Even Class Proportions as factor level 1
      grepl("m_2", FileName) ~ 2,  # Uneven Proportions as factor level 2
      TRUE ~ NA_integer_
    ),
    Lambda_values = case_when(
      grepl("l_0.3", FileName) ~ "0.3",
      grepl("l_0.5", FileName) ~ "0.5",
      grepl("l_0.7", FileName) ~ "0.7",
      grepl("l_0.9", FileName) ~ "0.9",
      grepl("l_a", FileName) ~ "A",
      grepl("l_b", FileName) ~ "B",
      grepl("l_c", FileName) ~ "C",
      grepl("l_d", FileName) ~ "D",
      TRUE ~ NA_character_
    ),
    # Add Population column based on FileName and convert it to a factor with formatted labels
    Population = case_when(
      grepl("tp_0.407", FileName) ~ ".200",
      grepl("tp_3.179", FileName) ~ ".800",
      TRUE ~ NA_character_
    )
  )

# Convert N, Mixing_proportion, and Model columns to factors
final_data_with_actuals <- final_data_with_actuals %>%
  mutate(
    Model = factor(Model, levels = c(1, 2, 3), labels = c("Model 1", "Model 2", "Model 3")),
    N = factor(N, levels = c(1, 2, 3, 4), labels = c("N = 500", "N = 1000", "N = 2500", "N = 5000")),
    Mixing_proportion = factor(Mixing_proportion, levels = c(1, 2), labels = c("Even Proportions", "Uneven Proportions"))
  )

```

*Calculate Violation Percentages per Condition*

```{r}
#| label: "calculate-violations2"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Step 6 Part 2: Summarize Violations and Adjust for Errors

# 1. Summarize violations per condition
violation_summary <- final_data_with_actuals %>%
  mutate(
    Any_Violation = ifelse(is.na(Any_Violation), 0, Any_Violation),
    ErrorFlag = ifelse(is.na(ErrorFlag), 0, ErrorFlag)  # Ensure no missing values for ErrorFlag
  ) %>%
  group_by(FileName, Model, Population, N, Mixing_proportion, Lambda_values) %>%
  summarize(
    Total_Rows = n(),                                # Total runs
    Total_Violations = sum(Any_Violation, na.rm = TRUE), # Total violations
    Total_Errors = sum(ErrorFlag, na.rm = TRUE),         # Total errors from ErrorFlag
    Percentage_Violations = (Total_Violations / Total_Rows) * 100, # % violations
    .groups = "drop"
  ) %>%
  # 2. Calculate Replications Needed for label switching
  mutate(
    N_numeric = as.numeric(gsub("N = ", "", as.character(N))), 
    Additional_Runs = (500 + Total_Violations) * (Percentage_Violations / 100), 
    Replications_Needed = ceiling(500 + Total_Violations + Additional_Runs + 20),
    Replications_Needed = if_else(Replications_Needed < 500, 500, Replications_Needed),
    ErrorRate = Total_Errors / Total_Rows,  # Calculate ErrorRate directly
    Adjusted_Replications_Needed = ceiling(Replications_Needed / (1 - ErrorRate)),
    Adjusted_Replications_Needed = if_else(Adjusted_Replications_Needed < 500, 500, Adjusted_Replications_Needed)
  ) %>%
  select(
    FileName, Model, Population, N, N_numeric, Mixing_proportion,
    Lambda_values, Total_Rows, Total_Violations, Total_Errors,
    ErrorRate, Percentage_Violations, Replications_Needed,
    Adjusted_Replications_Needed
  )

```

*Summarize & Visualize Label Switching Percentage Results*

```{r}

#| label: "summarize-errors-and-violations2"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true


# Update violation_summary to include TPs, Mix, and adjusted replications
violation_summary <- violation_summary %>%
  mutate(
    # Transition Probabilities based on Population
    TPs = case_when(
      Population == ".800" ~ 3.179,
      Population == ".200" ~ 0.407,
      TRUE ~ NA_real_
    ),
    
    # Numeric Mix column
    Mix = case_when(
      Mixing_proportion == "Even Proportions" ~ 1,
      Mixing_proportion == "Uneven Proportions" ~ 2,
      TRUE ~ NA_integer_
    )
  )

# Function to create datasets based on model and lambda values
create_combined_model_data <- function(data, model, lambda_values) {
  data %>%
    filter(Model == model, Lambda_values %in% lambda_values) %>%
    select(
      `Transition Probability` = Population,             
      TPs,                                    # Numeric transition probabilities
      N,                                      # Categorical sample size
      N_numeric,                              # Numeric sample size
      `Mixing Proportion` = Mixing_proportion, # Even/Uneven proportions
      Mix,                                    # Numeric mix column
      Lambda = Lambda_values,                 # Lambda column
      `Total Mplus Runs` = Total_Rows,        # Total rows
      `Total Violations` = Total_Violations,  # Total Violations
      `% of Violations` = Percentage_Violations, # Violation percentage
      `Total Errors` = Total_Errors,           #Total Eerrors
      `Error Rate` = ErrorRate
    )
}

# Datasets with multiple lambdas
model1_data <- create_combined_model_data(violation_summary, "Model 1", c("0.3", "0.5", "0.7", "0.9"))
model2_data <- create_combined_model_data(violation_summary, "Model 2", c("0.3", "0.5", "0.7", "0.9"))
model3_data <- create_combined_model_data(violation_summary, "Model 3", c("0.3", "0.5", "0.7", "0.9"))

# Datasets with single lambdas
model4_data <- create_combined_model_data(violation_summary, "Model 1", c("A"))
model5_data <- create_combined_model_data(violation_summary, "Model 1", c("B"))
model6_data <- create_combined_model_data(violation_summary, "Model 1", c("C"))
model7_data <- create_combined_model_data(violation_summary, "Model 1", c("D"))

model8_data <- create_combined_model_data(violation_summary, "Model 2", c("A"))
model9_data <- create_combined_model_data(violation_summary, "Model 2", c("B"))
model10_data <- create_combined_model_data(violation_summary, "Model 2", c("C"))
model11_data <- create_combined_model_data(violation_summary, "Model 2", c("D"))

model12_data <- create_combined_model_data(violation_summary, "Model 3", c("A"))
model13_data <- create_combined_model_data(violation_summary, "Model 3", c("B"))
model14_data <- create_combined_model_data(violation_summary, "Model 3", c("C"))
model15_data <- create_combined_model_data(violation_summary, "Model 3", c("D"))

# Define a function to create `gt` tables for models
create_gt_table <- function(data, model, Lambda) {
  data %>%
    gt() %>%
    tab_header(
      title = paste(model, ": Monte Carlo Results"),
      subtitle = paste("Lambda =", paste(Lambda, collapse = ", "), "- Label Switching and Errors Adjusted")
    ) %>%
    fmt_number(
      columns = c(`% of Violations`, `Error Rate`),
      decimals = 2
    ) %>%
    cols_align(align = "center", columns = everything()) %>%
    tab_options(
      table.font.size = "small",
      heading.title.font.size = "medium",
      heading.subtitle.font.size = "small"
    ) %>%
    tab_style(style = cell_text(align = "center"), locations = cells_column_labels(everything()))
}

# Generate tables for each data frame
model1_table <- create_gt_table(model1_data, "Model 1", c("0.3", "0.5", "0.7", "0.9"))
model2_table <- create_gt_table(model2_data, "Model 2", c("0.3", "0.5", "0.7", "0.9"))
model3_table <- create_gt_table(model3_data, "Model 3", c("0.3", "0.5", "0.7", "0.9"))

model4_table <- create_gt_table(model4_data, "Model 1", c("A"))
model5_table <- create_gt_table(model5_data, "Model 1", c("B"))
model6_table <- create_gt_table(model6_data, "Model 1", c("C"))
model7_table <- create_gt_table(model7_data, "Model 1", c("D"))

model8_table <- create_gt_table(model8_data, "Model 2", c("A"))
model9_table <- create_gt_table(model9_data, "Model 2", c("B"))
model10_table <- create_gt_table(model10_data, "Model 2", c("C"))
model11_table <- create_gt_table(model11_data, "Model 2", c("D"))

model12_table <- create_gt_table(model12_data, "Model 3", c("A"))
model13_table <- create_gt_table(model13_data, "Model 3", c("B"))
model14_table <- create_gt_table(model14_data, "Model 3", c("C"))
model15_table <- create_gt_table(model15_data, "Model 3", c("D"))


# Print each table by name
model1_table
model2_table
model3_table
model4_table
model5_table
model6_table
model7_table
model8_table
model9_table
model10_table
model11_table
model12_table
model13_table
model14_table
model15_table

```

Save the Table

```{r}
#| label: "render-violation-tables2"
#| echo: true
#| message: false
#| warning: false

invisible(save_as_image(violation_summary_table, path = here('Simulations', 'STUDY_1', "2 Time Points", "zErrors", "zl_l_e&v_2.svg")
   ))
```

Prepare data for Submission Table

```{r}
#| label: "prepare-data-final-table"
#| echo: true
#| message: false
#| warning: false

# Step 1: Rename columns in violation_summary2 (except join keys)
violation_summary2 <- violation_summary2 %>%
  rename_with(~ paste0(.x, "_2"), 
              -c(FileName, Population, N, N_numeric))

# Step 2: Merge both datasets on common keys
violation_summary_final <- violation_summary %>%
  left_join(violation_summary2, by = c("FileName", "Population", "N", "N_numeric")) %>%
  mutate(
    Total_Rows = Total_Rows,
    Violation_Rate = Percentage_Violations,  
    Error_Rate = ErrorRate,
    Final_Violation_Rate = Percentage_Violations_2,
    Final_Error_Rate = ErrorRate_2,
    Reps_Needed_for_Success = Replications_Needed,
    Successful_Replications = GoodReplications_2,
    Status = if_else(Successful_Replications >= 500, " Fixed", " Additional Runs Required")
  ) %>%
  select(
    N_numeric, Population, Total_Rows, Violation_Rate, Error_Rate, Reps_Needed_for_Success, 
    Final_Violation_Rate, Final_Error_Rate, Successful_Replications, Status
  ) %>%
arrange(factor(N_numeric, levels = c(500, 1000, 2000, 4000)), Population) %>%
mutate(N_numeric = trimws(as.numeric(N_numeric)))


```

Create flextable Function for Final Table

```{r}
create_flextable <- function(data) {
  
  # Keep only the required columns
  data <- data %>%
    select(
      N_numeric,  
      Population,  
      Total_Rows,
      Violation_Rate,
      Error_Rate,
      Reps_Needed_for_Success,
      Final_Violation_Rate,
      Final_Error_Rate,
      Successful_Replications
    ) %>%
    as.data.frame()  

  # Create the flextable
  ft <- flextable(data) %>%
    set_header_labels(
      N_numeric = "N",
      Population = "T11",  
      Total_Rows = "N Reps",
      Violation_Rate = "V %",
      Error_Rate = "\u03B5 %",  
      Reps_Needed_for_Success = "Reps Needed",
      Final_Violation_Rate = "V %",
      Final_Error_Rate = "\u03B5 %",
      Successful_Replications = "Successful Reps"
    )

  # Apply special formatting to headers
  ft <- compose(ft, part = "header", j = "N_numeric", value = as_paragraph(as_i("N")))
  ft <- compose(ft, part = "header", j = "Population", value = as_paragraph(as_i("T"), as_sub("11")))
  ft <- compose(ft, part = "header", j = "Total_Rows", value = as_paragraph(as_i("N"), "\n", "Reps"))
  ft <- compose(ft, part = "header", j = "Violation_Rate", value = as_paragraph(as_i("V"), "%"))
  ft <- compose(ft, part = "header", j = "Error_Rate", value = as_paragraph("\u03B5", "%"))
  ft <- compose(ft, part = "header", j = "Final_Violation_Rate", value = as_paragraph(as_i("V"), "%"))
  ft <- compose(ft, part = "header", j = "Final_Error_Rate", value = as_paragraph("\u03B5", "%"))
  ft <- compose(ft, part = "header", j = "Reps_Needed_for_Success", value = as_paragraph("Reps", "\n", "Needed"))
  ft <- compose(ft, part = "header", j = "Successful_Replications", value = as_paragraph("Successful", "\n", "Reps"))

  # **Correct vertical centering: Merge "N = _" across 6-row blocks**
  ft <- merge_v(ft, j = "N_numeric")  

  # **Ensure "N = ..." appears only ONCE in the center of the 6-row block**
  ft <- compose(
    ft,
    part = "body",
    j = "N_numeric",
    i = seq(1, nrow(data), by = 6),  #  This controls correct positioning
    value = as_paragraph(
      as_i("N"),  
      " =\u2009",  # THIN SPACE (Unicode U+2009)
      as_character(format(N_numeric, big.mark = ",", scientific = FALSE))  
    )
  )

  # **Fully remove duplicate N values in merged rows**
  ft <- compose(
    ft,
    part = "body",
    j = "N_numeric",
    i = setdiff(1:nrow(data), seq(1, nrow(data), by = 6)),  
    value = as_paragraph("")
  )

  # **Align vertically centered**
  ft <- valign(ft, j = "N_numeric", valign = "center", part = "body")

  # Center all text
  ft <- align(ft, align = "center", part = "all")

  # Set column widths
  ft <- width(ft, j = "N_numeric", width = .9)
  ft <- width(ft, j = "Population", width = 0.6)  
  ft <- width(ft, j = "Total_Rows", width = 0.6) 
  ft <- width(ft, j = "Violation_Rate", width = 0.6)
  ft <- width(ft, j = "Error_Rate", width = 0.4)
  ft <- width(ft, j = "Reps_Needed_for_Success", width = .7)
  ft <- width(ft, j = "Final_Violation_Rate", width = 0.6)
  ft <- width(ft, j = "Final_Error_Rate", width = 0.4)
  ft <- width(ft, j = "Successful_Replications", width = .6)

  # Apply percentage formatting
  ft <- colformat_num(
    ft,
    j = c("Violation_Rate", "Error_Rate", "Final_Violation_Rate", "Final_Error_Rate"),  
    suffix = "%"  
  )
  
ft <- add_header_row(
  ft,
  values = c(" ", "Initial Reps", "Final Reps", " "),
  colwidths = c(2, 3, 3, 1)
)

  # Define a transparent border
  no_border <- fp_border(color = "transparent", width = 0)

  # **Remove ONLY the bottom border under the first three columns (the blank subheader)**
  ft <- hline(ft, i = 1, j = 1:2, border = no_border, part = "header")
  ft <- hline(ft, i = 1, j = 9, border = no_border, part = "header")

  # Autofit table layout
  ft <- set_table_properties(ft, layout = "fixed")

  # Apply font settings
  ft <- font(ft, fontname = "Avenir Next", part = "all")

  # Get total number of rows
total_rows <- nrow(data)

# Create a logical vector marking every 6 rows for coloring
color_rows <- rep(FALSE, total_rows)  
for (i in seq(1, total_rows, by = 12)) {  
  color_rows[i:(i+5)] <- TRUE  #  Color every 6-row block
}

# Apply background color
ft <- bg(ft, i = color_rows, bg = "#f0f0f0", part = "body")

  return(ft)
}

# Generate formatted flextable
violation_summary_final_table <- create_flextable(violation_summary_final)
violation_summary_final_table

```

Save FINAL table

```{r}

invisible(save_as_image(violation_summary_final_table, path = here('Simulations', 'STUDY_1', "2 Time Points", "zErrors", "zl_l_e&v_FINAL.svg")
   ))
```

------------------------------------------------------------------------

# Final Data Preparation

------------------------------------------------------------------------

## Filter Cases with Violations and Errors

*Filter out cases with any violations, leaving only the clean data.*

```{r}
#| label: "delete-cases"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Filter out cases with no violations and no errors
filtered_data_with_no_violations <- final_data_with_actuals[
  final_data_with_actuals$Any_Violation == 0 & final_data_with_actuals$ErrorFlag == 0, ]

# Check the number of remaining rows after filtering
cat("Remaining rows after filtering:", nrow(filtered_data_with_no_violations), "\n")

# Verify if there are any remaining violations or errors
cat("Any remaining violations:", sum(filtered_data_with_no_violations$Any_Violation), "\n")
cat("Any remaining errors:", sum(filtered_data_with_no_violations$ErrorFlag), "\n")

```

------------------------------------------------------------------------

## Calculate Monte Carlo Values via Bootstrapping

*Calculate Monte Carlo values for`TRANS11`, including population values, averages, standard errors, Mean Squared Error (MSE), coverage, power, and dichotomous variables for Power and Coverage,*

```{r}
#| label: "Select-random-sample-replications"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

library(dplyr)
library(purrr)

# 1. Create a function that calculates mc_values from raw replication-level data
calc_mc_values <- function(data) {
  # Step A: Clean and convert columns as needed
  cleaned_data <- data %>%
    mutate(
      Population = as.numeric(as.character(Population)),
      TRANS11 = as.numeric(as.character(TRANS11)),
      SE_11 = as.numeric(as.character(SE_11))
    )
  
  # Step B: Compute group-level summaries (without grouping by Transitions)
  mc_values <- cleaned_data %>%
    group_by(Population, N) %>%
    summarize(
      group_size   = n(),
      average      = round(mean(TRANS11, na.rm = TRUE), 3),
      average_SE   = round(mean(SE_11, na.rm = TRUE), 3),
      population_sd= round(sd(TRANS11, na.rm = TRUE), 3),
      MSE          = round(mean((TRANS11 - Population)^2, na.rm = TRUE), 3),
      Coverage     = round(mean((Population >= (TRANS11 - 1.96 * SE_11)) &
                                  (Population <= (TRANS11 + 1.96 * SE_11)), na.rm = TRUE), 3),
      Power        = round(mean(TRANS11 / SE_11 > 1.96, na.rm = TRUE), 3),
      Reps_Used    = n(),
      .groups = "drop"
    )
  
  # Step C: Merge in Transitions from the raw data (or from an auxiliary table if needed)
  mc_values <- cleaned_data %>%
    select(FileName, Population, N, Transitions) %>%
    distinct() %>%
    right_join(mc_values, by = c("Population", "N"))
  
  # Step D: Calculate bias measures
  mc_values <- mc_values %>%
    mutate(
      Parameter_Bias_boot = round((average - Population) / Population * 100, 2),
      SE_Bias_boot        = round((average_SE - population_sd) / (population_sd + 1e-6) * 100, 2)
    )
  
  # (Optional: add any further transformations or dichotomizations)
  
  return(mc_values)
}

# 2. Create a parallelized bootstrap function that uses the above calculation on bootstrap samples
bootstrap_mc_values <- function(data, n_bootstrap, sample_size) {
  
  # Step A: Detect available cores and create a parallel cluster
  num_cores <- detectCores() - 1  # Use one less than total cores to avoid overloading the system
  cluster_type <- ifelse(.Platform$OS.type == "windows", "PSOCK", "FORK")  # Use FORK for Mac/Linux, PSOCK for Windows
  cl <- makeCluster(num_cores, type = cluster_type)  # Create the cluster
  
  # Step B: Export necessary functions and objects to the cluster workers
  clusterExport(cl, c("calc_mc_values", "sample_n", "%>%", "filtered_data_with_no_violations"))
  clusterEvalQ(cl, { library(dplyr) })  # Ensure each worker loads the required package

  # Step C: Group data by condition variables (Population, N, Transitions)
  grouped_data <- data %>%
    group_by(Population, N, Transitions) %>%
    group_split()  # Split data so each group runs separately in parallel
  
  # Step D: Perform bootstrapping in parallel across worker nodes
  boot_results <- parLapply(cl, grouped_data, function(group_data) {
    map_dfr(1:n_bootstrap, function(i) {
      # Step D1: Draw a bootstrap sample (with replacement) from the replications in this condition
      boot_sample <- group_data %>% sample_n(sample_size, replace = TRUE)
      
      # Step D2: Calculate MC values for the bootstrap sample
      boot_mc <- calc_mc_values(boot_sample)
      
      # Step D3: Add Bootstrap Iteration number
      boot_mc %>% mutate(Bootstrap_Iteration = i)
    })
  }) %>%
    bind_rows()  # Step E: Combine results from all parallel workers into a single dataframe

  # Step F: Stop the parallel cluster to free system resources
  stopCluster(cl)

  # Step G: Return the final bootstrapped MC values
  return(boot_results)
}

# 3. Run the bootstrap procedure on your raw replication-level data
set.seed(07252005)
boot_results <- bootstrap_mc_values(filtered_data_with_no_violations, n_bootstrap = 1000, sample_size = 500)

# 4. Aggregate the bootstrap results to get mean bootstrap estimates per condition:
bootstrap_aggregates <- boot_results %>%
  group_by(Population, N, Transitions) %>%
  summarize(
    Parameter_Bias = mean(Parameter_Bias_boot, na.rm = TRUE),
    SE_Bias       = mean(SE_Bias_boot, na.rm = TRUE),
    .groups = "drop"
  )

# 5. Calculate your original mc_values (using the full replication set) for comparison:
original_mc_values <- calc_mc_values(filtered_data_with_no_violations)

# 6. Merge the bootstrap aggregates back to the original values (if desired)
final_mc_values <- original_mc_values %>%
  left_join(bootstrap_aggregates, by = c("Population", "N", "Transitions")) %>%
  mutate(
    Power_Dic    = ifelse(Power >= 0.8, 1, 0),
    Coverage_Dic = ifelse(Coverage > 0.98 | Coverage < 0.91, 0, 1)
  )

# Save or inspect the results
# Save results
write.csv(final_mc_values, here("Simulations", "STUDY_1", "2 Time Points", "zbootstrapping", "l_l_2t_mc_final_mc_values.csv"), row.names = FALSE)
write.csv(boot_results, here("Simulations", "STUDY_1", "2 Time Points", "zbootstrapping", "l_l_2t_boot_results.csv"), row.names = FALSE)

```

### **Step 11: Compute Monte Carlo (MC) Values**

#### **Objective**

*Calculate Monte Carlo values for`TRANS11`, including population values, averages, standard errors, Mean Squared Error (MSE), coverage, and power.*

```{r}

#| label: "compute-mc-values"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# First, convert Population back to numeric if it's a factor
cleaned_data <- cleaned_data %>%
  mutate(Population = as.numeric(as.character(Population)))

# Calculate the Monte Carlo values, including Mixing_proportion, Model_Type, N, 
# population (transition probability), number of replications, and averages for TRANS11 and SE11
mc_values <- cleaned_data %>%
  group_by(FileName, Population, Mixing_proportion, Model, N, Lambda_values) %>%  # Group by FileName, Population, Mixing_proportion, Model_Type, and N
  summarize(
    average = round(mean(TRANS11, na.rm = TRUE), 3),
    average_SE = round(mean(SE_11, na.rm = TRUE), 3),
    population_sd = round(sd(TRANS11, na.rm = TRUE), 3),
    
    # MSE calculation: mean squared error between TRANS11 and Population
    MSE = round(mean((TRANS11 - Population)^2, na.rm = TRUE), 3),
    
    # Coverage calculation: check if Population lies within the confidence interval
    Coverage = round(mean((Population >= (TRANS11 - 1.96 * SE_11)) & (Population <= (TRANS11 + 1.96 * SE_11)), na.rm = TRUE), 3),
    
    # Power calculation: proportion of cases where TRANS11 is significant
    Power = round(mean(TRANS11 / SE_11 > 1.96, na.rm = TRUE), 3),
    
    # Reps_Used counts the number of replications (rows) used for each FileName
    Reps_Used = n()
  )

# Round the values to 3 decimal points
mc_values <- mc_values %>%
  mutate(across(starts_with("Avg_"), ~ round(.x, 3)))

```

------------------------------------------------------------------------

## Prepare Data for Visualization

### Subset Data for Bias Plots

*Subset the Monte Carlo data into mover transition probabilities (.2) and stayer transition probabilities (.8) based on population values*

```{r}
#| label: "calculate-bias-dichotomous-variables"
#| echo: true
#| message: true
#| warning: true
#| code-fold: true

# Step 1: Calculate dichotomous variable for Power (1 if Power >= 0.8, else 0)
mc_values <- mc_values %>%
  mutate(Power_Dic = ifelse(Power >= 0.8, 1, 0))

# Step 2: Calculate dichotomous variable for Coverage (0 if outside [0.91, 0.98], else 1)
mc_values <- mc_values %>%
  mutate(Coverage_Dic = ifelse(Coverage > 0.98 | Coverage < 0.91, 0, 1))

# Step 3: Remove any groupings before further calculations
mc_values <- mc_values %>%
  ungroup()

# Step 4: Ensure numeric columns are correctly formatted
mc_values <- mc_values %>%
  mutate(
    average = as.numeric(average),
    Population = as.numeric(Population),  # Ensure 'Population' is numeric
    average_se = as.numeric(average_SE),
    population_sd = as.numeric(population_sd)
  )

# Step 5: Calculate Parameter Bias and SE Bias, rounding the results to 2 decimal places
mc_values <- mc_values %>%
  mutate(
    Parameter_Bias = (average - Population) / Population * 100,  # Bias for the parameter
    SE_Bias = (average_se - population_sd) / population_sd * 100  # Bias for the standard error
  ) %>%
  mutate(across(c(Parameter_Bias, SE_Bias), ~ round(.x, 2)))  # Round to 2 decimal places

```

------------------------------------------------------------------------

## Prepare Data for Visualization

### Subset Data for Bias Plots

*Subset the Monte Carlo data into mover transition probabilities (.2) and stayer transition probabilities (.8) based on population values*

```{r}

#| label: "subset-data-for-movers-stayers"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Subset for Even Mixing Proportion (use the actual factor labels)
subset_even <- subset(mc_values, Mixing_proportion == "Even Proportions")
# Subset for Uneven Mixing Proportion
subset_uneven <- subset(mc_values, Mixing_proportion == "Uneven Proportions")


# Subset for Population 0.2 Even Mixing Proportion
subset_0.2_EVEN <- subset(subset_even, Population == 0.2)
# Subset for Population 0.2 Uneven Mixing Proportion
subset_0.2_UNEVEN <- subset(subset_uneven, Population == 0.2)
# Subset for Population 0.8 Even Mixing Proportion
subset_0.8_EVEN <- subset(subset_even, Population == 0.8)  # Change to 0.8_EVEN
# Subset for Population 0.8 Uneven Mixing Proportion
subset_0.8_UNEVEN <- subset(subset_uneven, Population == 0.8)  # Change to 0.8_UNEVEN

```

### Prepare Function for Bias Plots

```{r}

#| label: "create-plots"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true


generate_plot <- function(data, title, y_limits) {

  # Common theme for the plots
  common_theme <- theme_minimal() +
    theme(
      panel.grid.major.x = element_blank(),
      panel.grid.minor.x = element_blank(),
      panel.grid.minor.y = element_blank(),
      axis.text.x = element_text(size = 6),
      axis.ticks = element_line(color = "black", size = 0.2),
      legend.position = "bottom",
      legend.title = element_blank(),
      text = element_text(family = "Times New Roman"),
      axis.title.x = element_text(margin = margin(t = 10, b = 10)),
      legend.margin = margin(t = -10),
      plot.caption = element_text(hjust = 0, margin = margin(t = 10))
    )

  # Identify which legends are present in the data
  present_categories <- c("Parameter Bias", "Standard Error Bias")
  if (any(data$Coverage_Dic == 0)) present_categories <- c(present_categories, "Coverage Failure")
  if (any(data$Power_Dic == 0)) present_categories <- c(present_categories, "Power Failure")

  # Define the corresponding colors and shapes based on the present categories
  colors <- c("Parameter Bias" = "#7030A0", "Standard Error Bias" = "#C830CC", 
              "Coverage Failure" = "#7030A0", "Power Failure" = "black")

  shapes <- c("Parameter Bias" = 16, "Standard Error Bias" = 18, 
              "Coverage Failure" = 1, "Power Failure" = 4)

  # Filter the colors and shapes based on present categories
  filtered_colors <- colors[present_categories]
  filtered_shapes <- shapes[present_categories]

  # Plotting the data
  ggplot(data = data, aes(x = factor(Lambda_values))) +  
    geom_line(aes(y = Parameter_Bias, color = "Parameter Bias", group = 1), size = 0.3, linetype = "solid") +  
    geom_line(aes(y = SE_Bias, color = "Standard Error Bias", group = 1), size = 0.3, linetype = "solid") +  
    geom_point(aes(y = Parameter_Bias, color = "Parameter Bias"), shape = 16, size = 1, fill = "#7030A0", alpha = 0.8) +  
    geom_point(aes(y = SE_Bias, color = "Standard Error Bias"), shape = 18, size = 1, fill = "#C830CC", alpha = 0.8) +  
    geom_point(data = subset(data, Coverage_Dic == 0), aes(y = Parameter_Bias, color = "Coverage Failure"), shape = 1, size = 2, fill = "#7030A0", alpha = 1) +  
    geom_point(data = subset(data, Power_Dic == 0), aes(y = Parameter_Bias, color = "Power Failure"), shape = 4, size = 2, fill = "black", alpha = 1) + 
    scale_color_manual(
      values = filtered_colors, 
      labels = present_categories, 
      breaks = present_categories,
      guide = guide_legend(
        override.aes = list(
          shape = filtered_shapes
        )
      )
    ) + 
    labs(
      x = "Lambda Loadings on the RI",
      y = "Bias (%)",
      color = "",
      title = title
    ) +
    coord_cartesian(ylim = y_limits) +  
    facet_grid(factor(Model) ~ N, scales = "free_x") + 
    scale_x_discrete(name = "Lambda Loadings on the RI") +  # Set x-axis title
    scale_y_continuous(breaks = seq(min(y_limits), max(y_limits), by = 20)) +  
    common_theme +
    geom_hline(yintercept = c(-10, 10), linetype = "dashed", color = "#7030A0", size = 0.3) +  
    geom_hline(yintercept = c(-5, 5), linetype = "dashed", color = "#C830CC", size = 0.3) +
    theme(strip.text.y = element_text(size = 8))  # Adjust the size of row titles
}

```

### Render Bias Figures

```{r}
plot_0.2even <- generate_plot(subset_0.2_EVEN, "Even Mixing Proportion with .200 Transition Probabilities", c(-40, 200))
print(plot_0.2even)
```

```{r}
plot_0.2uneven <- generate_plot(subset_0.2_UNEVEN, "Uneven Mixing Proportion with .200 Transition Probabilities", c(-40, 80))
plot_0.2uneven <- generate_plot(subset_0.2_UNEVEN, "Uneven Mixing Proportion with .200 Transition Probabilities", c(-40, 80))
```

```{r}
plot_0.8even <- generate_plot(subset_0.8_EVEN, "Even Mixing Proportion with .800 Transition Probabilities", c(-40, 40))
print(plot_0.8even)
```

```{r}
plot_0.8uneven <- generate_plot(subset_0.8_UNEVEN, "Uneven Mixing Proportion with .800 Transition Probabilities", c(-40, 40))
print(plot_0.8uneven)
```

------------------------------------------------------------------------

### **Prepare Data for Heat Maps**

*Prepare data for heat map creation by ensuring correct formatting for population values, and subsetting the data based on class proportions and sample sizes.*

```{r}
#| label: "prepare-data-for-heatmaps"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true


# Mutate columns to factor with custom labels
all_data <- mc_values %>%
  mutate(Population = factor(Population, 
                             levels = c(0.2, 0.8),  # Define the numeric levels
                             labels = c(".200", ".800")))  # Assign the custom labels

all_data$Population <- as.numeric(as.character(all_data$Population))


rownames(all_data) <- NULL

# Ensure Population is numeric and fix Mixing_proportion labels
subset_0.2_Even <- subset(all_data, as.numeric(Population) == .200 & Mixing_proportion == "Even Proportions")

subset_0.2_uneven <- subset(all_data, as.numeric(Population) == .200 & Mixing_proportion == "Uneven Proportions")

subset_0.8_Even <- subset(all_data, as.numeric(Population) == .800 & Mixing_proportion == "Even Proportions")

subset_0.8_uneven <- subset(all_data, as.numeric(Population) == .800 & Mixing_proportion == "Uneven Proportions")


# Correct filtering using explicit factor matching
subset_0.2_Even_Model_1 <- subset_0.2_Even %>%
  filter(as.character(Model) == "Model 1")

subset_0.2_Even_Model_2 <- subset_0.2_Even %>%
  filter(as.character(Model) == "Model 2")

subset_0.2_Even_Model_3 <- subset_0.2_Even %>%
  filter(as.character(Model) == "Model 3")

subset_0.2_uneven_Model_1 <- subset_0.2_uneven %>%
  filter(as.character(Model) == "Model 1")

subset_0.2_uneven_Model_2 <- subset_0.2_uneven %>%
  filter(as.character(Model) == "Model 2")

subset_0.2_uneven_Model_3 <- subset_0.2_uneven %>%
  filter(as.character(Model) == "Model 3")

subset_0.8_Even_Model_1 <- subset_0.8_Even %>%
  filter(as.character(Model) == "Model 1")

subset_0.8_Even_Model_2 <- subset_0.8_Even %>%
  filter(as.character(Model) == "Model 2")

subset_0.8_Even_Model_3 <- subset_0.8_Even %>%
  filter(as.character(Model) == "Model 3")

subset_0.8_uneven_Model_1 <- subset_0.8_uneven %>%
  filter(as.character(Model) == "Model 1")

subset_0.8_uneven_Model_2 <- subset_0.8_uneven %>%
  filter(as.character(Model) == "Model 2")

subset_0.8_uneven_Model_3 <- subset_0.8_uneven %>%
  filter(as.character(Model) == "Model 3")



subset_0.2_Even_Model_1 <- subset_0.2_Even_Model_1 %>%
  select(Lambda_values, average, Coverage, Power, Parameter_Bias, SE_Bias)

subset_0.2_Even_Model_2 <- subset_0.2_Even_Model_2 %>%
  select(Lambda_values, average, Coverage, Power, Parameter_Bias, SE_Bias)

subset_0.2_Even_Model_3 <- subset_0.2_Even_Model_3 %>%
  select(Lambda_values, average, Coverage, Power, Parameter_Bias, SE_Bias)

subset_0.2_uneven_Model_1 <- subset_0.2_uneven_Model_1 %>%
  select(Lambda_values, average, Coverage, Power, Parameter_Bias, SE_Bias)

subset_0.2_uneven_Model_2 <- subset_0.2_uneven_Model_2 %>%
  select(Lambda_values, average, Coverage, Power, Parameter_Bias, SE_Bias)

subset_0.2_uneven_Model_3 <- subset_0.2_uneven_Model_3 %>%
  select(Lambda_values, average, Coverage, Power, Parameter_Bias, SE_Bias)

subset_0.8_Even_Model_1 <- subset_0.8_Even_Model_1 %>%
  select(Lambda_values, average, Coverage, Power, Parameter_Bias, SE_Bias)

subset_0.8_Even_Model_2 <- subset_0.8_Even_Model_2 %>%
  select(Lambda_values, average, Coverage, Power, Parameter_Bias, SE_Bias)

subset_0.8_Even_Model_3 <- subset_0.8_Even_Model_3 %>%
  select(Lambda_values, average, Coverage, Power, Parameter_Bias, SE_Bias)

subset_0.8_uneven_Model_1 <- subset_0.8_uneven_Model_1 %>%
  select(Lambda_values, average, Coverage, Power, Parameter_Bias, SE_Bias)

subset_0.8_uneven_Model_2 <- subset_0.8_uneven_Model_2 %>%
  select(Lambda_values, average, Coverage, Power, Parameter_Bias, SE_Bias)

subset_0.8_uneven_Model_3 <- subset_0.8_uneven_Model_3 %>%
  select(Lambda_values, average, Coverage, Power, Parameter_Bias, SE_Bias)

# Store subsets in a list with new names
new_subset_list <- list(
  subset_0.2_Even_Model_1 = subset_0.2_Even_Model_1,
  subset_0.2_Even_Model_2 = subset_0.2_Even_Model_2,
  subset_0.2_Even_Model_3 = subset_0.2_Even_Model_3,
  subset_0.2_uneven_Model_1 = subset_0.2_uneven_Model_1,
  subset_0.2_uneven_Model_2 = subset_0.2_uneven_Model_2,
  subset_0.2_uneven_Model_3 = subset_0.2_uneven_Model_3,
  subset_0.8_Even_Model_1 = subset_0.8_Even_Model_1,
  subset_0.8_Even_Model_2 = subset_0.8_Even_Model_2,
  subset_0.8_Even_Model_3 = subset_0.8_Even_Model_3,
  subset_0.8_uneven_Model_1 = subset_0.8_uneven_Model_1,
  subset_0.8_uneven_Model_2 = subset_0.8_uneven_Model_2,
  subset_0.8_uneven_Model_3 = subset_0.8_uneven_Model_3
)


```

### Prepare Function for Heat Map Creation

```{r}
#| label: "heatmap-creation"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true


create_table <- function(subset, transition_probability) {
  
  gt_table <- subset %>%
    gt() %>%
    opt_table_font(stack = "geometric-humanist") %>% 
    tab_header(
      title = paste("RILTA Generated & LTA Analyzed with Transition Probability of", transition_probability)
    ) %>%
    cols_label(
      Lambda_values = "Lambda",
      average = "Estimated Probability",
      Coverage = "Coverage",
      Power = "Power",
      Parameter_Bias = "Parameter Bias",
      SE_Bias = "Standard Error Bias"
    ) %>%
    tab_spanner(label = "Bias", columns = c("Parameter_Bias", "SE_Bias")) %>%
    tab_row_group(label = "N = 5000", rows = 25:32) %>%
    tab_row_group(label = "N = 2500", rows = 17:24) %>%
    tab_row_group(label = "N = 1000", rows = 9:16) %>%
    tab_row_group(label = "N = 500", rows = 1:8) %>%
    tab_style(style = cell_text(font = "bold italic"), locations = cells_row_groups()) %>%
    fmt_number(columns = c("Parameter_Bias", "SE_Bias"), decimals = 2) %>%
    #fmt_number(columns = 4, decimals = 3) %>%
     #   cols_width(
     # Lambda_values ~ px(65),  # Adjust as needed for compactness
    #  average ~ px(90),
    #  Coverage ~ px(80),
    #  Power ~ px(80),
    #  Parameter_Bias ~ px(80),
    #  SE_Bias ~ px(90)
    #) %>%
    tab_options(
      table.border.top.color = "black",
      table.border.bottom.color = "black",
      table_body.border.bottom.color = "black",
      heading.border.bottom.color = "black",
      column_labels.border.top.color = "black",
      column_labels.border.bottom.color = "black",
      row_group.border.bottom.color = "black",
      row_group.border.top.color = "black"
    ) %>%
    cols_align(align = c("center"), columns = everything())

  # Apply color highlighting for violations in Parameter Bias
  if (any(!(subset$Parameter_Bias >= -9.99 & subset$Parameter_Bias <= 9.99), na.rm = TRUE)) {
    gt_table <- gt_table %>%
      data_color(
        columns = "Parameter_Bias",
        rows = .data$Parameter_Bias < -9.99 | .data$Parameter_Bias > 9.99,  # Apply color only if outside the threshold
        method = "numeric",
        palette = c("#113386", "#DAE3FA", "#113386"),  # Darker blue for larger deviations
        domain = c(-40, 40)  # Adjust the domain to reflect the range of values
      ) %>%
      tab_footnote(
        footnote = md("Darker blue indicates larger deviations from zero *Parameter Bias* beyond the 9.99 threshold."),
        locations = cells_column_labels(columns = "Parameter_Bias")
      )
  }

  # Apply color highlighting for violations in SE Bias
  if (any(!(subset$SE_Bias >= -4.99 & subset$SE_Bias <= 4.99), na.rm = TRUE)) {
    gt_table <- gt_table %>%
      data_color(
        columns = "SE_Bias",
        rows = .data$SE_Bias < -4.99 | .data$SE_Bias > 4.99,  # Apply color only if outside the threshold
        method = "numeric",
        palette = c("#B4186E", "#F9D5E9", "#B4186E"),  # Darker red for larger deviations
        domain = c(-80, 80)  # Adjust the domain for the SE_Bias range
      ) %>%
      tab_footnote(
        footnote = md("Darker red indicates larger deviations from zero *Standard Error Bias* beyond the 4.99 threshold."),
        locations = cells_column_labels(columns = "SE_Bias")
      )
  }

  if (any(subset$Coverage < 0.93 | subset$Coverage > 0.979, na.rm = TRUE)) {
    gt_table <- gt_table %>%
      data_color(
        columns = "Coverage",
        rows = subset$Coverage < 0.93 | subset$Coverage > 0.979,
        method = "numeric",
        palette = c("#93C6B1", "white"),  # Green for coverage issues
        domain = c(0, 1)
      ) %>%
      tab_footnote(
        footnote = md("Green indicates failure to achieve adequate *Coverage*."),
        locations = cells_column_labels(columns = "Coverage")
      )
  }

  if (any(subset$Power < 0.8, na.rm = TRUE)) {
    gt_table <- gt_table %>%
      data_color(
        columns = "Power",
        rows = subset$Power < 0.8,
        method = "numeric",
        palette = c("#502CD1", "white"),  # Purple for power issues
        domain = c(0, 1)
      ) %>%
      tab_footnote(
        footnote = md("Purple indicates failure to achieve adequate *Power*."),
        locations = cells_column_labels(columns = "Power")
      )
  }
  
  return(gt_table)
}


```

### Render Heat maps

```{r}

#| label: "heatmap-0.2-even-model1"
#| echo: true
#| message: true
#| warning: true

# Heatmap for .200, Even Mixing Proportion, Model 2
subset_0.2_Even_Model_1_table <- create_table(subset_0.2_Even_Model_1, ".200, Even Mixing Proportion, Model 2")
subset_0.2_Even_Model_1_table |> gtsave(here('Simulations', 'STUDY_2','ZHeatmaps', 'z2t_rilta_lta_tables', "2T_L_R_.200_Even_Model_1.png"), expand = 8)
knitr::include_graphics(here('Simulations', 'STUDY_2', 'zHeatmaps', 'z2t_rilta_lta_tables', "2T_L_R_.200_Even_Model_1.png"))

```

```{r}
#| label: "heatmap-0.2-even-model2"
#| echo: true
#| message: true
#| warning: true

# Heatmap for .200, Even Mixing Proportion, Model 2
subset_0.2_Even_Model_2_table <- create_table(subset_0.2_Even_Model_2, ".200, Even Mixing Proportion, Model 2")
subset_0.2_Even_Model_2_table |> gtsave(here('Simulations', 'STUDY_2', 'zHeatmaps', 'z2t_rilta_lta_tables', "2T_L_R_.200_Even_Model_2.png"), expand = 8)
knitr::include_graphics(here('Simulations', 'STUDY_2', 'zHeatmaps', 'z2t_rilta_lta_tables', "2T_L_R_.200_Even_Model_2.png"))

```

```{r}
#| label: "heatmap-0.2-even-model3"
#| echo: true
#| message: false
#| warning: false

# Heatmap for .200, Even Mixing Proportion, Model 3
subset_0.2_Even_Model_3_table <- create_table(subset_0.2_Even_Model_3, ".200, Even Mixing Proportion, Model 3")
subset_0.2_Even_Model_3_table |> gtsave(here('Simulations', 'STUDY_2', 'zHeatmaps', 'z2t_rilta_lta_tables', "2T_L_R_.200_Even_Model_3.png"), expand = 8)
knitr::include_graphics(here('Simulations', 'STUDY_2', 'zHeatmaps', 'z2t_rilta_lta_tables', "2T_L_R_.200_Even_Model_3.png"))

```

```{r}
#| label: "heatmap-0.2-uneven-model1"
#| echo: true
#| message: false
#| warning: false

# Heatmap for .200, Uneven Mixing Proportion, Model 1
subset_0.2_uneven_Model_1_table <- create_table(subset_0.2_uneven_Model_1, ".200, Uneven Mixing Proportion, Model 1")
subset_0.2_uneven_Model_1_table |> gtsave(here('Simulations', 'STUDY_2', 'zHeatmaps', 'z2t_rilta_lta_tables', "2T_L_R_.200_Uneven_Model_1.png"), expand = 8)
knitr::include_graphics(here('Simulations', 'STUDY_2', 'zHeatmaps', 'z2t_rilta_lta_tables', "2T_L_R_.200_Uneven_Model_1.png"))

```

```{r}
#| label: "heatmap-0.2-uneven-model2"
#| echo: true
#| message: false
#| warning: false

# Heatmap for .200, Uneven Mixing Proportion, Model 2
subset_0.2_uneven_Model_2_table <- create_table(subset_0.2_uneven_Model_2, ".200, Uneven Mixing Proportion, Model 2")
subset_0.2_uneven_Model_2_table |> gtsave(here('Simulations', 'STUDY_2', 'zHeatmaps', 'z2t_rilta_lta_tables', "2T_L_R_.200_Uneven_Model_2.png"), expand = 8)
knitr::include_graphics(here('Simulations', 'STUDY_2', 'zHeatmaps', 'z2t_rilta_lta_tables', "2T_L_R_.200_Uneven_Model_2.png"))

```

```{r}
#| label: "heatmap-0.2-uneven-model3"
#| echo: true
#| message: false
#| warning: false

# Heatmap for .200, Uneven Mixing Proportion, Model 3
subset_0.2_uneven_Model_3_table <- create_table(subset_0.2_uneven_Model_3, ".200, Uneven Mixing Proportion, Model 3")
subset_0.2_uneven_Model_3_table |> gtsave(here('Simulations', 'STUDY_2', 'zHeatmaps', 'z2t_rilta_lta_tables', "2T_L_R_.200_Uneven_Model_3.png"), expand = 8)
knitr::include_graphics(here('Simulations', 'STUDY_2', 'zHeatmaps', 'z2t_rilta_lta_tables', "2T_L_R_.200_Uneven_Model_3.png"))

```

```{r}
#| label: "heatmap-0.8-even-model1"
#| echo: true
#| message: false
#| warning: false

# Heatmap for .800, Even Mixing Proportion, Model 1
subset_0.8_Even_Model_1_table <- create_table(subset_0.8_Even_Model_1, ".800, Even Mixing Proportion, Model 1")
subset_0.8_Even_Model_1_table |> gtsave(here('Simulations', 'STUDY_2', 'zHeatmaps', 'z2t_rilta_lta_tables', "2T_L_R_.800_Even_Model_1.png"), expand = 8)
knitr::include_graphics(here('Simulations', 'STUDY_2', 'zHeatmaps', 'z2t_rilta_lta_tables', "2T_L_R_.800_Even_Model_1.png"))

```

```{r}
#| label: "heatmap-0.8-even-model2"
#| echo: true
#| message: false
#| warning: false

# Heatmap for .800, Even Mixing Proportion, Model 2
subset_0.8_Even_Model_2_table <- create_table(subset_0.8_Even_Model_2, ".800, Even Mixing Proportion, Model 2")
subset_0.8_Even_Model_2_table |> gtsave(here('Simulations', 'STUDY_2', 'zHeatmaps', 'z2t_rilta_lta_tables', "2T_L_R_.800_Even_Model_2.png"), expand = 8)
knitr::include_graphics(here('Simulations', 'STUDY_2', 'zHeatmaps', 'z2t_rilta_lta_tables', "2T_L_R_.800_Even_Model_2.png"))

```

```{r}
#| label: "heatmap-0.8-even-model3"
#| echo: true
#| message: false
#| warning: false

# Heatmap for .800, Even Mixing Proportion, Model 3
subset_0.8_Even_Model_3_table <- create_table(subset_0.8_Even_Model_3, ".800, Even Mixing Proportion, Model 3")
subset_0.8_Even_Model_3_table |> gtsave(here('Simulations', 'STUDY_2', 'zHeatmaps', 'z2t_rilta_lta_tables', "2T_L_R_.800_Even_Model_3.png"), expand = 8)
knitr::include_graphics(here('Simulations', 'STUDY_2', 'zHeatmaps', 'z2t_rilta_lta_tables', "2T_L_R_.800_Even_Model_3.png"))

```

```{r}
#| label: "heatmap-0.8-uneven-model1"
#| echo: true
#| message: false
#| warning: false

# Heatmap for .800, Uneven Mixing Proportion, Model 1
subset_0.8_uneven_Model_1_table <- create_table(subset_0.8_uneven_Model_1, ".800, Uneven Mixing Proportion, Model 1")
subset_0.8_uneven_Model_1_table |> gtsave(here('Simulations', 'STUDY_2', 'zHeatmaps', 'z2t_rilta_lta_tables', "2T_L_R_.800_Uneven_Model_1.png"), expand = 8)
knitr::include_graphics(here('Simulations', 'STUDY_2', 'zHeatmaps', 'z2t_rilta_lta_tables', "2T_L_R_.800_Uneven_Model_1.png"))

```

```{r}
#| label: "heatmap-0.8-uneven-model2"
#| echo: true
#| message: false
#| warning: false

# Heatmap for .800, Uneven Mixing Proportion, Model 2
subset_0.8_uneven_Model_2_table <- create_table(subset_0.8_uneven_Model_2, ".800, Uneven Mixing Proportion, Model 2")
subset_0.8_uneven_Model_2_table |> gtsave(here('Simulations', 'STUDY_2', 'zHeatmaps', 'z2t_rilta_lta_tables', "2T_L_R_.800_Uneven_Model_2.png"), expand = 8)
knitr::include_graphics(here('Simulations', 'STUDY_2', 'zHeatmaps', 'z2t_rilta_lta_tables', "2T_L_R_.800_Uneven_Model_2.png"))

```

```{r}
#| label: "heatmap-0.8-uneven-model3"
#| echo: true
#| message: false
#| warning: false

# Heatmap for .800, Uneven Mixing Proportion, Model 3
subset_0.8_uneven_Model_3_table <- create_table(subset_0.8_uneven_Model_3, ".800, Uneven Mixing Proportion, Model 3")
subset_0.8_uneven_Model_3_table |> gtsave(here('Simulations', 'STUDY_2', 'Zheatmaps', 'z2t_rilta_lta_tables', "2T_L_R_.800_Uneven_Model_3.png"), expand = 8)
knitr::include_graphics(here('Simulations', 'STUDY_2', 'ZHeatmaps', 'z2t_rilta_lta_tables', "2T_L_R_.800_Uneven_Model_3.png"))

```
