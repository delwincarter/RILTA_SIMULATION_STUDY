---
title: "Final Study (k = 3) LTA Generated, LTA Analyzed: Two Timepoints"
format:
  html:
    code-fold: true
editor: visual
author: "Delwin Carter"
page-layout: full
fig-format: svg
knitr:
  opts_chunk:
    out.width: "90%"
    fig.align: center
---

```{r, message=FALSE, warning=FALSE}
#| label: "load-libraries"
#| echo: true
#| message: false
#| warning: false
# Load necessary libraries
#knitr::opts_chunk$set(echo = TRUE, eval = TRUE, warning = FALSE, message = FALSE)
library(tidyverse)
library(glue)
library(MplusAutomation)
library(here)
library(gt)
library(janitor)
library(ggplot2)
library(parallel)
library(tools)


```

# RILTA Generated, LTA Analyzed

## Introduction

In this section, we will simulate three models by generating them as Random Intercepts Latent Transition Models and analyze them as a Latent Transition Models.

![](images/RILTA_LTA.png){width="350"}

## Model 1:

Sample Size: N = 500, 1000, 2500, 5000

Transition logit (Probability): TPs = 3.179 (Stayer), 0.407 (Mover)

![](images/clipboard-2891141057.png){width="352"}

RI Loadings: lambda = .3, .5, .7, 9

![](images/clipboard-2109977150.png){width="554"}

Thresholds= Model 1

![](images/clipboard-3674477926.png){width="344"}

**Class Prevalence: Equal v. Unequal 1 = .33.3, .33.3, 33.3 ; 2 = .60, .30, .10**

#### Conditions Matrix for Model 1 - Model 3

```{r}
#| label: "simulation-conditions-1"
#| echo: true
#| message: false
#| warning: false

# Define the simulation conditions
p1 <- expand.grid(N = c(500, 1000, 2500, 5000),
TPs = c(3.179, 0.407),
lambda = c(.3, .5, .7, .9), 
mix = c(1, 2))
       
# Display the matrix using gt
p1 %>%
  gt() %>%
  tab_header(
    title = "Simulation Conditions Matrix",
    subtitle = "Combinations of Sample Sizes, Transition Probabilities, Lambdas, and Mixing Propotions"
  ) %>%
  cols_align(
    align = "center",
    columns = everything() # Centers all columns
  )

```

#### Simulation SetupÂ 

We will now run a Monte Carlo simulation for Model 2. The simulation will iterate over different combinations of sample sizes, transition probabilities, lamdas, and mixing proportion components. The following code sets up the cluster for parallel processing and defines the function to run the simulation.

```{r,eval = FALSE}
#| label: "rilta-lta-simulation-Model 1"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true


# Step 1: Create the cluster (use PSOCK for Windows)
num_cores <- detectCores() - 1  # Detect number of cores
cl <- makeCluster(num_cores, type = "PSOCK")    # Create the cluster with PSOCK

# Step 2: Define the function for the simulation
rilta_lta_func <- function(N, TPs, mix, lambda) {
  
  # Step 2.1: Construct the MODELPOPULATION argument based on the value of 'mix'
  MODELPOPULATION <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      
       f by u11-u15*{lambda} (p1-p5)
            u21-u25*{lambda} (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
    
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;

       f by u11-u15*{lambda} (p1-p5)
            u21-u25*{lambda} (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  }

  # Step 2.2: Construct the MODEL argument based on the value of 'mix'
  MODEL <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2: 	
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
    
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2: 	
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  }

  # Step 2.3: Construct the MODELCONSTRAINT argument based on the value of 'TPs'
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);

      
    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
      
    ")
  }

  # Step 3: Construct the Mplus object
  RILTA_LTA <- mplusObject(
    TITLE = glue("RILTA_LTA_M1_N_{N}_TP_{TPs}_M_{mix}_L_{lambda}"),
    MONTECARLO = glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N};
      SEED = 07252005;
      NREPS = 500;
      !SAVE = repM1*.dat;
      RESULTS = RILTA_LTA_M1_N_{N}_TP_{TPs}_M_{mix}_L_{lambda}.csv;"),
    
    
    ANALYSIS = "TYPE = MIXTURE;
      algorithm = integration;
      STARTS = 50 10;
      processors = 24;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Step 4: Run Mplus model
  RILTA_LTA_Model <- mplusModeler(
    RILTA_LTA, 
    dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', glue("RILTA_LTA_M1_N_{N}_TP_{TPs}_M_{mix}_L_{lambda}.dat")),
    modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', "RILTA_LTA_M1_N_{N}_TP_{TPs}_M_{mix}_L_{lambda}.inp")),
    check = TRUE, run = TRUE, hashfilename = FALSE
  )
  return(RILTA_LTA_Model)
}

# Step 5: Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func", "p1")))

# Ensure that the packages are loaded on each cluster node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

# Step 6: Run the simulation in parallel using the cluster
result_list <- parLapply(cl, 1:nrow(p1), function(i) {
  rilta_lta_func(p1$N[i], p1$TPs[i], p1$mix[i], p1$lambda[i])
})

stopCluster(cl)
```

## Model 2

### Conditions:

Sample Size: N = 500, 1000, 2500, 5000

Transition logit (Probability): TPs = 3.179 (Stayer), 0.407 (Mover)

![](images/clipboard-2891141057.png){width="352"}

RI Loadings: lambda = .3, .5, .7. 9

![](images/clipboard-2109977150.png){width="476"}

Thresholds= Example 2

![](images/clipboard-3697136395.png){width="285"}

**Class Prevalence: Equal v. Unequal 1 = .33.3, .33.3, 33.3 ; 2 = .60, .30, .10**

We will now run a Monte Carlo simulation for Model 2. This simulation will iterate over different combinations of sample sizes, transition probabilities, and mixture components using the logits form the probability plot of Model 2. The following code sets up the cluster for parallel processing and defines the function to run the simulation.

```{r, eval = FALSE}

#| label: "rilta-lta-simulation-Model 2"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true
# Step 1: Create the cluster (use PSOCK for Windows)
num_cores <- detectCores() - 1  # Detect number of cores
cl <- makeCluster(num_cores, type = "PSOCK")    # Create the cluster with PSOCK



rilta_lta_func2 <- function(N, TPs, mix, lambda) {
  
    # Construct the MODELPOPULATION argument based on the value of mix
  MODELPOPULATION <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
       
       f by u11-u15*{lambda} (p1-p5)
            u21-u25*{lambda} (p1-p5);
        f@1;
        [f@0];
        
        MODEL POPULATION-c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
       ")
    
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      
       f by u11-u15*{lambda} (p1-p5)
            u21-u25*{lambda} (p1-p5);
        f@1;
        [f@0];
        
     MODEL POPULATION-c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
       ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

     MODEL c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
	      ")      
      
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	      

     MODEL c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
	      ")      
  }
  
  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      

      
    ")
  }
  
  RILTA_LTA2 <- mplusObject(
    TITLE = glue("Generate RILTA_LTA_M2_N_{N}_TP_{TPs}_M_{mix}_L_{lambda}"),

    MONTECARLO =
      glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N};
      SEED = 07252005;
      NREPS = 500;
      !SAVE = repM2*.dat;
      RESULTS = RILTA_LTA_M2_N_{N}_TP_{TPs}_M_{mix}_L_{lambda}.csv;"),
    
    
    ANALYSIS = "TYPE = MIXTURE;
      algorithm = integration;
      STARTS = 50 10;
      processors = 24;
      logcriterion=0.00001;
      mconv=0.00001;",

    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_LTA_Model2<- mplusModeler(RILTA_LTA2, 
                                   dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', glue("RILTA_LTA_M2_N_{N}_TP_{TPs}_M_{mix}_L_{lambda}.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', "RILTA_LTA_M2_N_{N}_TP_{TPs}_M_{mix}_L_{lambda}.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_LTA_Model2)
}

# Step 3: Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func2", "p1")))

# Ensure that the packages are loaded on each cluster node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))



result_list <- parLapply(cl, 1:nrow(p1), function(i) {
  rilta_lta_func2(p1$N[i], p1$TPs[i], p1$mix[i], p1$lambda[i])
})

stopCluster(cl)
```

## Model 3

### Conditions:

Sample Size: N = 500, 1000, 2500, 5000

Transition logit (Probability): TPs = 3.179 (Stayer), 0.407 (Mover)

![](images/clipboard-2891141057.png){width="352"}

RI Loadings: lambda = .3, .5, .7, .9

![](images/clipboard-2109977150.png){width="495" height="175"}

Thresholds= Example 3

![](images/clipboard-2467009665.png){width="347"}

**Class Prevalence: Equal v. Unequal 1 = .33.3, .33.3, 33.3 ; 2 = .60, .30, .10**

We will now run a Monte Carlo simulation for Model 3. This simulation will iterate over different combinations of sample sizes, transition probabilities, and mixture components using the logits form the probability plot for Model 3. The following code sets up the cluster for parallel processing and defines the function to run the simulation.

```{r, eval = FALSE}

#| label: "rilta-lta-simulation-Model 3"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Step 1: Create the cluster (use PSOCK for Windows)
num_cores <- detectCores() - 1  # Detect number of cores
cl <- makeCluster(num_cores, type = "PSOCK")    # Create the cluster with PSOCK

rilta_lta_func3 <- function(N, TPs, mix, lambda) {
  
    # Construct the MODELPOPULATION argument based on the value of mix
  MODELPOPULATION <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11-u15*{lambda} (p1-p5)
            u21-u25*{lambda} (p1-p5);
        f@1;
        [f@0];
          
        MODEL POPULATION-c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
       ")
    
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11-u15*{lambda} (p1-p5)
            u21-u25*{lambda} (p1-p5);
        f@1;
        [f@0];
              
     MODEL POPULATION-c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
       ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

     MODEL c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
	      ")      
      
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	      

     MODEL c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
	      ")      
  }
    
  
  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  }
  
  RILTA_LTA3 <- mplusObject(
    TITLE = glue("Generate RILTA_LTA_M3_N_{N}_TP_{TPs}_M_{mix}_L_{lambda}"),

    MONTECARLO =
      glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N};
      SEED = 07252005;
      NREPS = 500;
      !SAVE = repM3*.dat;
      RESULTS = RILTA_LTA_M3_N_{N}_TP_{TPs}_M_{mix}_L_{lambda}.csv;"),
    
    
    ANALYSIS = "TYPE = MIXTURE;
      algorithm = integration;
      STARTS = 50 10;
      processors = 24;
      logcriterion=0.00001;
      mconv=0.00001;",

    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_LTA_Model3<- mplusModeler(RILTA_LTA3, 
                                   dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', glue("RILTA_LTA_M3_N_{N}_TP_{TPs}_M_{mix}_L_{lambda}.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', "RILTA_LTA_M3_N_{N}_TP_{TPs}_M_{mix}_L_{lambda}.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_LTA_Model3)
}

# Step 3: Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func3", "p1")))

# Ensure that the packages are loaded on each cluster node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(p1), function(i) {
  rilta_lta_func3(p1$N[i], p1$TPs[i], p1$mix[i], p1$lambda[i])
})


stopCluster(cl)
```

## Model 4: Varied Lambda Pattern A

### Conditions:

Sample Size: N = 500, 1000, 2500, 5000

Transition logit (Probability): TPs = 3.179 (Stayer), 0.407 (Mover)

![](images/clipboard-2891141057.png){width="352"}

RI Loadings: lambda = Pattern A

![](images/clipboard-236077840.png){width="516"}

Thresholds= Model 1

![](images/clipboard-1358058122.png){width="359"}

**Class Prevalence: Equal v. Unequal 1 = .33.3, .33.3, 33.3 ; 2 = .60, .30, .10**

#### Condition Matrix for Model 4 - Model 15

```{r}

p1 <- expand.grid(N = c(500, 1000, 2500, 5000),
TPs = c(3.179, 0.407),
mix = c(1, 2))

# Display the matrix using gt
p1 %>%
  gt() %>%
  tab_header(
    title = "Simulation Conditions Matrix",
    subtitle = "Combinations of Sample Sizes, Transition Probabilities, Lambdas, and Mixing Propotions"
  ) %>%
  cols_align(
    align = "center",
    columns = everything() # Centers all columns
  )

```

```{r,message=FALSE, warning=FALSE, eval = FALSE}
#| label: "rilta-lta-simulation-Model 4"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true
# Step 1: Create the cluster (use PSOCK for Windows)
num_cores <- detectCores() - 1  # Detect number of cores
cl <- makeCluster(num_cores, type = "PSOCK")    # Create the cluster with PSOCK


rilta_lta_func4 <- function(N, TPs, mix) {
  
  # Construct the MODELPOPULATION argument based on the value of mix
  MODELPOPULATION <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      
      	
       f by u11*.1 u12*.1 u13*.1 u14*.2 u15*1 (p1-p5)
            u21*.1 u22*.1 u23*.1 u24*.2 u25*1 (p1-p5);
        f@1;
        [f@0];
        
        
      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
    
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;

      	
       f by u11*.1 u12*.1 u13*.1 u14*.2 u15*1 (p1-p5)
            u21*.1 u22*.1 u23*.1 u24*.2 u25*1 (p1-p5);
        f@1;
        [f@0];
        
        
      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2: 	
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
    
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2: 	
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  }

  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      

    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      

    ")
  }

  # Construct the Mplus object
  RILTA_LTA4 <- mplusObject(
    TITLE = glue("RILTA_LTA_M1_N_{N}_TP_{TPs}_M_{mix}_L_A"),
    MONTECARLO = glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N};
      SEED = 07252005;
      NREPS = 500;
      !SAVE = repM4*.dat;
      RESULTS = RILTA_LTA_M1_N_{N}_TP_{TPs}_M_{mix}_L_A.csv;"),
    
    
    ANALYSIS = "TYPE = MIXTURE;
      algorithm = integration;
      STARTS = 50 10;
      processors = 24;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_LTA_Model4<- mplusModeler(RILTA_LTA4, 
                                   dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', glue("RILTA_LTA_M1_N_{N}_TP_{TPs}_M_{mix}_L_A.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', "RILTA_LTA_M1_N_{N}_TP_{TPs}_M_{mix}_L_A.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_LTA_Model4)
}

# Step 3: Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func4", "p1")))

# Ensure that the packages are loaded on each cluster node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(p1), function(i) {
  rilta_lta_func4(p1$N[i], p1$TPs[i], p1$mix[i])
               })
stopCluster(cl)
```

## Model 5: Varied Lambda Pattern B

### Conditions:

Sample Size: N = 500, 1000, 2500, 5500

Transition logit (Probability): TPs = 3.179 (Stayer), 0.407 (Mover)

![](images/clipboard-2891141057.png){width="352"}

RI Loadings: lambda = Pattern B

![](images/clipboard-236077840.png){width="483"}

Thresholds= Model 1

![](images/clipboard-1358058122.png){width="361"}

**Class Prevalence: Equal v. Unequal 1 = .33.3, .33.3, 33.3 ; 2 = .60, .30, .10**

```{r,message=FALSE, warning=FALSE, eval = FALSE}
#| label: "rilta-lta-simulation-Model 5"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true
# Step 1: Create the cluster (use PSOCK for Windows)
num_cores <- detectCores() - 1  # Detect number of cores
cl <- makeCluster(num_cores, type = "PSOCK")    # Create the cluster with PSOCK

rilta_lta_func5 <- function(N, TPs, mix) {
  
  # Construct the MODELPOPULATION argument based on the value of mix
  MODELPOPULATION <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
        	
       f by u11*.3 u12*.2 u13*.3 u14*.7 u15*1 (p1-p5)
            u21*.3 u22*.2 u23*.3 u24*.7 u25*1 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
    
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;

      	
       f by u11*.3 u12*.2 u13*.3 u14*.7 u15*1 (p1-p5)
            u21*.3 u22*.2 u23*.3 u24*.7 u25*1 (p1-p5);
        f@1;
        [f@0];
        
        
      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2: 	
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
    
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2: 	
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  }

  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    
      
    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  }

  # Construct the Mplus object
  RILTA_LTA5 <- mplusObject(
    TITLE = glue("RILTA_LTA_M1_N_{N}_TP_{TPs}_M_{mix}_L_B"),
    MONTECARLO = glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N};
      SEED = 07252005;
      NREPS = 500;
      !SAVE = repM5*.dat;
      RESULTS = RILTA_LTA_M1_N_{N}_TP_{TPs}_M_{mix}_L_B.csv;"),
    
    
    ANALYSIS = "TYPE = MIXTURE;
      algorithm = integration;
      STARTS = 50 10;
      processors = 24;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_LTA_Model5<- mplusModeler(RILTA_LTA5, 
                                   dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', glue("RILTA_LTA_M1_N_{N}_TP_{TPs}_M_{mix}_L_B.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', "RILTA_LTA_M1_N_{N}_TP_{TPs}_M_{mix}_L_B.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_LTA_Model5)
}

# Step 3: Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func5", "p1")))

# Ensure that the packages are loaded on each cluster node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(p1), function(i) {
  rilta_lta_func5(p1$N[i], p1$TPs[i], p1$mix[i])
               })
stopCluster(cl)
```

## Model 6: Varied Lambda Pattern C

### Conditions:

Sample Size: N = 500, 1000, 2500, 5500

Transition logit (Probability): TPs = 3.179 (Stayer), 0.407 (Mover)

![](images/clipboard-2891141057.png){width="352"}

RI Loadings: lambda = Pattern C

![](images/clipboard-236077840.png){width="621"}

Thresholds: Model 1

![](images/clipboard-1358058122.png){width="384"}

**Class Prevalence: Equal v. Unequal 1 = .33.3, .33.3, 33.3 ; 2 = .60, .30, .10**

```{r,message=FALSE, warning=FALSE, eval = FALSE}

#| label: "rilta-lta-simulation-Model 6"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true
#| 
# Step 1: Create the cluster (use PSOCK for Windows)
num_cores <- detectCores() - 1  # Detect number of cores
cl <- makeCluster(num_cores, type = "PSOCK")    # Create the cluster with PSOCK

rilta_lta_func6 <- function(N, TPs, mix) {
  
  # Construct the MODELPOPULATION argument based on the value of mix
  MODELPOPULATION <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.5 u12*.5 u13*.5 u14*.6 u15*1.4 (p1-p5)
            u21*.5 u22*.5 u23*.5 u24*.6 u25*1.4 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
    
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.5 u12*.5 u13*.5 u14*.6 u15*1.4 (p1-p5)
            u21*.5 u22*.5 u23*.5 u24*.6 u25*1.4 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2: 	
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
    
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2: 	
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  }

  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      

    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
 
    ")
  }

  # Construct the Mplus object
  RILTA_LTA6 <- mplusObject(
    TITLE = glue("RILTA_LTA_M1_N_{N}_TP_{TPs}_M_{mix}_L_C"),
    MONTECARLO = glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N};
      SEED = 07252005;
      NREPS = 500;
      !SAVE = repM6*.dat;
      RESULTS = RILTA_LTA_M1_N_{N}_TP_{TPs}_M_{mix}_L_C.csv;"),
    
    
    ANALYSIS = "TYPE = MIXTURE;
      algorithm = integration;
      STARTS = 50 10;
      processors = 24;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_LTA_Model6<- mplusModeler(RILTA_LTA6, 
                                   dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', glue("RILTA_LTA_M1_N_{N}_TP_{TPs}_M_{mix}_L_C.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', "RILTA_LTA_M1_N_{N}_TP_{TPs}_M_{mix}_L_C.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_LTA_Model6)
}

# Step 3: Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func6", "p1")))

# Ensure that the packages are loaded on each cluster node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(p1), function(i) {
  rilta_lta_func6(p1$N[i], p1$TPs[i], p1$mix[i])
               })
stopCluster(cl)
```

## Model 7: Varied Lambda Pattern D

### Conditions:

Sample Size: N = 500, 1000, 2500, 5500

Transition logit (Probability): TPs = 3.179 (Stayer), 0.407 (Mover)

![](images/clipboard-2891141057.png){width="352"}

RI Loadings: lambda = PATTERN D

![](images/clipboard-236077840.png){width="550"}

Thresholds= Model 1

![](images/clipboard-1358058122.png){width="318"}

**Class Prevalence: Equal v. Unequal 1 = .33.3, .33.3, 33.3 ; 2 = .60, .30, .10**

```{r,message=FALSE, warning=FALSE, eval = FALSE}

#| label: "rilta-lta-simulation-Model 7"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true
#| 
# Step 1: Create the cluster (use PSOCK for Windows)
num_cores <- detectCores() - 1  # Detect number of cores
cl <- makeCluster(num_cores, type = "PSOCK")    # Create the cluster with PSOCK

rilta_lta_func7 <- function(N, TPs, mix) {
  
  # Construct the MODELPOPULATION argument based on the value of mix
  MODELPOPULATION <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.5 u12*.5 u13*.5 u14*.6 u15*2.4 (p1-p5)
            u21*.5 u22*.5 u23*.5 u24*.6 u25*2.4 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
    
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.5 u12*.5 u13*.5 u14*.6 u15*2.4 (p1-p5)
            u21*.5 u22*.5 u23*.5 u24*.6 u25*.4 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2: 	
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
    
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2: 	
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  }

  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      

    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      

    ")
  }

  # Construct the Mplus object
  RILTA_LTA7 <- mplusObject(
    TITLE = glue("RILTA_LTA_M1_N_{N}_TP_{TPs}_M_{mix}_L_D"),
    MONTECARLO = glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N};
      SEED = 07252005;
      NREPS = 500;
      !SAVE = repM7*.dat;
      RESULTS = RILTA_LTA_M1_N_{N}_TP_{TPs}_M_{mix}_L_D.csv;"),
    
    
    ANALYSIS = "TYPE = MIXTURE;
      algorithm = integration;
      STARTS = 50 10;
      processors = 24;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_LTA_Model7<- mplusModeler(RILTA_LTA7, 
                                   dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', glue("RILTA_LTA_M1_N_{N}_TP_{TPs}_M_{mix}_L_D.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', "RILTA_LTA_M1_N_{N}_TP_{TPs}_M_{mix}_L_D.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_LTA_Model7)
}

# Step 3: Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func7", "p1")))

# Ensure that the packages are loaded on each cluster node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(p1), function(i) {
  rilta_lta_func7(p1$N[i], p1$TPs[i], p1$mix[i])
               })
stopCluster(cl)
```

## Model 8: Varied Lambda Pattern A

### Conditions:

Sample Size: N = 500, 1000, 2500, 5500

Transition logit (Probability): TPs = 3.179 (Stayer), 0.407 (Mover)

![](images/clipboard-2891141057.png){width="352"}

RI Loadings: lambda = Pattern A

![](images/clipboard-236077840.png){width="587"}

Thresholds= Model 2

![](images/clipboard-3697136395.png){width="226"}

**Class Prevalence: Equal v. Unequal 1 = .33.3, .33.3, 33.3 ; 2 = .60, .30, .10**

```{r,message=FALSE, warning=FALSE, eval = FALSE}

#| label: "rilta-lta-simulation-Model 8"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true
#| 
# Step 1: Create the cluster (use PSOCK for Windows)
num_cores <- detectCores() - 1  # Detect number of cores
cl <- makeCluster(num_cores, type = "PSOCK")    # Create the cluster with PSOCK


rilta_lta_func8 <- function(N, TPs, mix) {
  
  # Construct the MODELPOPULATION argument based on the value of mix
  MODELPOPULATION <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.1 u12*.1 u13*.1 u14*.2 u15*1 (p1-p5)
            u21*.1 u22*.1 u23*.1 u24*.2 u25*1 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
    
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.1 u12*.1 u13*.1 u14*.2 u15*1 (p1-p5)
            u21*.1 u22*.1 u23*.1 u24*.2 u25*1 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

      MODEL c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL c2: 	
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
    
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

      MODEL c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL c2: 	
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
  }

  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);

    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      

    ")
  }

  # Construct the Mplus object
  RILTA_LTA8 <- mplusObject(
    TITLE = glue("RILTA_LTA_M2_N_{N}_TP_{TPs}_M_{mix}_L_A"),
    MONTECARLO = glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N};
      SEED = 07252005;
      NREPS = 500;
      !SAVE = repM8*.dat;
      RESULTS = RILTA_LTA_M2_N_{N}_TP_{TPs}_M_{mix}_L_A.csv;"),
    
    
    ANALYSIS = "TYPE = MIXTURE;
      algorithm = integration;
      STARTS = 50 10;
      processors = 24;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_LTA_Model8<- mplusModeler(RILTA_LTA8, 
                                   dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', glue("RILTA_LTA_M2_N_{N}_TP_{TPs}_M_{mix}_L_A.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', "RILTA_LTA_M2_N_{N}_TP_{TPs}_M_{mix}_L_A.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_LTA_Model8)
}

# Step 3: Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func8", "p1")))

# Ensure that the packages are loaded on each cluster node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(p1), function(i) {
  rilta_lta_func8(p1$N[i], p1$TPs[i], p1$mix[i])
               })

stopCluster(cl)
```

## Model 9: Varied Lambda Pattern B

### Conditions:

Sample Size: N = 500, 1000, 2500, 5500

Transition logit (Probability): TPs = 3.179 (Stayer), 0.407 (Mover)

![](images/clipboard-2891141057.png){width="352"}

RI Loadings: lambda = Pattern B

![](images/clipboard-236077840.png){width="581"}

Thresholds= Model 2

![](images/clipboard-3697136395.png){width="266"}

**Class Prevalence: Equal v. Unequal 1 = .33.3, .33.3, 33.3 ; 2 = .60, .30, .10**

```{r,message=FALSE, warning=FALSE, eval = FALSE}

#| label: "rilta-lta-simulation-Model 9"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true
#| 
# Step 1: Create the cluster (use PSOCK for Windows)
num_cores <- detectCores() - 1  # Detect number of cores
cl <- makeCluster(num_cores, type = "PSOCK")    # Create the cluster with PSOCK

rilta_lta_func9 <- function(N, TPs, mix) {
  
  # Construct the MODELPOPULATION argument based on the value of mix
  MODELPOPULATION <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.3 u12*.2 u13*.3 u14*.7 u15*1 (p1-p5)
            u21*.3 u22*.2 u23*.3 u24*.7 u25*1 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
    
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.3 u12*.2 u13*.3 u14*.7 u15*1 (p1-p5)
            u21*.3 u22*.2 u23*.3 u24*.7 u25*1 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

      MODEL c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL c2: 	
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
    
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

      MODEL c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL c2: 	
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
  }

  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      

    ")
  }

  # Construct the Mplus object
  RILTA_LTA9 <- mplusObject(
    TITLE = glue("RILTA_LTA_M2_N_{N}_TP_{TPs}_M_{mix}_L_B"),
    MONTECARLO = glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N};
      SEED = 07252005;
      NREPS = 500;
      !SAVE = repM9*.dat;
      RESULTS = RILTA_LTA_M2_N_{N}_TP_{TPs}_M_{mix}_L_B.csv;"),
    
    ANALYSIS = "TYPE = MIXTURE;
      algorithm = integration;
      processors = 24;
      STARTS 50 10;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_LTA_Model9<- mplusModeler(RILTA_LTA9, 
                                   dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', glue("RILTA_LTA_M2_N_{N}_TP_{TPs}_M_{mix}_L_B.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', "RILTA_LTA_M2_N_{N}_TP_{TPs}_M_{mix}_L_B.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_LTA_Model9)
}

# Step 3: Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func9", "p1")))

# Ensure that the packages are loaded on each cluster node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(p1), function(i) {
  rilta_lta_func9(p1$N[i], p1$TPs[i], p1$mix[i])
               })

stopCluster(cl)
```

## Model 10: Varied Lambda Pattern C

### Conditions:

Sample Size: N = 500, 1000, 2500, 5500

Transition logit (Probability): TPs = 3.179 (Stayer), 0.407 (Mover)

![](images/clipboard-2891141057.png){width="352"}

RI Loadings: lambda = Pattern C

![](images/clipboard-236077840.png){width="581"}

Thresholds= Model 2

![](images/clipboard-3697136395.png){width="295"}

**Class Prevalence: Equal v. Unequal 1 = .33.3, .33.3, 33.3 ; 2 = .60, .30, .10**

```{r,message=FALSE, warning=FALSE, eval = FALSE}

#| label: "rilta-lta-simulation-Model 10"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true
#| 
# Step 1: Create the cluster (use PSOCK for Windows)
num_cores <- detectCores() - 1  # Detect number of cores
cl <- makeCluster(num_cores, type = "PSOCK")    # Create the cluster with PSOCK

rilta_lta_func10 <- function(N, TPs, mix) {
  
  # Construct the MODELPOPULATION argument based on the value of mix
  MODELPOPULATION <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.5 u12*.5 u13*.5 u14*.6 u15*1.4 (p1-p5)
            u21*.5 u22*.5 u23*.5 u24*.6 u25*1.4 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
    
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.5 u12*.5 u13*.5 u14*.6 u15*1.4 (p1-p5)
            u21*.5 u22*.5 u23*.5 u24*.6 u25*1.4 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

      MODEL c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL c2: 	
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
    
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

      MODEL c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL c2: 	
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
  }

  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      

    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      

    ")
  }

  # Construct the Mplus object
  RILTA_LTA10 <- mplusObject(
    TITLE = glue("RILTA_LTA_M2_N_{N}_TP_{TPs}_M_{mix}_L_C"),
    MONTECARLO = glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N};
      SEED = 07252005;
      NREPS = 500;
      !SAVE = repM10*.dat;
      RESULTS = RILTA_LTA_M2_N_{N}_TP_{TPs}_M_{mix}_L_C.csv;"),
    
    ANALYSIS = "TYPE = MIXTURE;
      algorithm = integration;
      STARTS 50 10;
      processors = 24;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_LTA_Model10<- mplusModeler(RILTA_LTA10, 
                                   dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', glue("RILTA_LTA_M2_N_{N}_TP_{TPs}_M_{mix}_L_C.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', "RILTA_LTA_M2_N_{N}_TP_{TPs}_M_{mix}_L_C.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_LTA_Model10)
}

# Step 3: Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func10", "p1")))

# Ensure that the packages are loaded on each cluster node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(p1), function(i) {
  rilta_lta_func10(p1$N[i], p1$TPs[i], p1$mix[i])
               })

stopCluster(cl)
```

## Model 11: Varied Lambda Pattern D

### Conditions:

Sample Size: N = 500, 1000, 2500, 5500

Transition logit (Probability): TPs = 3.179 (Stayer), 0.407 (Mover)

![](images/clipboard-2891141057.png){width="352"}

RI Loadings: lambda = PATTERN D

![](images/clipboard-236077840.png){width="525"}

Thresholds= Model 2

![](images/clipboard-3697136395.png){width="287"}

**Class Prevalence: Equal v. Unequal 1 = .33.3, .33.3, 33.3 ; 2 = .60, .30, .10**

```{r,message=FALSE, warning=FALSE, eval = FALSE}

#| label: "rilta-lta-simulation-Model 11"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true
#| 
# Step 1: Create the cluster (use PSOCK for Windows)
num_cores <- detectCores() - 1  # Detect number of cores
cl <- makeCluster(num_cores, type = "PSOCK")    # Create the cluster with PSOCK

rilta_lta_func11 <- function(N, TPs, mix) {
  
  # Construct the MODELPOPULATION argument based on the value of mix
  MODELPOPULATION <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.5 u12*.5 u13*.5 u14*.6 u15*2.4 (p1-p5)
            u21*.5 u22*.5 u23*.5 u24*.6 u25*2.4 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
    
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.5 u12*.5 u13*.5 u14*.6 u15*2.4 (p1-p5)
            u21*.5 u22*.5 u23*.5 u24*.6 u25*2.4 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

      MODEL c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL c2: 	
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
    
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

      MODEL c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL c2: 	
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
  }

  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      

    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      

    ")
  }

  # Construct the Mplus object
  RILTA_LTA11 <- mplusObject(
    TITLE = glue("RILTA_LTA_M2_N_{N}_TP_{TPs}_M_{mix}_L_D"),
    MONTECARLO = glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N};
      SEED = 07252005;
      NREPS = 500;
      !SAVE = repM11*.dat;
      RESULTS = RILTA_LTA_M2_N_{N}_TP_{TPs}_M_{mix}_L_D.csv;"),
    
    ANALYSIS = "TYPE = MIXTURE;
      algorithm = integration;
      STARTS 50 10;
      processors = 24;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_LTA_Model11<- mplusModeler(RILTA_LTA11, 
                                   dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', glue("RILTA_LTA_M2_N_{N}_TP_{TPs}_M_{mix}_L_D.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', "RILTA_LTA_M2_N_{N}_TP_{TPs}_M_{mix}_L_D.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_LTA_Model11)
}

# Step 3: Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func11", "p1")))

# Ensure that the packages are loaded on each cluster node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(p1), function(i) {
  rilta_lta_func11(p1$N[i], p1$TPs[i], p1$mix[i])
               })

stopCluster(cl)
```

## Model 12: Varied Lambda Pattern A

### Conditions:

Sample Size: N = 500, 1000, 2500, 5500

Transition logit (Probability): TPs = 3.179 (Stayer), 0.407 (Mover)

![](images/clipboard-2891141057.png){width="352"}

RI Loadings: lambda = Pattern A

![](images/clipboard-236077840.png){width="574"}

Thresholds= Model 3

![](images/clipboard-260898834.png){width="328"}

**Class Prevalence: Equal v. Unequal 1 = .33.3, .33.3, 33.3 ; 2 = .60, .30, .10**

```{r,message=FALSE, warning=FALSE, eval = FALSE}

#| label: "rilta-lta-simulation-Model 12"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Step 1: Create the cluster (use PSOCK for Windows)
num_cores <- detectCores() - 1  # Detect number of cores
cl <- makeCluster(num_cores, type = "PSOCK")    # Create the cluster with PSOCK

rilta_lta_func12 <- function(N, TPs, mix) {
  
    # Construct the MODELPOPULATION argument based on the value of mix
  MODELPOPULATION <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.1 u12*.1 u13*.1 u14*.2 u15*1 (p1-p5)
            u21*.1 u22*.1 u23*.1 u24*.2 u25*1 (p1-p5);
        f@1;
        [f@0];
          
        MODEL POPULATION-c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
       ")
    
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.1 u12*.1 u13*.1 u14*.2 u15*1 (p1-p5)
            u21*.1 u22*.1 u23*.1 u24*.2 u25*1 (p1-p5);
        f@1;
        [f@0];
              
     MODEL POPULATION-c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
       ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

     MODEL c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
	      ")      
      
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	      

     MODEL c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
	      ")      
  }
    
  
  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      

    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      

    ")
  }
  
  RILTA_LTA12 <- mplusObject(
    TITLE = glue("Generate RILTA_LTA_M3_N_{N}_TP_{TPs}_M_{mix}_L_A"),

    MONTECARLO =
      glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N};
      SEED = 07252005;
      NREPS = 500;
      !SAVE = repM12*.dat;
      RESULTS = RILTA_LTA_M3_N_{N}_TP_{TPs}_M_{mix}_L_A.csv;"),
    
    
    ANALYSIS = "TYPE = MIXTURE;
    Algorithm = INTEGRATION;
      STARTS = 50 10;
      processors = 24;
      logcriterion=0.00001;
      mconv=0.00001;",

    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_LTA_Model12<- mplusModeler(RILTA_LTA12, 
                                   dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', glue("RILTA_LTA_M3_N_{N}_TP_{TPs}_M_{mix}_L_A.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', "RILTA_LTA_M3_N_{N}_TP_{TPs}_M_{mix}_L_A.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_LTA_Model12)
}

# Step 3: Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func12", "p1")))

# Ensure that the packages are loaded on each cluster node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(p1), function(i) {
  rilta_lta_func12(p1$N[i], p1$TPs[i], p1$mix[i])
})

stopCluster(cl)

```

## Model 13: Varied Lambda Pattern B

### Conditions:

Sample Size: N = 500, 1000, 2500, 5500

Transition logit (Probability): TPs = 3.179 (Stayer), 0.407 (Mover)

![](images/clipboard-2891141057.png){width="352"}

RI Loadings: lambda = Pattern B

![](images/clipboard-236077840.png){width="648"}

Thresholds= Model 3

![](images/clipboard-260898834.png){width="363"}

**Class Prevalence: Equal v. Unequal 1 = .33.3, .33.3, 33.3 ; 2 = .60, .30, .10**

```{r,message=FALSE, warning=FALSE, eval = FALSE}

#| label: "rilta-lta-simulation-Model 13"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true


# Step 1: Create the cluster (use PSOCK for Windows)
num_cores <- detectCores() - 1  # Detect number of cores
cl <- makeCluster(num_cores, type = "PSOCK")    # Create the cluster with PSOCK

rilta_lta_func13 <- function(N, TPs, mix) {
  
    # Construct the MODELPOPULATION argument based on the value of mix
  MODELPOPULATION <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.3 u12*.2 u13*.3 u14*.7 u15*1 (p1-p5)
            u21*.3 u22*.2 u23*.3 u24*.7 u25*1 (p1-p5);
        f@1;
        [f@0];
          
        MODEL POPULATION-c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
       ")
    
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.3 u12*.2 u13*.3 u14*.7 u15*1 (p1-p5)
            u21*.3 u22*.2 u23*.3 u24*.7 u25*1 (p1-p5);
        f@1;
        [f@0];
              
     MODEL POPULATION-c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
       ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

     MODEL c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
	      ")      
      
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	      

     MODEL c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
	      ")      
  }
    
  
  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);

    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);

    ")
  }
  
  RILTA_LTA13 <- mplusObject(
    TITLE = glue("Generate RILTA_LTA_M3_N_{N}_TP_{TPs}_M_{mix}_L_B"),

    MONTECARLO =
      glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N};
      SEED = 07252005;
      NREPS = 500;
      !SAVE = repM13*.dat;
      RESULTS = RILTA_LTA_M3_N_{N}_TP_{TPs}_M_{mix}_L_B.csv;"),
    
    
    ANALYSIS = "TYPE = MIXTURE;
      algorithm = integration;
      STARTS = 50 10;
      processors = 24;
      logcriterion=0.00001;
      mconv=0.00001;",

    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_LTA_Model13<- mplusModeler(RILTA_LTA13, 
                                   dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', glue("RILTA_LTA_M3_N_{N}_TP_{TPs}_M_{mix}_L_B.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', "RILTA_LTA_M3_N_{N}_TP_{TPs}_M_{mix}_L_B.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_LTA_Model13)
}

# Step 3: Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func13", "p1")))

# Ensure that the packages are loaded on each cluster node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(p1), function(i) {
  rilta_lta_func13(p1$N[i], p1$TPs[i], p1$mix[i])
})


stopCluster(cl)
```

## Model 14: Varied Lambda Pattern C

### Conditions:

Sample Size: N = 500, 1000, 2500, 5500

Transition logit (Probability): TPs = 3.179 (Stayer), 0.407 (Mover)

![](images/clipboard-2891141057.png){width="352"}

RI Loadings: lambda = Pattern C

![](images/clipboard-236077840.png){width="739"}

Thresholds= Model 3

![](images/clipboard-260898834.png){width="312"}

**Class Prevalence: Equal v. Unequal 1 = .33.3, .33.3, 33.3 ; 2 = .60, .30, .10**

```{r,message=FALSE, warning=FALSE, eval = FALSE}

#| label: "rilta-lta-simulation-Model 14"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true


# Step 1: Create the cluster (use PSOCK for Windows)
num_cores <- detectCores() - 1  # Detect number of cores
cl <- makeCluster(num_cores, type = "FORK")    # Create the cluster with PSOCK

rilta_lta_func14 <- function(N, TPs, mix) {
  
    # Construct the MODELPOPULATION argument based on the value of mix
      # Construct the MODELPOPULATION argument based on the value of mix
  MODELPOPULATION <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.5 u12*.5 u13*.5 u14*.6 u15*1.4 (p1-p5)
            u21*.5 u22*.5 u23*.5 u24*.6 u25*1.4 (p1-p5);
        f@1;
        [f@0];
          
        MODEL POPULATION-c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
       ")
    
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.3 u12*.2 u13*.3 u14*.7 u15*1 (p1-p5)
            u21*.3 u22*.2 u23*.3 u24*.7 u25*1 (p1-p5);
        f@1;
        [f@0];
              
     MODEL POPULATION-c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
       ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

     MODEL c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
	      ")      
      
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	      

     MODEL c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
	      ")      
  }
    
  
  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);

    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);

    ")
  }
  
  RILTA_LTA14 <- mplusObject(
    TITLE = glue("Generate RILTA_LTA_M3_N_{N}_TP_{TPs}_M_{mix}_L_B"),

    MONTECARLO =
      glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N};
      SEED = 07252005;
      NREPS = 500;
      !SAVE = repM14*.dat;
      RESULTS = RILTA_LTA_M3_N_{N}_TP_{TPs}_M_{mix}_L_C.csv;"),
    
    
    ANALYSIS = "TYPE = MIXTURE;
      algorithm = integration;
      STARTS = 50 10;
      processors = 24;
      logcriterion=0.00001;
      mconv=0.00001;",

    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_LTA_Model14<- mplusModeler(RILTA_LTA14, 
                                   dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', glue("RILTA_LTA_M3_N_{N}_TP_{TPs}_M_{mix}_L_C.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', "RILTA_LTA_M3_N_{N}_TP_{TPs}_M_{mix}_L_C.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_LTA_Model14)
}

# Step 3: Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func14", "p1")))

# Ensure that the packages are loaded on each cluster node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(p1), function(i) {
  rilta_lta_func14(p1$N[i], p1$TPs[i], p1$mix[i])
})


stopCluster(cl)
```

## Model 15: Varied Lambda Pattern D

### Conditions:

Sample Size: N = 500, 1000, 2500, 5500

Transition logit (Probability): TPs = 3.179 (Stayer), 0.407 (Mover)

![](images/clipboard-2891141057.png){width="352"}

RI Loadings: lambda = PATTERN D

![](images/clipboard-236077840.png){width="653"}

Thresholds= Model 3

![](images/clipboard-260898834.png){width="281"}

**Class Prevalence: Equal v. Unequal 1 = .33.3, .33.3, 33.3 ; 2 = .60, .30, .10**

```{r,message=FALSE, warning=FALSE, eval = FALSE}

#| label: "rilta-lta-simulation-Model 15"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Step 1: Create the cluster (use PSOCK for Windows, FORK for MAC)
num_cores <- detectCores() - 1  # Detect number of cores
cl <- makeCluster(num_cores, type = "FORK") # Create the cluster with FORK or PSOCK

rilta_lta_func15 <- function(N, TPs, mix) {
  
    # Step 2: Construct the MODELPOPULATION argument based on the value of mix
  MODELPOPULATION <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.5 u12*.5 u13*.5 u14*.6 u15*2.4 (p1-p5)
            u21*.5 u22*.5 u23*.5 u24*.6 u25*2.4 (p1-p5);
        f@1;
        [f@0];
          
        MODEL POPULATION-c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
       ")
    
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.5 u12*.5 u13*.5 u14*.6 u15*2.4 (p1-p5)
            u21*.5 u22*.5 u23*.5 u24*.6 u25*2.4 (p1-p5);
        f@1;
        [f@0];
              
     MODEL POPULATION-c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
       ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

     MODEL c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
	      ")      
      
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	      

     MODEL c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
	      ")      
  }
    
  
  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      

    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
 
    ")
  }
  
  RILTA_LTA15 <- mplusObject(
    TITLE = glue("Generate RILTA_LTA_M3_N_{N}_TP_{TPs}_M_{mix}_L_D"),

    MONTECARLO =
      glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N};
      SEED = 07252005;
      NREPS = 500;
      !SAVE = repM15*.dat;
      RESULTS = RILTA_LTA_M3_N_{N}_TP_{TPs}_M_{mix}_L_D.csv;"),
    
    
    ANALYSIS = "TYPE = MIXTURE;
      algorithm = integration;
      STARTS = 50 10;
      processors = 24;
      logcriterion=0.00001;
      mconv=0.00001;",

    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_LTA_Model15<- mplusModeler(RILTA_LTA15, 
                                   dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', glue("RILTA_LTA_M3_N_{N}_TP_{TPs}_M_{mix}_L_D.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED', "RILTA_LTA_M3_N_{N}_TP_{TPs}_M_{mix}_L_D.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_LTA_Model15)
}

# Step 3: Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func15", "p1")))

# Ensure that the packages are loaded on each cluster node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(p1), function(i) {
  rilta_lta_func15(p1$N[i], p1$TPs[i], p1$mix[i])
})


stopCluster(cl)
```

# CHECK FOR LABEL SWITCHING

### Step 1: Combine All CSV Files into One Data Frame

#### **Objective:**Â 

*Load all CSV files and combine them into a single data frame.*

```{r}
#| label: "combine-csv-files-parallel"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true


# Step 1: Set the correct CSV directory
csv_directory <- here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED')

# Step 2: Source the child document
source(here('Child_Docs', 'data_scraping.R'))
```

### Step 2: Scrape Rows and Process Data

#### **Objective:**Â 

*Extract the appropriate rows from each 9-row chunk) and prepare the data for further processing.*

```{r}

#| label: "scrape-rows-process-data-parallel"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Step 2: Process the data using the child script
source(here('Child_Docs', 'step2_f_LTA.R'))

#Generates final_combined_data df
```

### Step 3: Convert Logits to Probabilities, Add Actual (Population) Values, and flag violators of label switching

#### **Objective:**Â 

*Convert the logits to probabilities and flag label switching cases*

```{r}
#| label: "convert-logits-and-flag-vialotors"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Step 3: Process the data and return results
source(here('Child_Docs', 'step_3.R'))

# The objects `final_data_with_actuals` and `violators` should now be in the global environment
```

### **Step 4: Plot Random Sample of Violators for Visual Inspection**

#### **Objective**

*Generate plots of randomly sampled violators for visual inspection using parallel processing.*

```{r, eval= FALSE}
#| label: "plot-violators"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Set plot dimensions
plot_width <- 8
plot_height <- 6

# Set seed and sample violators
set.seed(123)
sampled_violators <- violators[sample(nrow(violators), 250), ]

# Define the function to create and save plots for violators
plot_violator <- function(i) {
  row_data <- sampled_violators[i, ]
  file_name <- row_data$FileName  # Extract file name
  
  # Extract probabilities for EC1 through AC3
  probabilities <- c(
    as.numeric(row_data[c("Ec1u1", "Ec1u2", "Ec1u3", "Ec1u4", "Ec1u5")]),
    as.numeric(row_data[c("Ec2u1", "Ec2u2", "Ec2u3", "Ec2u4", "Ec2u5")]),
    as.numeric(row_data[c("Ec3u1", "Ec3u2", "Ec3u3", "Ec3u4", "Ec3u5")]),
    as.numeric(row_data[c("Ac1u1", "Ac1u2", "Ac1u3", "Ac1u4", "Ac1u5")]),
    as.numeric(row_data[c("Ac2u1", "Ac2u2", "Ac2u3", "Ac2u4", "Ac2u5")]),
    as.numeric(row_data[c("Ac3u1", "Ac3u2", "Ac3u3", "Ac3u4", "Ac3u5")])
  )
  
  # Create labels for the legend
  labels <- c(
    paste0("EC1: (", round(row_data$Ec1u1, 3), ", ", round(row_data$Ec1u2, 3), ", ", round(row_data$Ec1u3, 3), ", ", round(row_data$Ec1u4, 3), ", ", round(row_data$Ec1u5, 3), ")"),
    paste0("EC2: (", round(row_data$Ec2u1, 3), ", ", round(row_data$Ec2u2, 3), ", ", round(row_data$Ec2u3, 3), ", ", round(row_data$Ec2u4, 3), ", ", round(row_data$Ec2u5, 3), ")"),
    paste0("EC3: (", round(row_data$Ec3u1, 3), ", ", round(row_data$Ec3u2, 3), ", ", round(row_data$Ec3u3, 3), ", ", round(row_data$Ec3u4, 3), ", ", round(row_data$Ec3u5, 3), ")"),
    paste0("AC1: (", round(row_data$Ac1u1, 3), ", ", round(row_data$Ac1u2, 3), ", ", round(row_data$Ac1u3, 3), ", ", round(row_data$Ac1u4, 3), ", ", round(row_data$Ac1u5, 3), ")"),
    paste0("AC2: (", round(row_data$Ac2u1, 3), ", ", round(row_data$Ac2u2, 3), ", ", round(row_data$Ac2u3, 3), ", ", round(row_data$Ac2u4, 3), ", ", round(row_data$Ac2u5, 3), ")"),
    paste0("AC3: (", round(row_data$Ac3u1, 3), ", ", round(row_data$Ac3u2, 3), ", ", round(row_data$Ac3u3, 3), ", ", round(row_data$Ac3u4, 3), ", ", round(row_data$Ac3u5, 3), ")")
  )

  # Create data frame for plotting
  plot_data <- data.frame(
    Items = rep(1:5, 6),
    Probabilities = probabilities,
    Class = rep(labels, each = 5)
  )

  # Generate the plot
  p <- ggplot(plot_data, aes(x = Items, y = Probabilities, color = Class, group = Class)) +
    geom_line(size = 1.2) +
    geom_point(size = 3) +
    labs(title = file_name, x = "Items", y = "Probabilities") +
    theme_minimal(base_size = 16) +
    theme(
      panel.background = element_rect(fill = "white"),
      plot.background = element_rect(fill = "white"),
      plot.title = element_text(size = 14, hjust = 0.5)
    ) +
    scale_color_manual(values = c(
      "darkblue", "darkgreen", "darkred",  # AC1 to AC3
      "lightblue", "lightgreen", "lightcoral"  # EC1 to EC3
    ))

  # Save the plot to the specified folder
  ggsave(filename = file.path("z2t_lta_rilta_violator_plots", paste0("violator_plot_", i, "_", file_name, ".png")),
         plot = p, width = plot_width, height = plot_height)
}

# Generate and save plots for each sampled violator
invisible(lapply(1:nrow(sampled_violators), plot_violator))

```

### **Step 5: Summarize Violations**

#### **Objective**

*Calculate the percentage of violations for each file, handling missing values appropriately.*

#### Scrape Output Files for Errors for specific replications

```{r}
#| label: "summarize-errors"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

library(parallel)

extract_errors_from_file <- function(filepath, total_replications) {
  lines <- readLines(filepath)
  results <- vector("list", total_replications)
  error_keywords <- c("NON-POSITIVE DEFINITE", "SADDLE")

  # Initialize results for every replication
  for (rep in 1:total_replications) {
    results[[rep]] <- tibble(
      FileName = basename(filepath),
      Replication = rep,
      Message = "None",
      MessageType = "None"
    )
  }

  current_replication <- NULL
  for (line in lines) {
    if (str_detect(line, "REPLICATION")) {
      current_replication <- as.integer(str_extract(line, "\\d+"))
    }

    if (!is.null(current_replication) && current_replication <= total_replications &&
        any(sapply(error_keywords, grepl, line, ignore.case = TRUE))) {
      results[[current_replication]] <- tibble(
        FileName = basename(filepath),
        Replication = current_replication,
        Message = str_trim(line),
        MessageType = "Error"
      )
    }
  }

  return(bind_rows(results))
}

# Step 2: Extract Completed Replications
extract_completed_replications <- function(filepath) {
  lines <- readLines(filepath)
  completed_line <- lines[grepl("Completed", lines, ignore.case = TRUE)]
  completed <- as.integer(str_match(completed_line, "Completed\\s+(\\d+)")[, 2])
  if (length(completed) == 0) completed <- 0
  tibble(FileName = basename(filepath), CompletedReplications = completed)
}

# Step 3: Extract Requested Replications
extract_requested_replications <- function(filepath) {
  lines <- readLines(filepath)
  requested_line <- lines[grepl("Requested", lines, ignore.case = TRUE)]
  requested <- as.integer(str_match(requested_line, "Requested\\s+(\\d+)")[, 2])
  if (length(requested) == 0) requested <- 0
  tibble(FileName = basename(filepath), RequestedReplications = requested)
}

calculate_replication_summary <- function(error_summary, completed_replications, requested_replications) {
  summary <- error_summary %>%
    group_by(FileName) %>%
    summarise(
      ErrorReplications = n_distinct(Replication[MessageType == "Error"]),
      .groups = "drop"
    )

  full_summary <- requested_replications %>%
    left_join(completed_replications, by = "FileName") %>%
    left_join(summary, by = "FileName") %>%
    mutate(
      ErrorReplications = coalesce(ErrorReplications, 0),
      GoodReplications = CompletedReplications - ErrorReplications,
      ErrorRate = if_else(CompletedReplications > 0, (ErrorReplications / CompletedReplications) * 100, 0)
    ) %>%
    select(FileName, RequestedReplications, CompletedReplications, ErrorReplications, GoodReplications, ErrorRate)

  full_summary
}

# Step 4: Parallelized Processing (Windows/Mac/Linux Compatible)
output_folder <- "3_RILTA_GEN_LTA_ANALYZED"  # Adjust to your folder path
file_list <- list.files(output_folder, pattern = "\\.out$", full.names = TRUE)

# Step 5: Detect OS and Set Up Cluster
cluster_type <- ifelse(.Platform$OS.type == "windows", "PSOCK", "FORK")
num_cores <- detectCores() - 1  # Use all but one core
cl <- makeCluster(num_cores, type = cluster_type)

# Export necessary libraries and functions to the cluster
invisible(clusterExport(cl, c("extract_errors_from_file", "extract_completed_replications", "extract_requested_replications")))
invisible(clusterEvalQ(cl, library(tidyverse)))

# Step 6: Parallel Processing
# Calculate completed replications first
completed_rep_list <- parLapply(cl, file_list, extract_completed_replications)

# Extract errors while passing the total number of completed replications to the function
error_summary <- bind_rows(mapply(function(filepath, completed_data) {
  extract_errors_from_file(filepath, completed_data$CompletedReplications)
}, file_list, completed_rep_list, SIMPLIFY = FALSE))

completed_replications <- bind_rows(parLapply(cl, file_list, extract_completed_replications))
requested_replications <- bind_rows(parLapply(cl, file_list, extract_requested_replications))

# Stop the cluster
stopCluster(cl)

# Step 7: Calculate Replication Summary
replication_summary <- calculate_replication_summary(error_summary, completed_replications, requested_replications)

# Step 8: Create and Display the Table with Error Rate
replication_summary_table <- replication_summary %>%
  gt() %>%
  tab_header(
    title = "Replication Summary",
    subtitle = paste0("Folder: ", output_folder)
  ) %>%
  fmt_number(columns = c(CompletedReplications, RequestedReplications, ErrorReplications, GoodReplications, ErrorRate), decimals = 2) %>%
  cols_label(
    FileName = "File Name",
    CompletedReplications = "Completed Replications",
    RequestedReplications = "Requested Replications",
    ErrorReplications = "Replications with Errors",
    GoodReplications = "Good Replications",
    ErrorRate = "Error Rate (%)"
  ) %>%
  tab_options(
    table.font.size = "small",
    heading.title.font.size = "medium",
    heading.subtitle.font.size = "small"
  )

# Display the table
replication_summary_table

completed_replications <- completed_replications %>%
  mutate(FileName = str_replace(FileName, "\\.out$", ""),
         FileName = tolower(FileName),
         FileName = str_trim(FileName))

error_summary <- error_summary %>%
  mutate(FileName = str_replace(FileName, "\\.out$", ""),
         FileName = tolower(FileName),
         FileName = str_trim(FileName))

final_data_with_actuals <- final_data_with_actuals %>%
  mutate(FileName = tolower(FileName),
         FileName = str_trim(FileName))

replication_summary <- replication_summary %>%
  mutate(FileName = str_replace(FileName, "\\.out$", ""),
         FileName = tolower(FileName),
         FileName = str_trim(FileName))

cat("Rows in final_data_with_actuals:", nrow(final_data_with_actuals), "\n")
# Output the final number of rows to confirm data handling
cat("Number of rows in error_summary: ", nrow(error_summary), "\n")
cat("Number of rows in replication_summary: ", nrow(replication_summary), "\n")

```

#### Step 5: Part 1 Merge errors with main data

```{r}
#| label: "merge-errors"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Ensure consistent column formats and remove .out and .csv extensions
error_summary <- error_summary %>%
  mutate(
    FileName = tolower(str_trim(gsub("\\.out$|\\.csv$", "", FileName))), # Remove extensions and standardize FileName
    Replication = as.character(Replication) # Convert Replication to character
  )

final_data_with_actuals <- final_data_with_actuals %>%
  mutate(
    FileName = tolower(str_trim(gsub("\\.out$|\\.csv$", "", FileName))), # Remove extensions and standardize FileName
    Replication = as.character(Replication) # Convert Replication to character
  )

# Add a new column to flag errors
error_summary <- error_summary %>%
  mutate(ErrorFlag = if_else(Message == "None", 0, 1))


# Merge ErrorFlag into final_data_with_actuals
final_data_with_actuals <- final_data_with_actuals %>%
  left_join(error_summary %>% select(FileName, Replication, ErrorFlag),
            by = c("FileName", "Replication"))
```

#### Step 5: Part 2 Create Column Names from the Filename

```{r}
#| label: "prepare-data-for-plotting-bias"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true


# Add new columns based on the information in the FileName
final_data_with_actuals <- final_data_with_actuals %>%
  mutate(
    Model = case_when(
      grepl("m1", FileName) ~ "1",
      grepl("m2", FileName) ~ "2",
      grepl("m3", FileName) ~ "3",
      TRUE ~ NA_character_
    ),
    N = case_when(
      grepl("n_5000", FileName) ~ 4,  # Convert to factor level 4
      grepl("n_500", FileName) ~ 1,   # Convert to factor level 1
      grepl("n_1000", FileName) ~ 2,  # Convert to factor level 2
      grepl("n_2500", FileName) ~ 3,  # Convert to factor level 3
      TRUE ~ NA_integer_
    ),
    Mixing_proportion = case_when(
      grepl("m_1", FileName) ~ 1,  # Even Class Proportions as factor level 1
      grepl("m_2", FileName) ~ 2,  # Uneven Proportions as factor level 2
      TRUE ~ NA_integer_
    ),
    Lambda_values = case_when(
      grepl("l_0.3", FileName) ~ "0.3",
      grepl("l_0.5", FileName) ~ "0.5",
      grepl("l_0.7", FileName) ~ "0.7",
      grepl("l_0.9", FileName) ~ "0.9",
      grepl("l_a", FileName) ~ "A",
      grepl("l_b", FileName) ~ "B",
      grepl("l_c", FileName) ~ "C",
      grepl("l_d", FileName) ~ "D",
      TRUE ~ NA_character_
    ),
    # Add Population column based on FileName and convert it to a factor with formatted labels
    Population = case_when(
      grepl("tp_0.407", FileName) ~ ".200",
      grepl("tp_3.179", FileName) ~ ".800",
      TRUE ~ NA_character_
    )
  )

# Convert N, Mixing_proportion, and Model columns to factors
final_data_with_actuals <- final_data_with_actuals %>%
  mutate(
    Model = factor(Model, levels = c(1, 2, 3), labels = c("Model 1", "Model 2", "Model 3")),
    N = factor(N, levels = c(1, 2, 3, 4), labels = c("N = 500", "N = 1000", "N = 2500", "N = 5000")),
    Mixing_proportion = factor(Mixing_proportion, levels = c(1, 2), labels = c("Even Proportions", "Uneven Proportions"))
  )

```

#### Step 5: Part 3 Calculate Violation Percentages per Condition

```{r}
#| label: "calculate-violations"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Step 6 Part 2: Summarize Violations and Adjust for Errors

# 1. Summarize violations per condition
violation_summary <- final_data_with_actuals %>%
  mutate(
    Any_Violation = ifelse(is.na(Any_Violation), 0, Any_Violation),
    ErrorFlag = ifelse(is.na(ErrorFlag), 0, ErrorFlag)  # Ensure no missing values for ErrorFlag
  ) %>%
  group_by(FileName, Model, Population, N, Mixing_proportion, Lambda_values) %>%
  summarize(
    Total_Rows = n(),                                # Total runs
    Total_Violations = sum(Any_Violation, na.rm = TRUE), # Total violations
    Total_Errors = sum(ErrorFlag, na.rm = TRUE),         # Total errors from ErrorFlag
    Percentage_Violations = (Total_Violations / Total_Rows) * 100, # % violations
    .groups = "drop"
  ) %>%
  # 2. Calculate Replications Needed for label switching
  mutate(
    N_numeric = as.numeric(gsub("N = ", "", as.character(N))), 
    Additional_Runs = (500 + Total_Violations) * (Percentage_Violations / 100), 
    Replications_Needed = ceiling(500 + Total_Violations + Additional_Runs + 20),
    Replications_Needed = if_else(Replications_Needed < 500, 500, Replications_Needed),
    ErrorRate = Total_Errors / Total_Rows,  # Calculate ErrorRate directly
    Adjusted_Replications_Needed = ceiling(Replications_Needed / (1 - ErrorRate)),
    Adjusted_Replications_Needed = if_else(Adjusted_Replications_Needed < 500, 500, Adjusted_Replications_Needed)
  ) %>%
  select(
    FileName, Model, Population, N, N_numeric, Mixing_proportion,
    Lambda_values, Total_Rows, Total_Violations, Total_Errors,
    ErrorRate, Percentage_Violations, Replications_Needed,
    Adjusted_Replications_Needed
  )

```

#### Step 5: Part 4 Summarize Violations

```{r}

#| label: "summarize-violations"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true


# Update violation_summary to include TPs, Mix, and adjusted replications
violation_summary <- violation_summary %>%
  mutate(
    # Transition Probabilities based on Population
    TPs = case_when(
      Population == ".800" ~ 3.179,
      Population == ".200" ~ 0.407,
      TRUE ~ NA_real_
    ),
    
    # Numeric Mix column
    Mix = case_when(
      Mixing_proportion == "Even Proportions" ~ 1,
      Mixing_proportion == "Uneven Proportions" ~ 2,
      TRUE ~ NA_integer_
    )
  )

# Function to create datasets based on model and lambda values
create_combined_model_data <- function(data, model, lambda_values) {
  data %>%
    filter(Model == model, Lambda_values %in% lambda_values) %>%
    select(
      `Transition Probability` = Population,             
      TPs,                                    # Numeric transition probabilities
      N,                                      # Categorical sample size
      N_numeric,                              # Numeric sample size
      `Mixing Proportion` = Mixing_proportion, # Even/Uneven proportions
      Mix,                                    # Numeric mix column
      Lambda = Lambda_values,                 # Lambda column
      `Total Mplus Runs` = Total_Rows,        # Total rows
      `Total Violations` = Total_Violations,  # Total Violations
      `% of Violations` = Percentage_Violations, # Violation percentage
      `Total Errors` = Total_Errors,           #Total Eerrors
      `Error Rate` = ErrorRate,               # Error Rate
      `Replications Needed` = Replications_Needed, # Original replications needed
       Adjusted_Replications_Needed           # Final replications
    )
}

# Datasets with multiple lambdas
model1_data <- create_combined_model_data(violation_summary, "Model 1", c("0.3", "0.5", "0.7", "0.9"))
model2_data <- create_combined_model_data(violation_summary, "Model 2", c("0.3", "0.5", "0.7", "0.9"))
model3_data <- create_combined_model_data(violation_summary, "Model 3", c("0.3", "0.5", "0.7", "0.9"))

# Datasets with single lambdas
model4_data <- create_combined_model_data(violation_summary, "Model 1", c("A"))
model5_data <- create_combined_model_data(violation_summary, "Model 1", c("B"))
model6_data <- create_combined_model_data(violation_summary, "Model 1", c("C"))
model7_data <- create_combined_model_data(violation_summary, "Model 1", c("D"))

model8_data <- create_combined_model_data(violation_summary, "Model 2", c("A"))
model9_data <- create_combined_model_data(violation_summary, "Model 2", c("B"))
model10_data <- create_combined_model_data(violation_summary, "Model 2", c("C"))
model11_data <- create_combined_model_data(violation_summary, "Model 2", c("D"))

model12_data <- create_combined_model_data(violation_summary, "Model 3", c("A"))
model13_data <- create_combined_model_data(violation_summary, "Model 3", c("B"))
model14_data <- create_combined_model_data(violation_summary, "Model 3", c("C"))
model15_data <- create_combined_model_data(violation_summary, "Model 3", c("D"))

# Define a function to create `gt` tables for models
create_gt_table <- function(data, model, Lambda) {
  data %>%
    gt() %>%
    tab_header(
      title = paste(model, ": Monte Carlo Results"),
      subtitle = paste("Lambda =", paste(Lambda, collapse = ", "), "- Label Switching and Errors Adjusted")
    ) %>%
    fmt_number(
      columns = c(`% of Violations`, `Error Rate`),
      decimals = 2
    ) %>%
    cols_align(align = "center", columns = everything()) %>%
    tab_options(
      table.font.size = "small",
      heading.title.font.size = "medium",
      heading.subtitle.font.size = "small"
    ) %>%
    tab_style(style = cell_text(align = "center"), locations = cells_column_labels(everything()))
}

# Generate tables for each data frame
model1_table <- create_gt_table(model1_data, "Model 1", c("0.3", "0.5", "0.7", "0.9"))
model2_table <- create_gt_table(model2_data, "Model 2", c("0.3", "0.5", "0.7", "0.9"))
model3_table <- create_gt_table(model3_data, "Model 3", c("0.3", "0.5", "0.7", "0.9"))

model4_table <- create_gt_table(model4_data, "Model 1", c("A"))
model5_table <- create_gt_table(model5_data, "Model 1", c("B"))
model6_table <- create_gt_table(model6_data, "Model 1", c("C"))
model7_table <- create_gt_table(model7_data, "Model 1", c("D"))

model8_table <- create_gt_table(model8_data, "Model 2", c("A"))
model9_table <- create_gt_table(model9_data, "Model 2", c("B"))
model10_table <- create_gt_table(model10_data, "Model 2", c("C"))
model11_table <- create_gt_table(model11_data, "Model 2", c("D"))

model12_table <- create_gt_table(model12_data, "Model 3", c("A"))
model13_table <- create_gt_table(model13_data, "Model 3", c("B"))
model14_table <- create_gt_table(model14_data, "Model 3", c("C"))
model15_table <- create_gt_table(model15_data, "Model 3", c("D"))


# Print each table by name
model1_table
model2_table
model3_table
model4_table
model5_table
model6_table
model7_table
model8_table
model9_table
model10_table
model11_table
model12_table
model13_table
model14_table
model15_table

```

#### Step 5: Part 4 Summarize Violations

*Create Iterator files with adjusted_replications_needed for part two SIMULATION that **ONLY** have cases with errors.*

```{r}
# Filter violation_summary for conditions with both non-zero violations and non-zero error rates
filtered_violation_summary <- violation_summary %>%
  filter(Percentage_Violations > 0, ErrorRate > 0)

# Ensure the `Transition Probability` column is consistently handled
filtered_violation_summary <- filtered_violation_summary %>%
  mutate(
    # Transition Probabilities based on Population
    TPs = case_when(
      Population == ".800" ~ 3.179,
      Population == ".200" ~ 0.407,
      TRUE ~ NA_real_
    ),
    
    # Numeric Mix column
    Mix = case_when(
      Mixing_proportion == "Even Proportions" ~ 1,
      Mixing_proportion == "Uneven Proportions" ~ 2,
      TRUE ~ NA_integer_
    )
  ) %>%
  rename(
    `Transition Probability` = Population # Rename column for clarity
  )

# Proceed with table creation as per the earlier code


# Function to create datasets based on model and lambda values
create_combined_model_data <- function(data, model, lambda_values) {
  data %>%
    filter(Model == model, Lambda_values %in% lambda_values) %>%
    select(
      `Transition Probability`,               # Already renamed earlier
      TPs,                                    # Numeric transition probabilities
      N_numeric,                              # Sample size as numeric
      `Mixing Proportion` = Mixing_proportion, # Correct column name for Even/Uneven proportions
      Mix,                                    # Numeric mix column
      Lambda = Lambda_values,                 # Lambda column
      `Total Mplus Runs` = Total_Rows,        # Total rows
      `Total Violations` = Total_Violations,  # Total Violations
      `% of Violations` = Percentage_Violations, # Violation percentage
      `Error Rate` = ErrorRate,               # Error Rate
      `Replications Needed` = Replications_Needed, # Original replications needed
      Adjusted_Replications_Needed            # Final replications
    )
}


# Datasets with multiple lambdas
model1_data <- create_combined_model_data(filtered_violation_summary, "Model 1", c("0.3", "0.5", "0.7", "0.9"))
model2_data <- create_combined_model_data(filtered_violation_summary, "Model 2", c("0.3", "0.5", "0.7", "0.9"))
model3_data <- create_combined_model_data(filtered_violation_summary, "Model 3", c("0.3", "0.5", "0.7", "0.9"))

# Datasets with single lambdas
model4_data <- create_combined_model_data(filtered_violation_summary, "Model 1", c("A"))
model5_data <- create_combined_model_data(filtered_violation_summary, "Model 1", c("B"))
model6_data <- create_combined_model_data(filtered_violation_summary, "Model 1", c("C"))
model7_data <- create_combined_model_data(filtered_violation_summary, "Model 1", c("D"))

model8_data <- create_combined_model_data(filtered_violation_summary, "Model 2", c("A"))
model9_data <- create_combined_model_data(filtered_violation_summary, "Model 2", c("B"))
model10_data <- create_combined_model_data(filtered_violation_summary, "Model 2", c("C"))
model11_data <- create_combined_model_data(filtered_violation_summary, "Model 2", c("D"))

model12_data <- create_combined_model_data(filtered_violation_summary, "Model 3", c("A"))
model13_data <- create_combined_model_data(filtered_violation_summary, "Model 3", c("B"))
model14_data <- create_combined_model_data(filtered_violation_summary, "Model 3", c("C"))
model15_data <- create_combined_model_data(filtered_violation_summary, "Model 3", c("D"))

# Function to generate a gt table for display
create_gt_table <- function(data, model, lambda) {
  data %>%
    gt() %>%
    tab_header(
      title = paste(model, ": Monte Carlo Results (Filtered)"),
      subtitle = paste("Lambda =", paste(lambda, collapse = ", "), "- Label Switching and Errors Included")
    ) %>%
    cols_align(align = "center", columns = everything()) %>%
    tab_options(data_row.padding = px(4)) %>%
    tab_style(style = cell_text(align = "center"), locations = cells_column_labels(everything()))
}

# Generate tables for each data frame
model1_table <- create_gt_table(model1_data, "Model 1", c("0.3", "0.5", "0.7", "0.9"))
model2_table <- create_gt_table(model2_data, "Model 2", c("0.3", "0.5", "0.7", "0.9"))
model3_table <- create_gt_table(model3_data, "Model 3", c("0.3", "0.5", "0.7", "0.9"))

model4_table <- create_gt_table(model4_data, "Model 1", c("A"))
model5_table <- create_gt_table(model5_data, "Model 1", c("B"))
model6_table <- create_gt_table(model6_data, "Model 1", c("C"))
model7_table <- create_gt_table(model7_data, "Model 1", c("D"))

model8_table <- create_gt_table(model8_data, "Model 2", c("A"))
model9_table <- create_gt_table(model9_data, "Model 2", c("B"))
model10_table <- create_gt_table(model10_data, "Model 2", c("C"))
model11_table <- create_gt_table(model11_data, "Model 2", c("D"))

model12_table <- create_gt_table(model12_data, "Model 3", c("A"))
model13_table <- create_gt_table(model13_data, "Model 3", c("B"))
model14_table <- create_gt_table(model14_data, "Model 3", c("C"))
model15_table <- create_gt_table(model15_data, "Model 3", c("D"))

# Print each table by name
model1_table
model2_table
model3_table
model4_table
model5_table
model6_table
model7_table
model8_table
model9_table
model10_table
model11_table
model12_table
model13_table
model14_table
model15_table


```

# PART 2:

#### Objective

Rerun Analysis *with VARIED NUMBER OF REPLICATIONS to meet the 500 number threshold*

## Model 1: Simulation SetupÂ 

We will now run a Monte Carlo simulation for Model 2. The simulation will iterate over different combinations of sample sizes, transition probabilities, lamdas, and mixing proportion components. The following code sets up the cluster for parallel processing and defines the function to run the simulation.

```{r,eval = FALSE}
#| label: "rilta-lta-simulation-Model 1b"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true


  # Define the Mplus object with the dynamic replications
rilta_lta_func <- function(N_numeric, TPs, Lambda, Mix, Adjusted_Replications_Needed) {
  
  # Step 2.1: Construct the MODELPOPULATION argument based on the value of 'mix'
  MODELPOPULATION <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      
       f by u11-u15*{Lambda} (p1-p5)
            u21-u25*{Lambda} (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;

       f by u11-u15*{Lambda} (p1-p5)
            u21-u25*{Lambda} (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  }

  # Step 2.2: Construct the MODEL argument based on the value of 'mix'
  MODEL <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2: 	
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2: 	
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  }

  # Step 2.3: Construct the MODELCONSTRAINT argument based on the value of 'TPs'
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);

      
    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
      
    ")
  }

  # Step 3: Construct the Mplus object
  RILTA_LTA <- mplusObject(
    TITLE = glue("RILTA_LTA_M1_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_{Lambda}"),
    MONTECARLO = glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N_numeric};
      SEED = 07252005;
      NREPS = {Adjusted_Replications_Needed};
      !SAVE = repM1*.dat;
      RESULTS = RILTA_LTA_M1_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_{Lambda}.csv;"),
    
    
    ANALYSIS = "TYPE = MIXTURE;
      algorithm = integration;
      STARTS = 50 10;
      processors = 24;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Step 4: Run Mplus model
  RILTA_LTA_Model <- mplusModeler(
    RILTA_LTA, 
    dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', glue("RILTA_LTA_M1_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_{Lambda}.dat")),
    modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', "RILTA_LTA_M1_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_{Lambda}.inp")),
    check = TRUE, run = TRUE, hashfilename = FALSE
  )
  return(RILTA_LTA_Model)
}

library(parallel)

# Start the cluster
num_cores <- detectCores() - 1

# Step 2: Select the cluster type based on the system (PSOCK for Windows, FORK for macOS/Linux)
cluster_type <- ifelse(.Platform$OS.type == "windows", "PSOCK", "FORK")


cl <- makeCluster(num_cores, type = cluster_type)

# Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func", "model1_data", "here", "glue", "mplusModeler", "mplusObject")))

# Ensure required libraries are loaded on each node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(model1_data), function(i) {
  rilta_lta_func(
    model1_data$N_numeric[i], 
    model1_data$TPs[i], 
    model1_data$Lambda[i], 
    model1_data$Mix[i],  
    model1_data$Replications_Needed[i]
  )
})

# Stop the cluster after the simulation
stopCluster(cl)
```

## Model 2

We will now run a Monte Carlo simulation for Model 2. This simulation will iterate over different combinations of sample sizes, transition probabilities, and mixture components using the logits form the probability plot of Model 2. The following code sets up the cluster for parallel processing and defines the function to run the simulation.

```{r, eval = FALSE}

#| label: "rilta-lta-simulation-Model 2b"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true


  # Define the Mplus object with the dynamic replications
rilta_lta_func2 <- function(N_numeric, TPs, Lambda, Mix, Replications_Needed) {
  
    # Construct the MODELPOPULATION argument based on the value of mix
  MODELPOPULATION <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
       
       f by u11-u15*{Lambda} (p1-p5)
            u21-u25*{Lambda} (p1-p5);
        f@1;
        [f@0];
        
        MODEL POPULATION-c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
       ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      
       f by u11-u15*{Lambda} (p1-p5)
            u21-u25*{Lambda} (p1-p5);
        f@1;
        [f@0];
        
     MODEL POPULATION-c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
       ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

     MODEL c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
	      ")      
      
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	      

     MODEL c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
	      ")      
  }
  
  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  }
  
  RILTA_LTA2 <- mplusObject(
    TITLE = glue("Generate RILTA_LTA_M2_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_{Lambda}"),

    MONTECARLO =
      glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N_numeric};
      SEED = 07252005;
      NREPS = {Adjusted_Replications_Needed};
      !SAVE = repM2*.dat;
      RESULTS = RILTA_LTA_M2_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_{Lambda}.csv;"),
    
    
    ANALYSIS = "TYPE = MIXTURE;
      algorithm = integration;
      STARTS = 50 10;
      processors = 24;
      logcriterion=0.00001;
      mconv=0.00001;",

    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_LTA_Model2<- mplusModeler(RILTA_LTA2, 
                                   dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', glue("RILTA_LTA_M2_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_{Lambda}.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', "RILTA_LTA_M2_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_{Lambda}.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_LTA_Model2)
}

library(parallel)

# Start the cluster
num_cores <- detectCores() - 1

# Step 2: Select the cluster type based on the system (PSOCK for Windows, FORK for macOS/Linux)
cluster_type <- ifelse(.Platform$OS.type == "windows", "PSOCK", "FORK")


cl <- makeCluster(num_cores, type = cluster_type)

# Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func2", "model2_data", "here", "glue", "mplusModeler", "mplusObject")))

# Ensure required libraries are loaded on each node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(model2_data), function(i) {
  rilta_lta_func2(
    model2_data$N_numeric[i], 
    model2_data$TPs[i], 
    model2_data$Lambda[i], 
    model2_data$Mix[i],  
    model2_data$Replications_Needed[i]
  )
})

# Stop the cluster after the simulation
stopCluster(cl)
```

## Model 3

We will now run a Monte Carlo simulation for Model 3. This simulation will iterate over different combinations of sample sizes, transition probabilities, and mixture components using the logits form the probability plot for Model 3. The following code sets up the cluster for parallel processing and defines the function to run the simulation.

```{r, eval = FALSE}

#| label: "rilta-lta-simulation-Model 3b"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

  # Define the Mplus object with the dynamic replications
rilta_lta_func3 <- function(N_numeric, TPs, Lambda, Mix, Replications_Needed) {
  
    # Construct the MODELPOPULATION argument based on the value of mix
  MODELPOPULATION <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11-u15*{Lambda} (p1-p5)
            u21-u25*{Lambda} (p1-p5);
        f@1;
        [f@0];
          
        MODEL POPULATION-c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
       ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11-u15*{Lambda} (p1-p5)
            u21-u25*{Lambda} (p1-p5);
        f@1;
        [f@0];
              
     MODEL POPULATION-c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
       ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

     MODEL c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
	      ")      
      
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	      

     MODEL c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
	      ")      
  }
    
  
  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  }
  
  RILTA_LTA3 <- mplusObject(
    TITLE = glue("Generate RILTA_LTA_M3_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_{Lambda}"),

    MONTECARLO =
      glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N_numeric};
      SEED = 07252005;
      NREPS = {Adjusted_Replications_Needed};
      !SAVE = repM3*.dat;
      RESULTS = RILTA_LTA_M3_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_{Lambda}.csv;"),
    
    
    ANALYSIS = "TYPE = MIXTURE;
      algorithm = integration;
      STARTS = 50 10;
      processors = 24;
      logcriterion=0.00001;
      mconv=0.00001;",

    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_LTA_Model3<- mplusModeler(RILTA_LTA3, 
                                   dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', glue("RILTA_LTA_M3_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_{Lambda}.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', "RILTA_LTA_M3_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_{Lambda}.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_LTA_Model3)
}

library(parallel)

# Start the cluster
num_cores <- detectCores() - 1

# Step 2: Select the cluster type based on the system (PSOCK for Windows, FORK for macOS/Linux)
cluster_type <- ifelse(.Platform$OS.type == "windows", "PSOCK", "FORK")


cl <- makeCluster(num_cores, type = cluster_type)

# Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func3", "model3_data", "here", "glue", "mplusModeler", "mplusObject")))

# Ensure required libraries are loaded on each node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(model3_data), function(i) {
  rilta_lta_func3(
    model3_data$N_numeric[i], 
    model3_data$TPs[i], 
    model3_data$Lambda[i], 
    model3_data$Mix[i],  
    model3_data$Replications_Needed[i]
  )
})

# Stop the cluster after the simulation
stopCluster(cl)
```

## Model 4: Varied Lambda Pattern A

```{r,message=FALSE, warning=FALSE, eval = FALSE}
#| label: "rilta-lta-simulation-Model 4b"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true




  # Define the Mplus object with the dynamic replications
rilta_lta_func4 <- function(N_numeric, TPs, Mix, Replications_Needed) {
  
  # Construct the MODELPOPULATION argument based on the value of mix
  MODELPOPULATION <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      
      	
       f by u11*.1 u12*.1 u13*.1 u14*.2 u15*1 (p1-p5)
            u21*.1 u22*.1 u23*.1 u24*.2 u25*1 (p1-p5);
        f@1;
        [f@0];
        
        
      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;

      	
       f by u11*.1 u12*.1 u13*.1 u14*.2 u15*1 (p1-p5)
            u21*.1 u22*.1 u23*.1 u24*.2 u25*1 (p1-p5);
        f@1;
        [f@0];
        
        
      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2: 	
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2: 	
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  }

  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      

    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      

    ")
  }

  # Construct the Mplus object
  RILTA_LTA4 <- mplusObject(
    TITLE = glue("RILTA_LTA_M1_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_A"),
    MONTECARLO = glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N_numeric};
      SEED = 07252005;
      NREPS = {Adjusted_Replications_Needed};
      !SAVE = repM4*.dat;
      RESULTS = RILTA_LTA_M1_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_A.csv;"),
    
    
    ANALYSIS = "TYPE = MIXTURE;
      algorithm = integration;
      STARTS = 50 10;
      processors = 24;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_LTA_Model4<- mplusModeler(RILTA_LTA4, 
                                   dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', glue("RILTA_LTA_M1_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_A.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', "RILTA_LTA_M1_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_A.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_LTA_Model4)
}

library(parallel)

# Start the cluster
num_cores <- detectCores() - 1

# Step 2: Select the cluster type based on the system (PSOCK for Windows, FORK for macOS/Linux)
cluster_type <- ifelse(.Platform$OS.type == "windows", "PSOCK", "FORK")

cl <- makeCluster(num_cores, type = cluster_type)

# Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func4", "model4_data", "here", "glue", "mplusModeler", "mplusObject")))

# Ensure required libraries are loaded on each node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(model4_data), function(i) {
  rilta_lta_func4(
    model4_data$N_numeric[i], 
    model4_data$TPs[i], 
    model4_data$Mix[i],  
    model4_data$Replications_Needed[i]
  )
})

# Stop the cluster after the simulation
stopCluster(cl)
```

## Model 5: Varied Lambda Pattern B

```{r,message=FALSE, warning=FALSE, eval = FALSE}
#| label: "rilta-lta-simulation-Model 5b"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true


  # Define the Mplus object with the dynamic replications
rilta_lta_func5 <- function(N_numeric, TPs, Mix, Replications_Needed) {
  
  # Construct the MODELPOPULATION argument based on the value of mix
  MODELPOPULATION <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
        	
       f by u11*.3 u12*.2 u13*.3 u14*.7 u15*1 (p1-p5)
            u21*.3 u22*.2 u23*.3 u24*.7 u25*1 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;

      	
       f by u11*.3 u12*.2 u13*.3 u14*.7 u15*1 (p1-p5)
            u21*.3 u22*.2 u23*.3 u24*.7 u25*1 (p1-p5);
        f@1;
        [f@0];
        
        
      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2: 	
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2: 	
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  }

  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    
      
    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  }

  # Construct the Mplus object
  RILTA_LTA5 <- mplusObject(
    TITLE = glue("RILTA_LTA_M1_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_B"),
    MONTECARLO = glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N_numeric};
      SEED = 07252005;
      NREPS = {Adjusted_Replications_Needed};
      !SAVE = repM5*.dat;
      RESULTS = RILTA_LTA_M1_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_B.csv;"),
    
    
    ANALYSIS = "TYPE = MIXTURE;
      algorithm = integration;
      STARTS = 50 10;
      processors = 24;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_LTA_Model5<- mplusModeler(RILTA_LTA5, 
                                   dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', glue("RILTA_LTA_M1_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_B.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', "RILTA_LTA_M1_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_B.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_LTA_Model5)
}

library(parallel)

# Start the cluster
num_cores <- detectCores() - 1

# Step 2: Select the cluster type based on the system (PSOCK for Windows, FORK for macOS/Linux)
cluster_type <- ifelse(.Platform$OS.type == "windows", "PSOCK", "FORK")

cl <- makeCluster(num_cores, type = cluster_type)

# Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func5", "model5_data", "here", "glue", "mplusModeler", "mplusObject")))

# Ensure required libraries are loaded on each node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(model5_data), function(i) {
  rilta_lta_func5(
    model5_data$N_numeric[i], 
    model5_data$TPs[i], 
    model5_data$Mix[i],  
    model5_data$Replications_Needed[i]
  )
})

# Stop the cluster after the simulation
stopCluster(cl)
```

## Model 6: Varied Lambda Pattern C

```{r,message=FALSE, warning=FALSE, eval = FALSE}

#| label: "rilta-lta-simulation-Model 6b"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true


  # Define the Mplus object with the dynamic replications
rilta_lta_func6 <- function(N_numeric, TPs, Mix, Replications_Needed) {
  
  # Construct the MODELPOPULATION argument based on the value of mix
  MODELPOPULATION <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.5 u12*.5 u13*.5 u14*.6 u15*1.4 (p1-p5)
            u21*.5 u22*.5 u23*.5 u24*.6 u25*1.4 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.5 u12*.5 u13*.5 u14*.6 u15*1.4 (p1-p5)
            u21*.5 u22*.5 u23*.5 u24*.6 u25*1.4 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2: 	
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2: 	
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  }

  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      

    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
 
    ")
  }

  # Construct the Mplus object
  RILTA_LTA6 <- mplusObject(
    TITLE = glue("RILTA_LTA_M1_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_C"),
    MONTECARLO = glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N_numeric};
      SEED = 07252005;
      NREPS = {Adjusted_Replications_Needed};
      !SAVE = repM6*.dat;
      RESULTS = RILTA_LTA_M1_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_C.csv;"),
    
    
    ANALYSIS = "TYPE = MIXTURE;
      algorithm = integration;
      STARTS = 50 10;
      processors = 24;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_LTA_Model6<- mplusModeler(RILTA_LTA6, 
                                   dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', glue("RILTA_LTA_M1_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_C.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', "RILTA_LTA_M1_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_C.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_LTA_Model6)
}

library(parallel)

# Start the cluster
num_cores <- detectCores() - 1

# Step 2: Select the cluster type based on the system (PSOCK for Windows, FORK for macOS/Linux)
cluster_type <- ifelse(.Platform$OS.type == "windows", "PSOCK", "FORK")

cl <- makeCluster(num_cores, type = cluster_type)

# Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func6", "model6_data", "here", "glue", "mplusModeler", "mplusObject")))

# Ensure required libraries are loaded on each node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(model6_data), function(i) {
  rilta_lta_func6(
    model6_data$N_numeric[i], 
    model6_data$TPs[i], 
    model6_data$Mix[i],  
    model6_data$Replications_Needed[i]
  )
})

# Stop the cluster after the simulation
stopCluster(cl)
```

## Model 7: Varied Lambda Pattern D

```{r,message=FALSE, warning=FALSE, eval = FALSE}

#| label: "rilta-lta-simulation-Model 7b"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true


  # Define the Mplus object with the dynamic replications
rilta_lta_func7 <- function(N_numeric, TPs, Mix, Replications_Needed) {
  
  # Construct the MODELPOPULATION argument based on the value of mix
  MODELPOPULATION <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.5 u12*.5 u13*.5 u14*.6 u15*2.4 (p1-p5)
            u21*.5 u22*.5 u23*.5 u24*.6 u25*2.4 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.5 u12*.5 u13*.5 u14*.6 u15*2.4 (p1-p5)
            u21*.5 u22*.5 u23*.5 u24*.6 u25*.4 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  }

  # Construct the MODEL argument based on the value of Mix
  MODEL <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2: 	
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2: 	
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  }

  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      

    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      

    ")
  }

  # Construct the Mplus object
  RILTA_LTA7 <- mplusObject(
    TITLE = glue("RILTA_LTA_M1_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_D"),
    MONTECARLO = glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N_numeric};
      SEED = 07252005;
      NREPS = {Adjusted_Replications_Needed};
      !SAVE = repM7*.dat;
      RESULTS = RILTA_LTA_M1_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_D.csv;"),
    
    
    ANALYSIS = "TYPE = MIXTURE;
      algorithm = integration;
      STARTS = 50 10;
      processors = 24;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_LTA_Model7<- mplusModeler(RILTA_LTA7, 
                                   dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', glue("RILTA_LTA_M1_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_D.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', "RILTA_LTA_M1_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_D.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_LTA_Model7)
}

 library(parallel)

# Start the cluster
num_cores <- detectCores() - 1

# Step 2: Select the cluster type based on the system (PSOCK for Windows, FORK for macOS/Linux)
cluster_type <- ifelse(.Platform$OS.type == "windows", "PSOCK", "FORK")

cl <- makeCluster(num_cores, type = cluster_type)

# Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func7", "model7_data", "here", "glue", "mplusModeler", "mplusObject")))

# Ensure required libraries are loaded on each node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(model7_data), function(i) {
  rilta_lta_func7(
    model7_data$N_numeric[i], 
    model7_data$TPs[i], 
    model7_data$Mix[i],  
    model7_data$Replications_Needed[i]
  )
})

# Stop the cluster after the simulation
stopCluster(cl)
```

## Model 8: Varied Lambda Pattern A

```{r,message=FALSE, warning=FALSE, eval = FALSE}

#| label: "rilta-lta-simulation-Model 8b"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true


  # Define the Mplus object with the dynamic replications
rilta_lta_func8 <- function(N_numeric, TPs, Mix, Replications_Needed) {
  
  # Construct the MODELPOPULATION argument based on the value of mix
  MODELPOPULATION <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.1 u12*.1 u13*.1 u14*.2 u15*1 (p1-p5)
            u21*.1 u22*.1 u23*.1 u24*.2 u25*1 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.1 u12*.1 u13*.1 u14*.2 u15*1 (p1-p5)
            u21*.1 u22*.1 u23*.1 u24*.2 u25*1 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
  }

  # Construct the MODEL argument based on the value of Mix
  MODEL <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

      MODEL c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL c2: 	
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

      MODEL c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL c2: 	
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
  }

  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);

    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      

    ")
  }

  # Construct the Mplus object
  RILTA_LTA8 <- mplusObject(
    TITLE = glue("RILTA_LTA_M2_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_A"),
    MONTECARLO = glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N_numeric};
      SEED = 07252005;
      NREPS = {Adjusted_Replications_Needed};
      !SAVE = repM8*.dat;
      RESULTS = RILTA_LTA_M2_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_A.csv;"),
    
    
    ANALYSIS = "TYPE = MIXTURE;
      algorithm = integration;
      STARTS = 50 10;
      processors = 24;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_LTA_Model8<- mplusModeler(RILTA_LTA8, 
                                   dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', glue("RILTA_LTA_M2_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_A.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', "RILTA_LTA_M2_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_A.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_LTA_Model8)
}

library(parallel)

# Start the cluster
num_cores <- detectCores() - 1

# Step 2: Select the cluster type based on the system (PSOCK for Windows, FORK for macOS/Linux)
cluster_type <- ifelse(.Platform$OS.type == "windows", "PSOCK", "FORK")

cl <- makeCluster(num_cores, type = cluster_type)

# Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func8", "model8_data", "here", "glue", "mplusModeler", "mplusObject")))

# Ensure required libraries are loaded on each node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(model8_data), function(i) {
  rilta_lta_func8(
    model8_data$N_numeric[i], 
    model8_data$TPs[i], 
    model8_data$Mix[i],  
    model8_data$Replications_Needed[i]
  )
})

# Stop the cluster after the simulation
stopCluster(cl)
```

## Model 9: Varied Lambda Pattern B

```{r,message=FALSE, warning=FALSE, eval = FALSE}

#| label: "rilta-lta-simulation-Model 9b"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true


  # Define the Mplus object with the dynamic replications
rilta_lta_func9 <- function(N_numeric, TPs, Mix, Replications_Needed) {
  
  # Construct the MODELPOPULATION argument based on the value of mix
  MODELPOPULATION <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.3 u12*.2 u13*.3 u14*.7 u15*1 (p1-p5)
            u21*.3 u22*.2 u23*.3 u24*.7 u25*1 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.3 u12*.2 u13*.3 u14*.7 u15*1 (p1-p5)
            u21*.3 u22*.2 u23*.3 u24*.7 u25*1 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

      MODEL c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL c2: 	
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

      MODEL c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL c2: 	
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
  }

  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      

    ")
  }

  # Construct the Mplus object
  RILTA_LTA9 <- mplusObject(
    TITLE = glue("RILTA_LTA_M2_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_B"),
    MONTECARLO = glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N_numeric};
      SEED = 07252005;
      NREPS = {Adjusted_Replications_Needed};
      !SAVE = repM9*.dat;
      RESULTS = RILTA_LTA_M2_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_B.csv;"),
    
    ANALYSIS = "TYPE = MIXTURE;
      algorithm = integration;
      processors = 24;
      STARTS 50 10;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_LTA_Model9<- mplusModeler(RILTA_LTA9, 
                                   dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', glue("RILTA_LTA_M2_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_B.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', "RILTA_LTA_M2_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_B.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_LTA_Model9)
}

library(parallel)

# Start the cluster
num_cores <- detectCores() - 1

# Step 2: Select the cluster type based on the system (PSOCK for Windows, FORK for macOS/Linux)
cluster_type <- ifelse(.Platform$OS.type == "windows", "PSOCK", "FORK")

cl <- makeCluster(num_cores, type = cluster_type)

# Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func9", "model9_data", "here", "glue", "mplusModeler", "mplusObject")))

# Ensure required libraries are loaded on each node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(model9_data), function(i) {
  rilta_lta_func9(
    model9_data$N_numeric[i], 
    model9_data$TPs[i], 
    model9_data$Mix[i],  
    model9_data$Replications_Needed[i]
  )
})

# Stop the cluster after the simulation
stopCluster(cl)
```

## Model 10: Varied Lambda Pattern C

```{r,message=FALSE, warning=FALSE, eval = FALSE}

#| label: "rilta-lta-simulation-Model 10b"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

  # Define the Mplus object with the dynamic replications
rilta_lta_func10 <- function(N_numeric, TPs, Mix, Replications_Needed) {
  
  # Construct the MODELPOPULATION argument based on the value of mix
  MODELPOPULATION <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.5 u12*.5 u13*.5 u14*.6 u15*1.4 (p1-p5)
            u21*.5 u22*.5 u23*.5 u24*.6 u25*1.4 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.5 u12*.5 u13*.5 u14*.6 u15*1.4 (p1-p5)
            u21*.5 u22*.5 u23*.5 u24*.6 u25*1.4 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

      MODEL c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL c2: 	
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

      MODEL c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL c2: 	
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
  }

  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      

    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      

    ")
  }

  # Construct the Mplus object
  RILTA_LTA10 <- mplusObject(
    TITLE = glue("RILTA_LTA_M2_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_C"),
    MONTECARLO = glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N_numeric};
      SEED = 07252005;
      NREPS = {Adjusted_Replications_Needed};
      !SAVE = repM10*.dat;
      RESULTS = RILTA_LTA_M2_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_C.csv;"),
    
    ANALYSIS = "TYPE = MIXTURE;
      algorithm = integration;
      STARTS 50 10;
      processors = 24;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_LTA_Model10<- mplusModeler(RILTA_LTA10, 
                                   dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', glue("RILTA_LTA_M2_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_C.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', "RILTA_LTA_M2_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_C.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_LTA_Model10)
}

library(parallel)

# Start the cluster
num_cores <- detectCores() - 1

# Step 2: Select the cluster type based on the system (PSOCK for Windows, FORK for macOS/Linux)
cluster_type <- ifelse(.Platform$OS.type == "windows", "PSOCK", "FORK")

cl <- makeCluster(num_cores, type = cluster_type)

# Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func10", "model10_data", "here", "glue", "mplusModeler", "mplusObject")))

# Ensure required libraries are loaded on each node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(model10_data), function(i) {
  rilta_lta_func10(
    model10_data$N_numeric[i], 
    model10_data$TPs[i], 
    model10_data$Mix[i],  
    model10_data$Replications_Needed[i]
  )
})

# Stop the cluster after the simulation
stopCluster(cl)
```

## Model 11: Varied Lambda Pattern D

```{r,message=FALSE, warning=FALSE, eval = FALSE}

#| label: "rilta-lta-simulation-Model 11b"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true


  # Define the Mplus object with the dynamic replications
rilta_lta_func11 <- function(N_numeric, TPs, Mix, Replications_Needed) {
  
  # Construct the MODELPOPULATION argument based on the value of mix
  MODELPOPULATION <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.5 u12*.5 u13*.5 u14*.6 u15*2.4 (p1-p5)
            u21*.5 u22*.5 u23*.5 u24*.6 u25*2.4 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.5 u12*.5 u13*.5 u14*.6 u15*2.4 (p1-p5)
            u21*.5 u22*.5 u23*.5 u24*.6 u25*2.4 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

      MODEL c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL c2: 	
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

      MODEL c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL c2: 	
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
  }

  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      

    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      

    ")
  }

  # Construct the Mplus object
  RILTA_LTA11 <- mplusObject(
    TITLE = glue("RILTA_LTA_M2_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_D"),
    MONTECARLO = glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N_numeric};
      SEED = 07252005;
      NREPS = {Adjusted_Replications_Needed};
      !SAVE = repM11*.dat;
      RESULTS = RILTA_LTA_M2_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_D.csv;"),
    
    ANALYSIS = "TYPE = MIXTURE;
      algorithm = integration;
      STARTS 50 10;
      processors = 24;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_LTA_Model11<- mplusModeler(RILTA_LTA11, 
                                   dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', glue("RILTA_LTA_M2_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_D.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', "RILTA_LTA_M2_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_D.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_LTA_Model11)
}

library(parallel)

# Start the cluster
num_cores <- detectCores() - 1

# Step 2: Select the cluster type based on the system (PSOCK for Windows, FORK for macOS/Linux)
cluster_type <- ifelse(.Platform$OS.type == "windows", "PSOCK", "FORK")

cl <- makeCluster(num_cores, type = cluster_type)

# Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func11", "model11_data", "here", "glue", "mplusModeler", "mplusObject")))

# Ensure required libraries are loaded on each node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(model11_data), function(i) {
  rilta_lta_func11(
    model11_data$N_numeric[i], 
    model11_data$TPs[i], 
    model11_data$Mix[i],  
    model11_data$Replications_Needed[i]
  )
})

# Stop the cluster after the simulation
stopCluster(cl)
```

## Model 12: Varied Lambda Pattern A

```{r,message=FALSE, warning=FALSE, eval = FALSE}

#| label: "rilta-lta-simulation-Model 12b"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true


  # Define the Mplus object with the dynamic replications
rilta_lta_func12 <- function(N_numeric, TPs, Mix, Replications_Needed) {
  
    # Construct the MODELPOPULATION argument based on the value of mix
  MODELPOPULATION <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.1 u12*.1 u13*.1 u14*.2 u15*1 (p1-p5)
            u21*.1 u22*.1 u23*.1 u24*.2 u25*1 (p1-p5);
        f@1;
        [f@0];
          
        MODEL POPULATION-c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
       ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.1 u12*.1 u13*.1 u14*.2 u15*1 (p1-p5)
            u21*.1 u22*.1 u23*.1 u24*.2 u25*1 (p1-p5);
        f@1;
        [f@0];
              
     MODEL POPULATION-c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
       ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

     MODEL c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
	      ")      
      
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	      

     MODEL c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
	      ")      
  }
    
  
  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      

    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      

    ")
  }
  
  RILTA_LTA12 <- mplusObject(
    TITLE = glue("Generate RILTA_LTA_M3_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_A"),

    MONTECARLO =
      glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N_numeric};
      SEED = 07252005;
      NREPS = {Adjusted_Replications_Needed};
      !SAVE = repM12*.dat;
      RESULTS = RILTA_LTA_M3_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_A.csv;"),
    
    
    ANALYSIS = "TYPE = MIXTURE;
    Algorithm = INTEGRATION;
      STARTS = 50 10;
      processors = 24;
      logcriterion=0.00001;
      mconv=0.00001;",

    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_LTA_Model12<- mplusModeler(RILTA_LTA12, 
                                   dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', glue("RILTA_LTA_M3_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_A.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', "RILTA_LTA_M3_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_A.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_LTA_Model12)
}

library(parallel)

# Start the cluster
num_cores <- detectCores() - 1

# Step 2: Select the cluster type based on the system (PSOCK for Windows, FORK for macOS/Linux)
cluster_type <- ifelse(.Platform$OS.type == "windows", "PSOCK", "FORK")

cl <- makeCluster(num_cores, type = cluster_type)

# Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func12", "model12_data", "here", "glue", "mplusModeler", "mplusObject")))

# Ensure required libraries are loaded on each node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(model12_data), function(i) {
  rilta_lta_func12(
    model12_data$N_numeric[i], 
    model12_data$TPs[i], 
    model12_data$Mix[i],  
    model12_data$Replications_Needed[i]
  )
})

# Stop the cluster after the simulation
stopCluster(cl)
```

## Model 13: Varied Lambda Pattern B

```{r,message=FALSE, warning=FALSE, eval = FALSE}

#| label: "rilta-lta-simulation-Model 13b"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true


  # Define the Mplus object with the dynamic replications
rilta_lta_func13 <- function(N_numeric, TPs, Mix, Replications_Needed) {
  
    # Construct the MODELPOPULATION argument based on the value of mix
  MODELPOPULATION <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.3 u12*.2 u13*.3 u14*.7 u15*1 (p1-p5)
            u21*.3 u22*.2 u23*.3 u24*.7 u25*1 (p1-p5);
        f@1;
        [f@0];
          
        MODEL POPULATION-c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
       ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.3 u12*.2 u13*.3 u14*.7 u15*1 (p1-p5)
            u21*.3 u22*.2 u23*.3 u24*.7 u25*1 (p1-p5);
        f@1;
        [f@0];
              
     MODEL POPULATION-c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
       ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

     MODEL c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
	      ")      
      
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	      

     MODEL c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
	      ")      
  }
    
  
  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);

    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);

    ")
  }
  
  RILTA_LTA13 <- mplusObject(
    TITLE = glue("Generate RILTA_LTA_M3_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_B"),

    MONTECARLO =
      glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N_numeric};
      SEED = 07252005;
      NREPS = {Adjusted_Replications_Needed};
      !SAVE = repM13*.dat;
      RESULTS = RILTA_LTA_M3_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_B.csv;"),
    
    
    ANALYSIS = "TYPE = MIXTURE;
      algorithm = integration;
      STARTS = 50 10;
      processors = 24;
      logcriterion=0.00001;
      mconv=0.00001;",

    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_LTA_Model13<- mplusModeler(RILTA_LTA13, 
                                   dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', glue("RILTA_LTA_M3_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_B.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', "RILTA_LTA_M3_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_B.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_LTA_Model13)
}

library(parallel)

# Start the cluster
num_cores <- detectCores() - 1

# Step 2: Select the cluster type based on the system (PSOCK for Windows, FORK for macOS/Linux)
cluster_type <- ifelse(.Platform$OS.type == "windows", "PSOCK", "FORK")

cl <- makeCluster(num_cores, type = cluster_type)

# Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func13", "model13_data", "here", "glue", "mplusModeler", "mplusObject")))

# Ensure required libraries are loaded on each node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(model13_data), function(i) {
  rilta_lta_func13(
    model13_data$N_numeric[i], 
    model13_data$TPs[i], 
    model13_data$Mix[i],  
    model13_data$Replications_Needed[i]
  )
})

# Stop the cluster after the simulation
stopCluster(cl)
```

## Model 14: Varied Lambda Pattern C

```{r,message=FALSE, warning=FALSE, eval = FALSE}

#| label: "rilta-lta-simulation-Model 14b"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true


  # Define the Mplus object with the dynamic replications
rilta_lta_func14 <- function(N_numeric, TPs, Mix, Replications_Needed) {
  
    # Construct the MODELPOPULATION argument based on the value of mix
  MODELPOPULATION <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.5 u12*.5 u13*.5 u14*.6 u15*1.4 (p1-p5)
            u21*.5 u22*.5 u23*.5 u24*.6 u25*1.4 (p1-p5);
        f@1;
        [f@0];
          
        MODEL POPULATION-c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
       ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.3 u12*.2 u13*.3 u14*.7 u15*1 (p1-p5)
            u21*.3 u22*.2 u23*.3 u24*.7 u25*1 (p1-p5);
        f@1;
        [f@0];
              
     MODEL POPULATION-c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
       ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

     MODEL c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
	      ")      
      
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	      

     MODEL c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
	      ")      
  }
    
  
  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);

    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);

    ")
  }
  
  RILTA_LTA14 <- mplusObject(
    TITLE = glue("Generate RILTA_LTA_M3_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_B"),

    MONTECARLO =
      glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N_numeric};
      SEED = 07252005;
      NREPS = {Adjusted_Replications_Needed};
      !SAVE = repM14*.dat;
      RESULTS = RILTA_LTA_M3_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_C.csv;"),
    
    
    ANALYSIS = "TYPE = MIXTURE;
      algorithm = integration;
      STARTS = 50 10;
      processors = 24;
      logcriterion=0.00001;
      mconv=0.00001;",

    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_LTA_Model14<- mplusModeler(RILTA_LTA14, 
                                   dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', glue("RILTA_LTA_M3_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_C.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', "RILTA_LTA_M3_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_C.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_LTA_Model14)
}

library(parallel)

# Start the cluster
num_cores <- detectCores() - 1

# Step 2: Select the cluster type based on the system (PSOCK for Windows, FORK for macOS/Linux)
cluster_type <- ifelse(.Platform$OS.type == "windows", "PSOCK", "FORK")

cl <- makeCluster(num_cores, type = cluster_type)

# Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func14", "model14_data", "here", "glue", "mplusModeler", "mplusObject")))

# Ensure required libraries are loaded on each node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(model14_data), function(i) {
  rilta_lta_func14(
    model14_data$N_numeric[i], 
    model14_data$TPs[i], 
    model14_data$Mix[i],  
    model14_data$Replications_Needed[i]
  )
})

# Stop the cluster after the simulation
stopCluster(cl)
```

## Model 15: Varied Lambda Pattern D

```{r,message=FALSE, warning=FALSE, eval = FALSE}

#| label: "rilta-lta-simulation-Model 15b"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

  # Define the Mplus object with the dynamic replications
rilta_lta_func15 <- function(N_numeric, TPs, Mix, Replications_Needed) {
  
    # Step 2: Construct the MODELPOPULATION argument based on the value of mix
  MODELPOPULATION <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.5 u12*.5 u13*.5 u14*.6 u15*2.4 (p1-p5)
            u21*.5 u22*.5 u23*.5 u24*.6 u25*2.4 (p1-p5);
        f@1;
        [f@0];
          
        MODEL POPULATION-c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
       ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.5 u12*.5 u13*.5 u14*.6 u15*2.4 (p1-p5)
            u21*.5 u22*.5 u23*.5 u24*.6 u25*2.4 (p1-p5);
        f@1;
        [f@0];
              
     MODEL POPULATION-c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
       ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

     MODEL c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
	      ")      
      
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	      

     MODEL c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
	      ")      
  }
    
  
  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      

    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
 
    ")
  }
  
  RILTA_LTA15 <- mplusObject(
    TITLE = glue("Generate RILTA_LTA_M3_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_D"),

    MONTECARLO =
      glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N_numeric};
      SEED = 07252005;
      NREPS = {Adjusted_Replications_Needed};
      !SAVE = repM15*.dat;
      RESULTS = RILTA_LTA_M3_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_D.csv;"),
    
    
    ANALYSIS = "TYPE = MIXTURE;
      algorithm = integration;
      STARTS = 50 10;
      processors = 24;
      logcriterion=0.00001;
      mconv=0.00001;",

    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_LTA_Model15<- mplusModeler(RILTA_LTA15, 
                                   dataout = here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', glue("RILTA_LTA_M3_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_D.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP', "RILTA_LTA_M3_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_D.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_LTA_Model15)
}

library(parallel)

# Start the cluster
num_cores <- detectCores() - 1

# Step 2: Select the cluster type based on the system (PSOCK for Windows, FORK for macOS/Linux)
cluster_type <- ifelse(.Platform$OS.type == "windows", "PSOCK", "FORK")

cl <- makeCluster(num_cores, type = cluster_type)

# Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_lta_func15", "model15_data", "here", "glue", "mplusModeler", "mplusObject")))

# Ensure required libraries are loaded on each node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(model15_data), function(i) {
  rilta_lta_func15(
    model15_data$N_numeric[i], 
    model15_data$TPs[i], 
    model15_data$Mix[i],  
    model15_data$Replications_Needed[i]
  )
})

# Stop the cluster after the simulation
stopCluster(cl)
```

# CHECK FOR LABEL SWITCHING

### Step 6: Combine All CSV Files into One Data Frame

#### **Objective:**Â 

*Load all CSV files and combine them into a single data frame.*

```{r}
#| label: "combine-csv-files-parallel2"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true


# Step 1: Set the correct CSV directory
csv_directory <- here('Simulations', 'STUDY_2', '3_RILTA_GEN_LTA_ANALYZED_REP')

# Step 2: Source the child document
source(here('Child_Docs', 'data_scraping.R'))
```

### Step 7: Scrape Rows and Process Data

#### **Objective:**Â 

*Extract the appropriate rows from each 9-row chunk) and prepare the data for further processing.*

```{r}

#| label: "scrape-rows-process-data-parallel2"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Step 2: Process the data using the child script
source(here('Child_Docs', 'step2_f_LTA.R'))


# Assuming the data frame is named final_data_with_actuals
# Count of non-missing values
non_missing_trans_11 <- sum(!is.na(final_data_with_actuals$Trans_11))
non_missing_se_11 <- sum(!is.na(final_data_with_actuals$SE_11))

# Count of missing values
missing_trans_11 <- sum(is.na(final_data_with_actuals$Trans_11))
missing_se_11 <- sum(is.na(final_data_with_actuals$SE_11))

# Output the counts
cat("Trans_11 - Non-missing:", non_missing_trans_11, "Missing:", missing_trans_11, "\n")
cat("SE_11 - Non-missing:", non_missing_se_11, "Missing:", missing_se_11, "\n")

```

### Step 8: Convert Logits to Probabilities and Add Actual (Population) Values

#### **Objective:**Â 

*Convert the logits to probabilities and flag label switching cases*

```{r}
#| label: "convert-logits-and-flags2"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Step 3: Process the data and return results
source(here('Child_Docs', 'step_3.R'))

# The objects `final_data_with_actuals` and `violators` should now be in the global environment
```

### **Step 9: Summarize Violations**

#### **Objective**

*Calculate the percentage of violations for each file, handling missing values appropriately.*

#### Scrape Output Files for Errors for specific replications

```{r}
#| label: "summarize-errors2"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

library(parallel)

extract_errors_from_file <- function(filepath, total_replications) {
  lines <- readLines(filepath)
  results <- vector("list", total_replications)
  error_keywords <- c("NON-POSITIVE DEFINITE", "SADDLE")

  # Initialize results for every replication
  for (rep in 1:total_replications) {
    results[[rep]] <- tibble(
      FileName = basename(filepath),
      Replication = rep,
      Message = "None",
      MessageType = "None"
    )
  }

  current_replication <- NULL
  for (line in lines) {
    if (str_detect(line, "REPLICATION")) {
      current_replication <- as.integer(str_extract(line, "\\d+"))
    }

    if (!is.null(current_replication) && current_replication <= total_replications &&
        any(sapply(error_keywords, grepl, line, ignore.case = TRUE))) {
      results[[current_replication]] <- tibble(
        FileName = basename(filepath),
        Replication = current_replication,
        Message = str_trim(line),
        MessageType = "Error"
      )
    }
  }

  return(bind_rows(results))
}

# Step 2: Extract Completed Replications
extract_completed_replications <- function(filepath) {
  lines <- readLines(filepath)
  completed_line <- lines[grepl("Completed", lines, ignore.case = TRUE)]
  completed <- as.integer(str_match(completed_line, "Completed\\s+(\\d+)")[, 2])
  if (length(completed) == 0) completed <- 0
  tibble(FileName = basename(filepath), CompletedReplications = completed)
}

# Step 3: Extract Requested Replications
extract_requested_replications <- function(filepath) {
  lines <- readLines(filepath)
  requested_line <- lines[grepl("Requested", lines, ignore.case = TRUE)]
  requested <- as.integer(str_match(requested_line, "Requested\\s+(\\d+)")[, 2])
  if (length(requested) == 0) requested <- 0
  tibble(FileName = basename(filepath), RequestedReplications = requested)
}

calculate_replication_summary <- function(error_summary, completed_replications, requested_replications) {
  summary <- error_summary %>%
    group_by(FileName) %>%
    summarise(
      ErrorReplications = n_distinct(Replication[MessageType == "Error"]),
      .groups = "drop"
    )

  full_summary <- requested_replications %>%
    left_join(completed_replications, by = "FileName") %>%
    left_join(summary, by = "FileName") %>%
    mutate(
      ErrorReplications = coalesce(ErrorReplications, 0),
      GoodReplications = CompletedReplications - ErrorReplications,
      ErrorRate = if_else(CompletedReplications > 0, (ErrorReplications / CompletedReplications) * 100, 0)
    ) %>%
    select(FileName, RequestedReplications, CompletedReplications, ErrorReplications, GoodReplications, ErrorRate)

  full_summary
}

# Step 4: Parallelized Processing (Windows/Mac/Linux Compatible)
output_folder <- "3_RILTA_GEN_LTA_ANALYZED_REP"  # Adjust to your folder path
file_list <- list.files(output_folder, pattern = "\\.out$", full.names = TRUE)

# Step 5: Detect OS and Set Up Cluster
cluster_type <- ifelse(.Platform$OS.type == "windows", "PSOCK", "FORK")
num_cores <- detectCores() - 1  # Use all but one core
cl <- makeCluster(num_cores, type = cluster_type)

# Export necessary libraries and functions to the cluster
invisible(clusterExport(cl, c("extract_errors_from_file", "extract_completed_replications", "extract_requested_replications")))
invisible(clusterEvalQ(cl, library(tidyverse)))

# Step 6: Parallel Processing
# Calculate completed replications first
completed_rep_list <- parLapply(cl, file_list, extract_completed_replications)

# Extract errors while passing the total number of completed replications to the function
error_summary <- bind_rows(mapply(function(filepath, completed_data) {
  extract_errors_from_file(filepath, completed_data$CompletedReplications)
}, file_list, completed_rep_list, SIMPLIFY = FALSE))

completed_replications <- bind_rows(parLapply(cl, file_list, extract_completed_replications))
requested_replications <- bind_rows(parLapply(cl, file_list, extract_requested_replications))

# Stop the cluster
stopCluster(cl)

# Step 7: Calculate Replication Summary
replication_summary <- calculate_replication_summary(error_summary, completed_replications, requested_replications)

# Step 8: Create and Display the Table with Error Rate
replication_summary_table <- replication_summary %>%
  gt() %>%
  tab_header(
    title = "Replication Summary",
    subtitle = paste0("Folder: ", output_folder)
  ) %>%
  fmt_number(columns = c(CompletedReplications, RequestedReplications, ErrorReplications, GoodReplications, ErrorRate), decimals = 2) %>%
  cols_label(
    FileName = "File Name",
    CompletedReplications = "Completed Replications",
    RequestedReplications = "Requested Replications",
    ErrorReplications = "Replications with Errors",
    GoodReplications = "Good Replications",
    ErrorRate = "Error Rate (%)"
  ) %>%
  tab_options(
    table.font.size = "small",
    heading.title.font.size = "medium",
    heading.subtitle.font.size = "small"
  )

# Display the table
replication_summary_table

completed_replications <- completed_replications %>%
  mutate(FileName = str_replace(FileName, "\\.out$", ""),
         FileName = tolower(FileName),
         FileName = str_trim(FileName))

error_summary <- error_summary %>%
  mutate(FileName = str_replace(FileName, "\\.out$", ""),
         FileName = tolower(FileName),
         FileName = str_trim(FileName))

final_data_with_actuals <- final_data_with_actuals %>%
  mutate(FileName = tolower(FileName),
         FileName = str_trim(FileName))

replication_summary <- replication_summary %>%
  mutate(FileName = str_replace(FileName, "\\.out$", ""),
         FileName = tolower(FileName),
         FileName = str_trim(FileName))

cat("Rows in final_data_with_actuals:", nrow(final_data_with_actuals), "\n")
# Output the final number of rows to confirm data handling
cat("Number of rows in error_summary: ", nrow(error_summary), "\n")
cat("Number of rows in replication_summary: ", nrow(replication_summary), "\n")

```

#### Step 9: Part 1 Merge errors with main data

```{r}
#| label: "merge-errors2"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Ensure consistent column formats and remove .out and .csv extensions
error_summary <- error_summary %>%
  mutate(
    FileName = tolower(str_trim(gsub("\\.out$|\\.csv$", "", FileName))), # Remove extensions and standardize FileName
    Replication = as.character(Replication) # Convert Replication to character
  )

final_data_with_actuals <- final_data_with_actuals %>%
  mutate(
    FileName = tolower(str_trim(gsub("\\.out$|\\.csv$", "", FileName))), # Remove extensions and standardize FileName
    Replication = as.character(Replication) # Convert Replication to character
  )

# Add a new column to flag errors
error_summary <- error_summary %>%
  mutate(ErrorFlag = if_else(Message == "None", 0, 1))


# Merge ErrorFlag into final_data_with_actuals
final_data_with_actuals <- final_data_with_actuals %>%
  left_join(error_summary %>% select(FileName, Replication, ErrorFlag),
            by = c("FileName", "Replication"))
```

#### Step 9: Part 2 Create Column Names from the Filename

```{r}
#| label: "prepare-data-for-plotting-bias2"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true


# Add new columns based on the information in the FileName
final_data_with_actuals <- final_data_with_actuals %>%
  mutate(
    Model = case_when(
      grepl("m1", FileName) ~ "1",
      grepl("m2", FileName) ~ "2",
      grepl("m3", FileName) ~ "3",
      TRUE ~ NA_character_
    ),
    N = case_when(
      grepl("n_5000", FileName) ~ 4,  # Convert to factor level 4
      grepl("n_500", FileName) ~ 1,   # Convert to factor level 1
      grepl("n_1000", FileName) ~ 2,  # Convert to factor level 2
      grepl("n_2500", FileName) ~ 3,  # Convert to factor level 3
      TRUE ~ NA_integer_
    ),
    Mixing_proportion = case_when(
      grepl("m_1", FileName) ~ 1,  # Even Class Proportions as factor level 1
      grepl("m_2", FileName) ~ 2,  # Uneven Proportions as factor level 2
      TRUE ~ NA_integer_
    ),
    Lambda_values = case_when(
      grepl("l_0.3", FileName) ~ "0.3",
      grepl("l_0.5", FileName) ~ "0.5",
      grepl("l_0.7", FileName) ~ "0.7",
      grepl("l_0.9", FileName) ~ "0.9",
      grepl("l_a", FileName) ~ "A",
      grepl("l_b", FileName) ~ "B",
      grepl("l_c", FileName) ~ "C",
      grepl("l_d", FileName) ~ "D",
      TRUE ~ NA_character_
    ),
    # Add Population column based on FileName and convert it to a factor with formatted labels
    Population = case_when(
      grepl("tp_0.407", FileName) ~ ".200",
      grepl("tp_3.179", FileName) ~ ".800",
      TRUE ~ NA_character_
    )
  )

# Convert N, Mixing_proportion, and Model columns to factors
final_data_with_actuals <- final_data_with_actuals %>%
  mutate(
    Model = factor(Model, levels = c(1, 2, 3), labels = c("Model 1", "Model 2", "Model 3")),
    N = factor(N, levels = c(1, 2, 3, 4), labels = c("N = 500", "N = 1000", "N = 2500", "N = 5000")),
    Mixing_proportion = factor(Mixing_proportion, levels = c(1, 2), labels = c("Even Proportions", "Uneven Proportions"))
  )

```

#### Step 9: Part 3 Calculate Violation Percentages per Condition

```{r}
#| label: "calculate-violations2"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Step 6 Part 2: Summarize Violations and Adjust for Errors

# 1. Summarize violations per condition
violation_summary <- final_data_with_actuals %>%
  mutate(
    Any_Violation = ifelse(is.na(Any_Violation), 0, Any_Violation),
    ErrorFlag = ifelse(is.na(ErrorFlag), 0, ErrorFlag)  # Ensure no missing values for ErrorFlag
  ) %>%
  group_by(FileName, Model, Population, N, Mixing_proportion, Lambda_values) %>%
  summarize(
    Total_Rows = n(),                                # Total runs
    Total_Violations = sum(Any_Violation, na.rm = TRUE), # Total violations
    Total_Errors = sum(ErrorFlag, na.rm = TRUE),         # Total errors from ErrorFlag
    Percentage_Violations = (Total_Violations / Total_Rows) * 100, # % violations
    .groups = "drop"
  ) %>%
  # 2. Calculate Replications Needed for label switching
  mutate(
    N_numeric = as.numeric(gsub("N = ", "", as.character(N))), 
    Additional_Runs = (500 + Total_Violations) * (Percentage_Violations / 100), 
    Replications_Needed = ceiling(500 + Total_Violations + Additional_Runs + 20),
    Replications_Needed = if_else(Replications_Needed < 500, 500, Replications_Needed),
    ErrorRate = Total_Errors / Total_Rows,  # Calculate ErrorRate directly
    Adjusted_Replications_Needed = ceiling(Replications_Needed / (1 - ErrorRate)),
    Adjusted_Replications_Needed = if_else(Adjusted_Replications_Needed < 500, 500, Adjusted_Replications_Needed)
  ) %>%
  select(
    FileName, Model, Population, N, N_numeric, Mixing_proportion,
    Lambda_values, Total_Rows, Total_Violations, Total_Errors,
    ErrorRate, Percentage_Violations, Replications_Needed,
    Adjusted_Replications_Needed
  )

```

#### Step 9: Part 4 Summarize Violations

```{r}

#| label: "summarize-errors-and-violations2"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true


# Update violation_summary to include TPs, Mix, and adjusted replications
violation_summary <- violation_summary %>%
  mutate(
    # Transition Probabilities based on Population
    TPs = case_when(
      Population == ".800" ~ 3.179,
      Population == ".200" ~ 0.407,
      TRUE ~ NA_real_
    ),
    
    # Numeric Mix column
    Mix = case_when(
      Mixing_proportion == "Even Proportions" ~ 1,
      Mixing_proportion == "Uneven Proportions" ~ 2,
      TRUE ~ NA_integer_
    )
  )

# Function to create datasets based on model and lambda values
create_combined_model_data <- function(data, model, lambda_values) {
  data %>%
    filter(Model == model, Lambda_values %in% lambda_values) %>%
    select(
      `Transition Probability` = Population,             
      TPs,                                    # Numeric transition probabilities
      N,                                      # Categorical sample size
      N_numeric,                              # Numeric sample size
      `Mixing Proportion` = Mixing_proportion, # Even/Uneven proportions
      Mix,                                    # Numeric mix column
      Lambda = Lambda_values,                 # Lambda column
      `Total Mplus Runs` = Total_Rows,        # Total rows
      `Total Violations` = Total_Violations,  # Total Violations
      `% of Violations` = Percentage_Violations, # Violation percentage
      `Total Errors` = Total_Errors,           #Total Eerrors
      `Error Rate` = ErrorRate
    )
}

# Datasets with multiple lambdas
model1_data <- create_combined_model_data(violation_summary, "Model 1", c("0.3", "0.5", "0.7", "0.9"))
model2_data <- create_combined_model_data(violation_summary, "Model 2", c("0.3", "0.5", "0.7", "0.9"))
model3_data <- create_combined_model_data(violation_summary, "Model 3", c("0.3", "0.5", "0.7", "0.9"))

# Datasets with single lambdas
model4_data <- create_combined_model_data(violation_summary, "Model 1", c("A"))
model5_data <- create_combined_model_data(violation_summary, "Model 1", c("B"))
model6_data <- create_combined_model_data(violation_summary, "Model 1", c("C"))
model7_data <- create_combined_model_data(violation_summary, "Model 1", c("D"))

model8_data <- create_combined_model_data(violation_summary, "Model 2", c("A"))
model9_data <- create_combined_model_data(violation_summary, "Model 2", c("B"))
model10_data <- create_combined_model_data(violation_summary, "Model 2", c("C"))
model11_data <- create_combined_model_data(violation_summary, "Model 2", c("D"))

model12_data <- create_combined_model_data(violation_summary, "Model 3", c("A"))
model13_data <- create_combined_model_data(violation_summary, "Model 3", c("B"))
model14_data <- create_combined_model_data(violation_summary, "Model 3", c("C"))
model15_data <- create_combined_model_data(violation_summary, "Model 3", c("D"))

# Define a function to create `gt` tables for models
create_gt_table <- function(data, model, Lambda) {
  data %>%
    gt() %>%
    tab_header(
      title = paste(model, ": Monte Carlo Results"),
      subtitle = paste("Lambda =", paste(Lambda, collapse = ", "), "- Label Switching and Errors Adjusted")
    ) %>%
    fmt_number(
      columns = c(`% of Violations`, `Error Rate`),
      decimals = 2
    ) %>%
    cols_align(align = "center", columns = everything()) %>%
    tab_options(
      table.font.size = "small",
      heading.title.font.size = "medium",
      heading.subtitle.font.size = "small"
    ) %>%
    tab_style(style = cell_text(align = "center"), locations = cells_column_labels(everything()))
}

# Generate tables for each data frame
model1_table <- create_gt_table(model1_data, "Model 1", c("0.3", "0.5", "0.7", "0.9"))
model2_table <- create_gt_table(model2_data, "Model 2", c("0.3", "0.5", "0.7", "0.9"))
model3_table <- create_gt_table(model3_data, "Model 3", c("0.3", "0.5", "0.7", "0.9"))

model4_table <- create_gt_table(model4_data, "Model 1", c("A"))
model5_table <- create_gt_table(model5_data, "Model 1", c("B"))
model6_table <- create_gt_table(model6_data, "Model 1", c("C"))
model7_table <- create_gt_table(model7_data, "Model 1", c("D"))

model8_table <- create_gt_table(model8_data, "Model 2", c("A"))
model9_table <- create_gt_table(model9_data, "Model 2", c("B"))
model10_table <- create_gt_table(model10_data, "Model 2", c("C"))
model11_table <- create_gt_table(model11_data, "Model 2", c("D"))

model12_table <- create_gt_table(model12_data, "Model 3", c("A"))
model13_table <- create_gt_table(model13_data, "Model 3", c("B"))
model14_table <- create_gt_table(model14_data, "Model 3", c("C"))
model15_table <- create_gt_table(model15_data, "Model 3", c("D"))


# Print each table by name
model1_table
model2_table
model3_table
model4_table
model5_table
model6_table
model7_table
model8_table
model9_table
model10_table
model11_table
model12_table
model13_table
model14_table
model15_table

```

### **Step 10: Delete Cases that Violate**

#### **Objective**

*Filter out cases with any violations, leaving only the clean data.*

```{r}
#| label: "delete-cases"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Filter out cases with no violations and no errors
filtered_data_with_no_violations <- final_data_with_actuals[
  final_data_with_actuals$Any_Violation == 0 & final_data_with_actuals$ErrorFlag == 0, ]
```

#### Step 10: Part 1

Take random sample of replications to achieve n = 500

```{r}
#| label: "Select-random-sample-replications"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true


# Set seed for reproducibility
set.seed(07252005)

# Group data by FileName and sample 500 rows per condition (if possible)
cleaned_data <- filtered_data_with_no_violations %>%
  group_by(FileName) %>%
  slice_sample(n = 500, replace = FALSE) %>%  # Randomly sample 500 rows (without replacement)
  ungroup()

# Verify the number of rows per condition
condition_counts <- cleaned_data %>%
  group_by(FileName) %>%
  summarize(Count = n(), .groups = "drop")

# Print conditions with more or less than 500 rows (sanity check)
sanity_check <- condition_counts %>%
  filter(Count != 500)

if (nrow(sanity_check) > 0) {
  warning("Some conditions do not have exactly 500 rows. Please verify the data and ensure extra replications are sufficient.")
  print(sanity_check)
} else {
  message("All conditions have exactly 500 rows.")
}
```

### **Step 11: Compute Monte Carlo (MC) Values**

#### **Objective**

*Calculate Monte Carlo values forÂ `TRANS11`, including population values, averages, standard errors, Mean Squared Error (MSE), coverage, and power.*

```{r}

#| label: "compute-mc-values"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# First, convert Population back to numeric if it's a factor
cleaned_data <- cleaned_data %>%
  mutate(Population = as.numeric(as.character(Population)))

# Calculate the Monte Carlo values, including Mixing_proportion, Model_Type, N, 
# population (transition probability), number of replications, and averages for TRANS11 and SE11
mc_values <- cleaned_data %>%
  group_by(FileName, Population, Mixing_proportion, Model, N, Lambda_values) %>%  # Group by FileName, Population, Mixing_proportion, Model_Type, and N
  summarize(
    average = round(mean(TRANS11, na.rm = TRUE), 3),
    average_SE = round(mean(SE_11, na.rm = TRUE), 3),
    population_sd = round(sd(TRANS11, na.rm = TRUE), 3),
    
    # MSE calculation: mean squared error between TRANS11 and Population
    MSE = round(mean((TRANS11 - Population)^2, na.rm = TRUE), 3),
    
    # Coverage calculation: check if Population lies within the confidence interval
    Coverage = round(mean((Population >= (TRANS11 - 1.96 * SE_11)) & (Population <= (TRANS11 + 1.96 * SE_11)), na.rm = TRUE), 3),
    
    # Power calculation: proportion of cases where TRANS11 is significant
    Power = round(mean(TRANS11 / SE_11 > 1.96, na.rm = TRUE), 3),
    
    # Reps_Used counts the number of replications (rows) used for each FileName
    Reps_Used = n()
  )

# Round the values to 3 decimal points
mc_values <- mc_values %>%
  mutate(across(starts_with("Avg_"), ~ round(.x, 3)))

```

### **Step 12: Prepare Data for Plotting Bias**

#### **Objective**

*Prepare the Monte Carlo summary data by adding information from the file names (Model, Sample Size, Mixing Proportion, Lambda Values) and converting these to factors for plotting.*

**Step 10: Calculate Dichotomous Variables and Bias**

#### **Objective**

*Calculate dichotomous variables for Power and Coverage, compute Parameter and SE Bias, and prepare subsets for movers and stayers.*

```{r}
#| label: "calculate-bias-dichotomous-variables"
#| echo: true
#| message: true
#| warning: true
#| code-fold: true

# Step 1: Calculate dichotomous variable for Power (1 if Power >= 0.8, else 0)
mc_values <- mc_values %>%
  mutate(Power_Dic = ifelse(Power >= 0.8, 1, 0))

# Step 2: Calculate dichotomous variable for Coverage (0 if outside [0.91, 0.98], else 1)
mc_values <- mc_values %>%
  mutate(Coverage_Dic = ifelse(Coverage > 0.98 | Coverage < 0.91, 0, 1))

# Step 3: Remove any groupings before further calculations
mc_values <- mc_values %>%
  ungroup()

# Step 4: Ensure numeric columns are correctly formatted
mc_values <- mc_values %>%
  mutate(
    average = as.numeric(average),
    Population = as.numeric(Population),  # Ensure 'Population' is numeric
    average_se = as.numeric(average_SE),
    population_sd = as.numeric(population_sd)
  )

# Step 5: Calculate Parameter Bias and SE Bias, rounding the results to 2 decimal places
mc_values <- mc_values %>%
  mutate(
    Parameter_Bias = (average - Population) / Population * 100,  # Bias for the parameter
    SE_Bias = (average_se - population_sd) / population_sd * 100  # Bias for the standard error
  ) %>%
  mutate(across(c(Parameter_Bias, SE_Bias), ~ round(.x, 2)))  # Round to 2 decimal places

```

### **Step 13: Subset Data for Movers and Stayers**

#### **Objective**

*Subset the Monte Carlo values data for transitions with movers and stayers based on the population value.*

```{r}

#| label: "subset-data-for-movers-stayers"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Subset for Even Mixing Proportion (use the actual factor labels)
subset_even <- subset(mc_values, Mixing_proportion == "Even Proportions")
# Subset for Uneven Mixing Proportion
subset_uneven <- subset(mc_values, Mixing_proportion == "Uneven Proportions")


# Subset for Population 0.2 Even Mixing Proportion
subset_0.2_EVEN <- subset(subset_even, Population == 0.2)
# Subset for Population 0.2 Uneven Mixing Proportion
subset_0.2_UNEVEN <- subset(subset_uneven, Population == 0.2)
# Subset for Population 0.8 Even Mixing Proportion
subset_0.8_EVEN <- subset(subset_even, Population == 0.8)  # Change to 0.8_EVEN
# Subset for Population 0.8 Uneven Mixing Proportion
subset_0.8_UNEVEN <- subset(subset_uneven, Population == 0.8)  # Change to 0.8_UNEVEN

```

### **Step 14: Combined Plot for Mover and Stayer**

#### **Objective**

*Create streamlined plots for both mover and stayer subsets using a common theme and labels.*

```{r}

#| label: "create-plots"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true


generate_plot <- function(data, title, y_limits) {

  # Common theme for the plots
  common_theme <- theme_minimal() +
    theme(
      panel.grid.major.x = element_blank(),
      panel.grid.minor.x = element_blank(),
      panel.grid.minor.y = element_blank(),
      axis.text.x = element_text(size = 6),
      axis.ticks = element_line(color = "black", size = 0.2),
      legend.position = "bottom",
      legend.title = element_blank(),
      text = element_text(family = "Times New Roman"),
      axis.title.x = element_text(margin = margin(t = 10, b = 10)),
      legend.margin = margin(t = -10),
      plot.caption = element_text(hjust = 0, margin = margin(t = 10))
    )

  # Identify which legends are present in the data
  present_categories <- c("Parameter Bias", "Standard Error Bias")
  if (any(data$Coverage_Dic == 0)) present_categories <- c(present_categories, "Coverage Failure")
  if (any(data$Power_Dic == 0)) present_categories <- c(present_categories, "Power Failure")

  # Define the corresponding colors and shapes based on the present categories
  colors <- c("Parameter Bias" = "#7030A0", "Standard Error Bias" = "#C830CC", 
              "Coverage Failure" = "#7030A0", "Power Failure" = "black")

  shapes <- c("Parameter Bias" = 16, "Standard Error Bias" = 18, 
              "Coverage Failure" = 1, "Power Failure" = 4)

  # Filter the colors and shapes based on present categories
  filtered_colors <- colors[present_categories]
  filtered_shapes <- shapes[present_categories]

  # Plotting the data
  ggplot(data = data, aes(x = factor(Lambda_values))) +  
    geom_line(aes(y = Parameter_Bias, color = "Parameter Bias", group = 1), size = 0.3, linetype = "solid") +  
    geom_line(aes(y = SE_Bias, color = "Standard Error Bias", group = 1), size = 0.3, linetype = "solid") +  
    geom_point(aes(y = Parameter_Bias, color = "Parameter Bias"), shape = 16, size = 1, fill = "#7030A0", alpha = 0.8) +  
    geom_point(aes(y = SE_Bias, color = "Standard Error Bias"), shape = 18, size = 1, fill = "#C830CC", alpha = 0.8) +  
    geom_point(data = subset(data, Coverage_Dic == 0), aes(y = Parameter_Bias, color = "Coverage Failure"), shape = 1, size = 2, fill = "#7030A0", alpha = 1) +  
    geom_point(data = subset(data, Power_Dic == 0), aes(y = Parameter_Bias, color = "Power Failure"), shape = 4, size = 2, fill = "black", alpha = 1) + 
    scale_color_manual(
      values = filtered_colors, 
      labels = present_categories, 
      breaks = present_categories,
      guide = guide_legend(
        override.aes = list(
          shape = filtered_shapes
        )
      )
    ) + 
    labs(
      x = "Lambda Loadings on the RI",
      y = "Bias (%)",
      color = "",
      title = title
    ) +
    coord_cartesian(ylim = y_limits) +  
    facet_grid(factor(Model) ~ N, scales = "free_x") + 
    scale_x_discrete(name = "Lambda Loadings on the RI") +  # Set x-axis title
    scale_y_continuous(breaks = seq(min(y_limits), max(y_limits), by = 20)) +  
    common_theme +
    geom_hline(yintercept = c(-10, 10), linetype = "dashed", color = "#7030A0", size = 0.3) +  
    geom_hline(yintercept = c(-5, 5), linetype = "dashed", color = "#C830CC", size = 0.3) +
    theme(strip.text.y = element_text(size = 8))  # Adjust the size of row titles
}



# Generate plots
plot_0.2even <- generate_plot(subset_0.2_EVEN, "Even Mixing Proportion with .200 Transition Probabilities", c(-40, 200))
plot_0.2uneven <- generate_plot(subset_0.2_UNEVEN, "Uneven Mixing Proportion with .200 Transition Probabilities", c(-40, 80))
plot_0.8even <- generate_plot(subset_0.8_EVEN, "Even Mixing Proportion with .800 Transition Probabilities", c(-40, 40))
plot_0.8uneven <- generate_plot(subset_0.8_UNEVEN, "Uneven Mixing Proportion with .800 Transition Probabilities", c(-40, 40))

# Print the plots
print(plot_0.2even)
print(plot_0.2uneven)
print(plot_0.8even)
print(plot_0.8uneven)

```

### **Step 15: Prepare Data for Heatmaps**

#### **Objective**

*Prepare data for heatmap creation by ensuring correct formatting for population values, and subsetting the data based on class proportions and sample sizes.*

```{r}
#| label: "prepare-data-for-heatmaps"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true


# Mutate columns to factor with custom labels
all_data <- mc_values %>%
  mutate(Population = factor(Population, 
                             levels = c(0.2, 0.8),  # Define the numeric levels
                             labels = c(".200", ".800")))  # Assign the custom labels

all_data$Population <- as.numeric(as.character(all_data$Population))


rownames(all_data) <- NULL

# Ensure Population is numeric and fix Mixing_proportion labels
subset_0.2_Even <- subset(all_data, as.numeric(Population) == .200 & Mixing_proportion == "Even Proportions")

subset_0.2_uneven <- subset(all_data, as.numeric(Population) == .200 & Mixing_proportion == "Uneven Proportions")

subset_0.8_Even <- subset(all_data, as.numeric(Population) == .800 & Mixing_proportion == "Even Proportions")

subset_0.8_uneven <- subset(all_data, as.numeric(Population) == .800 & Mixing_proportion == "Uneven Proportions")


# Correct filtering using explicit factor matching
subset_0.2_Even_Model_1 <- subset_0.2_Even %>%
  filter(as.character(Model) == "Model 1")

subset_0.2_Even_Model_2 <- subset_0.2_Even %>%
  filter(as.character(Model) == "Model 2")

subset_0.2_Even_Model_3 <- subset_0.2_Even %>%
  filter(as.character(Model) == "Model 3")

subset_0.2_uneven_Model_1 <- subset_0.2_uneven %>%
  filter(as.character(Model) == "Model 1")

subset_0.2_uneven_Model_2 <- subset_0.2_uneven %>%
  filter(as.character(Model) == "Model 2")

subset_0.2_uneven_Model_3 <- subset_0.2_uneven %>%
  filter(as.character(Model) == "Model 3")

subset_0.8_Even_Model_1 <- subset_0.8_Even %>%
  filter(as.character(Model) == "Model 1")

subset_0.8_Even_Model_2 <- subset_0.8_Even %>%
  filter(as.character(Model) == "Model 2")

subset_0.8_Even_Model_3 <- subset_0.8_Even %>%
  filter(as.character(Model) == "Model 3")

subset_0.8_uneven_Model_1 <- subset_0.8_uneven %>%
  filter(as.character(Model) == "Model 1")

subset_0.8_uneven_Model_2 <- subset_0.8_uneven %>%
  filter(as.character(Model) == "Model 2")

subset_0.8_uneven_Model_3 <- subset_0.8_uneven %>%
  filter(as.character(Model) == "Model 3")



subset_0.2_Even_Model_1 <- subset_0.2_Even_Model_1 %>%
  select(Lambda_values, average, Coverage, Power, Parameter_Bias, SE_Bias)

subset_0.2_Even_Model_2 <- subset_0.2_Even_Model_2 %>%
  select(Lambda_values, average, Coverage, Power, Parameter_Bias, SE_Bias)

subset_0.2_Even_Model_3 <- subset_0.2_Even_Model_3 %>%
  select(Lambda_values, average, Coverage, Power, Parameter_Bias, SE_Bias)

subset_0.2_uneven_Model_1 <- subset_0.2_uneven_Model_1 %>%
  select(Lambda_values, average, Coverage, Power, Parameter_Bias, SE_Bias)

subset_0.2_uneven_Model_2 <- subset_0.2_uneven_Model_2 %>%
  select(Lambda_values, average, Coverage, Power, Parameter_Bias, SE_Bias)

subset_0.2_uneven_Model_3 <- subset_0.2_uneven_Model_3 %>%
  select(Lambda_values, average, Coverage, Power, Parameter_Bias, SE_Bias)

subset_0.8_Even_Model_1 <- subset_0.8_Even_Model_1 %>%
  select(Lambda_values, average, Coverage, Power, Parameter_Bias, SE_Bias)

subset_0.8_Even_Model_2 <- subset_0.8_Even_Model_2 %>%
  select(Lambda_values, average, Coverage, Power, Parameter_Bias, SE_Bias)

subset_0.8_Even_Model_3 <- subset_0.8_Even_Model_3 %>%
  select(Lambda_values, average, Coverage, Power, Parameter_Bias, SE_Bias)

subset_0.8_uneven_Model_1 <- subset_0.8_uneven_Model_1 %>%
  select(Lambda_values, average, Coverage, Power, Parameter_Bias, SE_Bias)

subset_0.8_uneven_Model_2 <- subset_0.8_uneven_Model_2 %>%
  select(Lambda_values, average, Coverage, Power, Parameter_Bias, SE_Bias)

subset_0.8_uneven_Model_3 <- subset_0.8_uneven_Model_3 %>%
  select(Lambda_values, average, Coverage, Power, Parameter_Bias, SE_Bias)

# Store subsets in a list with new names
new_subset_list <- list(
  subset_0.2_Even_Model_1 = subset_0.2_Even_Model_1,
  subset_0.2_Even_Model_2 = subset_0.2_Even_Model_2,
  subset_0.2_Even_Model_3 = subset_0.2_Even_Model_3,
  subset_0.2_uneven_Model_1 = subset_0.2_uneven_Model_1,
  subset_0.2_uneven_Model_2 = subset_0.2_uneven_Model_2,
  subset_0.2_uneven_Model_3 = subset_0.2_uneven_Model_3,
  subset_0.8_Even_Model_1 = subset_0.8_Even_Model_1,
  subset_0.8_Even_Model_2 = subset_0.8_Even_Model_2,
  subset_0.8_Even_Model_3 = subset_0.8_Even_Model_3,
  subset_0.8_uneven_Model_1 = subset_0.8_uneven_Model_1,
  subset_0.8_uneven_Model_2 = subset_0.8_uneven_Model_2,
  subset_0.8_uneven_Model_3 = subset_0.8_uneven_Model_3
)


```

### **Step 16: Heatmap Creation and Rendering**

#### **Objective**

*Create heatmaps using theÂ `gt`Â package and render each table separately for different subsets of the data.*

```{r}
#| label: "heatmap-creation"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true


create_table <- function(subset, transition_probability) {
  
  gt_table <- subset %>%
    gt() %>%
    opt_table_font(stack = "geometric-humanist") %>% 
    tab_header(
      title = paste("RILTA Generated & LTA Analyzed with Transition Probability of", transition_probability)
    ) %>%
    cols_label(
      Lambda_values = "Lambda",
      average = "Estimated Probability",
      Coverage = "Coverage",
      Power = "Power",
      Parameter_Bias = "Parameter Bias",
      SE_Bias = "Standard Error Bias"
    ) %>%
    tab_spanner(label = "Bias", columns = c("Parameter_Bias", "SE_Bias")) %>%
    tab_row_group(label = "N = 5000", rows = 25:32) %>%
    tab_row_group(label = "N = 2500", rows = 17:24) %>%
    tab_row_group(label = "N = 1000", rows = 9:16) %>%
    tab_row_group(label = "N = 500", rows = 1:8) %>%
    tab_style(style = cell_text(font = "bold italic"), locations = cells_row_groups()) %>%
    fmt_number(columns = c("Parameter_Bias", "SE_Bias"), decimals = 2) %>%
    #fmt_number(columns = 4, decimals = 3) %>%
     #   cols_width(
     # Lambda_values ~ px(65),  # Adjust as needed for compactness
    #  average ~ px(90),
    #  Coverage ~ px(80),
    #  Power ~ px(80),
    #  Parameter_Bias ~ px(80),
    #  SE_Bias ~ px(90)
    #) %>%
    tab_options(
      table.border.top.color = "black",
      table.border.bottom.color = "black",
      table_body.border.bottom.color = "black",
      heading.border.bottom.color = "black",
      column_labels.border.top.color = "black",
      column_labels.border.bottom.color = "black",
      row_group.border.bottom.color = "black",
      row_group.border.top.color = "black"
    ) %>%
    cols_align(align = c("center"), columns = everything())

  # Apply color highlighting for violations in Parameter Bias
  if (any(!(subset$Parameter_Bias >= -9.99 & subset$Parameter_Bias <= 9.99), na.rm = TRUE)) {
    gt_table <- gt_table %>%
      data_color(
        columns = "Parameter_Bias",
        rows = .data$Parameter_Bias < -9.99 | .data$Parameter_Bias > 9.99,  # Apply color only if outside the threshold
        method = "numeric",
        palette = c("#113386", "#DAE3FA", "#113386"),  # Darker blue for larger deviations
        domain = c(-40, 40)  # Adjust the domain to reflect the range of values
      ) %>%
      tab_footnote(
        footnote = md("Darker blue indicates larger deviations from zero *Parameter Bias* beyond the Â±9.99 threshold."),
        locations = cells_column_labels(columns = "Parameter_Bias")
      )
  }

  # Apply color highlighting for violations in SE Bias
  if (any(!(subset$SE_Bias >= -4.99 & subset$SE_Bias <= 4.99), na.rm = TRUE)) {
    gt_table <- gt_table %>%
      data_color(
        columns = "SE_Bias",
        rows = .data$SE_Bias < -4.99 | .data$SE_Bias > 4.99,  # Apply color only if outside the threshold
        method = "numeric",
        palette = c("#B4186E", "#F9D5E9", "#B4186E"),  # Darker red for larger deviations
        domain = c(-80, 80)  # Adjust the domain for the SE_Bias range
      ) %>%
      tab_footnote(
        footnote = md("Darker red indicates larger deviations from zero *Standard Error Bias* beyond the Â±4.99 threshold."),
        locations = cells_column_labels(columns = "SE_Bias")
      )
  }

  if (any(subset$Coverage < 0.93 | subset$Coverage > 0.979, na.rm = TRUE)) {
    gt_table <- gt_table %>%
      data_color(
        columns = "Coverage",
        rows = subset$Coverage < 0.93 | subset$Coverage > 0.979,
        method = "numeric",
        palette = c("#93C6B1", "white"),  # Green for coverage issues
        domain = c(0, 1)
      ) %>%
      tab_footnote(
        footnote = md("Green indicates failure to achieve adequate *Coverage*."),
        locations = cells_column_labels(columns = "Coverage")
      )
  }

  if (any(subset$Power < 0.8, na.rm = TRUE)) {
    gt_table <- gt_table %>%
      data_color(
        columns = "Power",
        rows = subset$Power < 0.8,
        method = "numeric",
        palette = c("#502CD1", "white"),  # Purple for power issues
        domain = c(0, 1)
      ) %>%
      tab_footnote(
        footnote = md("Purple indicates failure to achieve adequate *Power*."),
        locations = cells_column_labels(columns = "Power")
      )
  }
  
  return(gt_table)
}


```

#### **Step 17: Rendering the Tables**

```{r}

#| label: "heatmap-0.2-even-model1"
#| echo: true
#| message: true
#| warning: true

# Heatmap for .200, Even Mixing Proportion, Model 2
subset_0.2_Even_Model_1_table <- create_table(subset_0.2_Even_Model_1, ".200, Even Mixing Proportion, Model 2")
subset_0.2_Even_Model_1_table |> gtsave(here('Simulations', 'STUDY_2','ZHeatmaps', 'z2t_rilta_lta_tables', "2T_L_R_.200_Even_Model_1.png"), expand = 8)
knitr::include_graphics(here('Simulations', 'STUDY_2', 'zHeatmaps', 'z2t_rilta_lta_tables', "2T_L_R_.200_Even_Model_1.png"))

```

```{r}
#| label: "heatmap-0.2-even-model2"
#| echo: true
#| message: true
#| warning: true

# Heatmap for .200, Even Mixing Proportion, Model 2
subset_0.2_Even_Model_2_table <- create_table(subset_0.2_Even_Model_2, ".200, Even Mixing Proportion, Model 2")
subset_0.2_Even_Model_2_table |> gtsave(here('Simulations', 'STUDY_2', 'zHeatmaps', 'z2t_rilta_lta_tables', "2T_L_R_.200_Even_Model_2.png"), expand = 8)
knitr::include_graphics(here('Simulations', 'STUDY_2', 'zHeatmaps', 'z2t_rilta_lta_tables', "2T_L_R_.200_Even_Model_2.png"))

```

```{r}
#| label: "heatmap-0.2-even-model3"
#| echo: true
#| message: false
#| warning: false

# Heatmap for .200, Even Mixing Proportion, Model 3
subset_0.2_Even_Model_3_table <- create_table(subset_0.2_Even_Model_3, ".200, Even Mixing Proportion, Model 3")
subset_0.2_Even_Model_3_table |> gtsave(here('Simulations', 'STUDY_2', 'zHeatmaps', 'z2t_rilta_lta_tables', "2T_L_R_.200_Even_Model_3.png"), expand = 8)
knitr::include_graphics(here('Simulations', 'STUDY_2', 'zHeatmaps', 'z2t_rilta_lta_tables', "2T_L_R_.200_Even_Model_3.png"))

```

```{r}
#| label: "heatmap-0.2-uneven-model1"
#| echo: true
#| message: false
#| warning: false

# Heatmap for .200, Uneven Mixing Proportion, Model 1
subset_0.2_uneven_Model_1_table <- create_table(subset_0.2_uneven_Model_1, ".200, Uneven Mixing Proportion, Model 1")
subset_0.2_uneven_Model_1_table |> gtsave(here('Simulations', 'STUDY_2', 'zHeatmaps', 'z2t_rilta_lta_tables', "2T_L_R_.200_Uneven_Model_1.png"), expand = 8)
knitr::include_graphics(here('Simulations', 'STUDY_2', 'zHeatmaps', 'z2t_rilta_lta_tables', "2T_L_R_.200_Uneven_Model_1.png"))

```

```{r}
#| label: "heatmap-0.2-uneven-model2"
#| echo: true
#| message: false
#| warning: false

# Heatmap for .200, Uneven Mixing Proportion, Model 2
subset_0.2_uneven_Model_2_table <- create_table(subset_0.2_uneven_Model_2, ".200, Uneven Mixing Proportion, Model 2")
subset_0.2_uneven_Model_2_table |> gtsave(here('Simulations', 'STUDY_2', 'zHeatmaps', 'z2t_rilta_lta_tables', "2T_L_R_.200_Uneven_Model_2.png"), expand = 8)
knitr::include_graphics(here('Simulations', 'STUDY_2', 'zHeatmaps', 'z2t_rilta_lta_tables', "2T_L_R_.200_Uneven_Model_2.png"))

```

```{r}
#| label: "heatmap-0.2-uneven-model3"
#| echo: true
#| message: false
#| warning: false

# Heatmap for .200, Uneven Mixing Proportion, Model 3
subset_0.2_uneven_Model_3_table <- create_table(subset_0.2_uneven_Model_3, ".200, Uneven Mixing Proportion, Model 3")
subset_0.2_uneven_Model_3_table |> gtsave(here('Simulations', 'STUDY_2', 'zHeatmaps', 'z2t_rilta_lta_tables', "2T_L_R_.200_Uneven_Model_3.png"), expand = 8)
knitr::include_graphics(here('Simulations', 'STUDY_2', 'zHeatmaps', 'z2t_rilta_lta_tables', "2T_L_R_.200_Uneven_Model_3.png"))

```

```{r}
#| label: "heatmap-0.8-even-model1"
#| echo: true
#| message: false
#| warning: false

# Heatmap for .800, Even Mixing Proportion, Model 1
subset_0.8_Even_Model_1_table <- create_table(subset_0.8_Even_Model_1, ".800, Even Mixing Proportion, Model 1")
subset_0.8_Even_Model_1_table |> gtsave(here('Simulations', 'STUDY_2', 'zHeatmaps', 'z2t_rilta_lta_tables', "2T_L_R_.800_Even_Model_1.png"), expand = 8)
knitr::include_graphics(here('Simulations', 'STUDY_2', 'zHeatmaps', 'z2t_rilta_lta_tables', "2T_L_R_.800_Even_Model_1.png"))

```

```{r}
#| label: "heatmap-0.8-even-model2"
#| echo: true
#| message: false
#| warning: false

# Heatmap for .800, Even Mixing Proportion, Model 2
subset_0.8_Even_Model_2_table <- create_table(subset_0.8_Even_Model_2, ".800, Even Mixing Proportion, Model 2")
subset_0.8_Even_Model_2_table |> gtsave(here('Simulations', 'STUDY_2', 'zHeatmaps', 'z2t_rilta_lta_tables', "2T_L_R_.800_Even_Model_2.png"), expand = 8)
knitr::include_graphics(here('Simulations', 'STUDY_2', 'zHeatmaps', 'z2t_rilta_lta_tables', "2T_L_R_.800_Even_Model_2.png"))

```

```{r}
#| label: "heatmap-0.8-even-model3"
#| echo: true
#| message: false
#| warning: false

# Heatmap for .800, Even Mixing Proportion, Model 3
subset_0.8_Even_Model_3_table <- create_table(subset_0.8_Even_Model_3, ".800, Even Mixing Proportion, Model 3")
subset_0.8_Even_Model_3_table |> gtsave(here('Simulations', 'STUDY_2', 'zHeatmaps', 'z2t_rilta_lta_tables', "2T_L_R_.800_Even_Model_3.png"), expand = 8)
knitr::include_graphics(here('Simulations', 'STUDY_2', 'zHeatmaps', 'z2t_rilta_lta_tables', "2T_L_R_.800_Even_Model_3.png"))

```

```{r}
#| label: "heatmap-0.8-uneven-model1"
#| echo: true
#| message: false
#| warning: false

# Heatmap for .800, Uneven Mixing Proportion, Model 1
subset_0.8_uneven_Model_1_table <- create_table(subset_0.8_uneven_Model_1, ".800, Uneven Mixing Proportion, Model 1")
subset_0.8_uneven_Model_1_table |> gtsave(here('Simulations', 'STUDY_2', 'zHeatmaps', 'z2t_rilta_lta_tables', "2T_L_R_.800_Uneven_Model_1.png"), expand = 8)
knitr::include_graphics(here('Simulations', 'STUDY_2', 'zHeatmaps', 'z2t_rilta_lta_tables', "2T_L_R_.800_Uneven_Model_1.png"))

```

```{r}
#| label: "heatmap-0.8-uneven-model2"
#| echo: true
#| message: false
#| warning: false

# Heatmap for .800, Uneven Mixing Proportion, Model 2
subset_0.8_uneven_Model_2_table <- create_table(subset_0.8_uneven_Model_2, ".800, Uneven Mixing Proportion, Model 2")
subset_0.8_uneven_Model_2_table |> gtsave(here('Simulations', 'STUDY_2', 'zHeatmaps', 'z2t_rilta_lta_tables', "2T_L_R_.800_Uneven_Model_2.png"), expand = 8)
knitr::include_graphics(here('Simulations', 'STUDY_2', 'zHeatmaps', 'z2t_rilta_lta_tables', "2T_L_R_.800_Uneven_Model_2.png"))

```

```{r}
#| label: "heatmap-0.8-uneven-model3"
#| echo: true
#| message: false
#| warning: false

# Heatmap for .800, Uneven Mixing Proportion, Model 3
subset_0.8_uneven_Model_3_table <- create_table(subset_0.8_uneven_Model_3, ".800, Uneven Mixing Proportion, Model 3")
subset_0.8_uneven_Model_3_table |> gtsave(here('Simulations', 'STUDY_2', 'Zheatmaps', 'z2t_rilta_lta_tables', "2T_L_R_.800_Uneven_Model_3.png"), expand = 8)
knitr::include_graphics(here('Simulations', 'STUDY_2', 'ZHeatmaps', 'z2t_rilta_lta_tables', "2T_L_R_.800_Uneven_Model_3.png"))

```
