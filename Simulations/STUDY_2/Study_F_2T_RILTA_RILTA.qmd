---
title: "Study 2 (k = 3) RILTA Generated, RILTA Analyzed: Two Timepoints"
format:
  html:
    code-fold: true
editor: visual
author: "Delwin Carter"
page-layout: full
fig-format: svg
knitr:
  opts_chunk:
    out.width: "90%"
    fig.align: center
---

```{r, message=FALSE}
#| label: "load-libraries"
#| echo: true
#| message: false
#| warning: false
#knitr::opts_chunk$set(echo = TRUE, eval = TRUE, warning = FALSE, message = FALSE)

library(tidyverse)
library(glue)
library(MplusAutomation)
library(here)
library(gt)
library(janitor)
library(parallel)
library(tools)
```

# RILTA Generated, RILTA Analyzed

## Introduction

In this section, we will simulate three models by generating them as Random Intercepts Latent Transition Models and analyze them as Random Intercepts Latent Transition Models.

![](images/RILTA_RILTA.png){width="354"}

# Model 1:

### Conditions:

Sample Size: N = 500, 1000, 2500, 5000

Transitions probability:

![](images/clipboard-2891141057.png){width="352"}

RI Loadings: lambda = 0.5, 1.5, 3

![](images/clipboard-1938861516.png){width="551"}

Thresholds= Model 1

![](images/clipboard-1358058122.png){width="359"}

**Class Prevalence: Equal v. Unequal 1 = .33.3, .33.3, 33.3 ; 2 = .60, .30, .10**

#### Iterator Matrix for Model 1 - Model 3

```{r}

#| label: "simultation-conditions"
#| echo: true
#| message: false
#| warning: false

p1 <- expand.grid(N = c(500, 1000, 2500, 5000),
TPs = c(3.179, 0.407),
mix = c(1, 2),
lambda = c(.5, 1.5, 3))
       
# Display the matrix using gt
p1 %>%
  gt() %>%
  tab_header(
    title = "Simulation Conditions Matrix",
    subtitle = "Combinations of Sample Sizes, Transition Probabilities, and Mixing Propotions"
  ) %>%
  cols_align(
    align = "center",
    columns = everything() # Centers all columns
  )
```

#### Simulation Setup: Model 1

We will now run a Monte Carlo simulation for Model 1. The simulation will iterate over different combinations of sample sizes, transition probabilities, mixing proportion, and lambda components. The following code sets up the cluster for parallel processing and defines the function to run the simulation.

```{r,eval = FALSE}

#| label: "lta-rilta-simulation-Model 1"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Step 1: Create the cluster (use PSOCK for Windows)
num_cores <- detectCores() - 1  # Detect number of cores
cl <- makeCluster(num_cores, type = "PSOCK")    # Create the cluster with PSOCK

rilta_rilta_func <- function(N, TPs, mix, lambda) {
  
  # Construct the MODELPOPULATION argument based on the value of mix
  MODELPOPULATION <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      
       f by u11-u15*{lambda} (p1-p5)
            u21-u25*{lambda} (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
    
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;

       f by u11-u15*{lambda} (p1-p5)
            u21-u25*{lambda} (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

       f by u11-u15*{lambda} (p1-p5)
            u21-u25*{lambda} (p1-p5);
        f@1;
        [f@0];

      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2: 	
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
    
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	
      
       f by u11-u15*{lambda} (p1-p5)
            u21-u25*{lambda} (p1-p5);
        f@1;
        [f@0];      

      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2: 	
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  }

  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);

      
    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);

    ")
  }

  # Construct the Mplus object
  RILTA_RILTA <- mplusObject(
    TITLE = glue("RILTA_RILTA_M1_N_{N}_TP_{TPs}_M_{mix}_L_{lambda}"),
    MONTECARLO = glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N};
      SEED = 07252005;
      NREPS = 500;
      !!SAVE = repM1*.dat;
      RESULTS = RILTA_RILTA_M1_N_{N}_TP_{TPs}_M_{mix}_L_{lambda}.csv;"),
    
    
    ANALYSIS = "TYPE = MIXTURE;
      algorithm = integration;
      STARTS = 50 10;
      processors = 24;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_RILTA_Model<- mplusModeler(RILTA_RILTA, 
                                   dataout = here('Simulations', 'STUDY_2', '4_RILTA_GEN_RILTA_ANALYZED', glue("RILTA_RILTA_M1_N_{N}_TP_{TPs}_M_{mix}_L_{lambda}.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '4_RILTA_GEN_RILTA_ANALYZED', "RILTA_RILTA_M1_N_{N}_TP_{TPs}_M_{mix}_L_{lambda}.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_RILTA_Model)
}

# Step 3: Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_rilta_func", "p1")))

# Ensure that the packages are loaded on each cluster node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(p1), function(i) {
  rilta_rilta_func(p1$N[i], p1$TPs[i], p1$mix[i], p1$lambda[i])
})

stopCluster(cl)

```

# Model 2: RILTA Generated, RILTA Analyzed

### Conditions:

Sample Size: N = 500, 1000, 2500, 5000

Transition Probability

![](images/clipboard-2891141057.png){width="352"}

RI Loadings: lambda = .5, 1.5, 3

![](images/clipboard-1938861516.png){width="380"}

Thresholds= Model 2

![](images/clipboard-3697136395.png){width="363"}

**Class Prevalence: Equal v. Unequal 1 = .33.3, .33.3, 33.3 ; 2 = .60, .30, .10**

#### Simulation Setup: Model 2

We will now run a Monte Carlo simulation for Model 2. The simulation will iterate over different combinations of sample sizes, transition probabilities, mixing proportion, and lambda components. The following code sets up the cluster for parallel processing and defines the function to run the simulation.

```{r, eval = FALSE}

#| label: "lta-rilta-simulation-Model 2"
#| echo: true
#| message: false
#| warning: false

# Step 1: Create the cluster (use PSOCK for Windows)
num_cores <- detectCores() - 1  # Detect number of cores
cl <- makeCluster(num_cores, type = "PSOCK")    # Create the cluster with PSOCK

rilta_rilta_func2 <- function(N, TPs, mix, lambda) {
  
    # Construct the MODELPOPULATION argument based on the value of mix
  MODELPOPULATION <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
       
       f by u11-u15*{lambda} (p1-p5)
            u21-u25*{lambda} (p1-p5);
        f@1;
        [f@0];
        
        MODEL POPULATION-c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
       ")
    
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      
       f by u11-u15*{lambda} (p1-p5)
            u21-u25*{lambda} (p1-p5);
        f@1;
        [f@0];
        
     MODEL POPULATION-c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
       ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

       f by u11-u15*{lambda} (p1-p5)
            u21-u25*{lambda} (p1-p5);
        f@1;
        [f@0];
        
     MODEL c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
	      ")      


            
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	      

           f by u11-u15*{lambda} (p1-p5)
            u21-u25*{lambda} (p1-p5);
        f@1;
        [f@0];
        
     MODEL c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
	      ")      
  }
  
  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);

    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);

    ")
  }
  
  RILTA_RILTA2 <- mplusObject(
    TITLE = glue("Generate RILTA_RILTA_M2_N_{N}_TP_{TPs}_M_{mix}_L_{lambda}"),

    MONTECARLO =
      glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N};
      SEED = 07252005;
      NREPS = 500;
      !SAVE = repM2*.dat;
      RESULTS = RILTA_RILTA_M2_N_{N}_TP_{TPs}_M_{mix}_L_{lambda}.csv;"),
    
    
    ANALYSIS = "TYPE = MIXTURE;
      algorithm = integration;
      STARTS = 50 10;
      processors = 24;
      logcriterion=0.00001;
      mconv=0.00001;",

    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_RILTA_Model2<- mplusModeler(RILTA_RILTA2, 
                                   dataout = here('Simulations', 'STUDY_2', '4_RILTA_GEN_RILTA_ANALYZED', glue("RILTA_RILTA_M2_N_{N}_TP_{TPs}_M_{mix}_L_{lambda}.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '4_RILTA_GEN_RILTA_ANALYZED', "RILTA_RILTA_M2_N_{N}_TP_{TPs}_M_{mix}_L_{lambda}.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_RILTA_Model2)
}

# Step 3: Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_rilta_func2", "p1")))

# Ensure that the packages are loaded on each cluster node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(p1), function(i) {
  rilta_rilta_func2(p1$N[i], p1$TPs[i], p1$mix[i], p1$lambda[i])
})



stopCluster(cl)
```

# Model 3: RILTA Generated, RILTA Analyzed

### Conditions:

Sample Size: N = 1000, 2500, 5000, 7500

Transition logit (Probability): TPs = 3.179 (Stayer), 0.407 (Mover)

![](images/clipboard-2891141057.png){width="352"}

RI Loadings: lambda = .5, 1.5, 3

![](images/clipboard-1938861516.png){width="410"}

Thresholds= Model 3

![](images/clipboard-260898834.png){width="378"}

**Class Prevalence: Equal v. Unequal 1 = .33.3, .33.3, 33.3 ; 2 = .60, .30, .10**

#### Simulation Setup: Model 3

We will now run a Monte Carlo simulation for Model 3. The simulation will iterate over different combinations of sample sizes, transition probabilities, mixing proportion, and lambda components. The following code sets up the cluster for parallel processing and defines the function to run the simulation.

```{r,message=FALSE, warning=FALSE, eval = FALSE}

#| label: "lta-rilta-simulation-Model 3"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Step 1: Create the cluster (use PSOCK for Windows)
num_cores <- detectCores() - 1  # Detect number of cores
cl <- makeCluster(num_cores, type = "PSOCK")    # Create the cluster with PSOCK

rilta_rilta_func3 <- function(N, TPs, mix, lambda) {
  
    # Construct the MODELPOPULATION argument based on the value of mix
  MODELPOPULATION <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11-u15*{lambda} (p1-p5)
            u21-u25*{lambda} (p1-p5);
        f@1;
        [f@0];
          
        MODEL POPULATION-c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
       ")
    
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11-u15*{lambda} (p1-p5)
            u21-u25*{lambda} (p1-p5);
        f@1;
        [f@0];
              
     MODEL POPULATION-c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
       ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	
      	
       f by u11-u15*{lambda} (p1-p5)
            u21-u25*{lambda} (p1-p5);
        f@1;
        [f@0];
          
     MODEL c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
	      ")      

          
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	      
      	
       f by u11-u15*{lambda} (p1-p5)
            u21-u25*{lambda} (p1-p5);
        f@1;
        [f@0];
          
     MODEL c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
	      ")      
  }
    
  
  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  }
  
  RILTA_RILTA3 <- mplusObject(
    TITLE = glue("Generate RILTA_RILTA_M3_N_{N}_TP_{TPs}_M_{mix}_L_{lambda}"),

    MONTECARLO =
      glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N};
      SEED = 07252005;
      NREPS = 500;
      !SAVE = repM3*.dat;
      RESULTS = RILTA_RILTA_M3_N_{N}_TP_{TPs}_M_{mix}_L_{lambda}.csv;"),
    
    
    ANALYSIS = "TYPE = MIXTURE;
      algorithm = integration;
      STARTS = 50 10;
      processors = 24;
      logcriterion=0.00001;
      mconv=0.00001;",

    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_RILTA_Model3<- mplusModeler(RILTA_RILTA3, 
                                   dataout = here('Simulations', 'STUDY_2', '4_RILTA_GEN_RILTA_ANALYZED', glue("RILTA_RILTA_M3_N_{N}_TP_{TPs}_M_{mix}_L_{lambda}.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '4_RILTA_GEN_RILTA_ANALYZED', "RILTA_RILTA_M3_N_{N}_TP_{TPs}_M_{mix}_L_{lambda}.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_RILTA_Model3)
}

# Step 3: Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_rilta_func3", "p1")))

# Ensure that the packages are loaded on each cluster node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(p1), function(i) {
  rilta_rilta_func3(p1$N[i], p1$TPs[i], p1$mix[i], p1$lambda[i])
})

stopCluster(cl)

```

# Model 4: PATTERN M1_X

### Conditions:

Sample Size: N = 500, 1000, 2500, 5000

Transition logit (Probability): TPs = 3.179 (Stayer), 0.407 (Mover)

![](images/clipboard-2891141057.png){width="352"}

RI Loadings: lambda = Pattern X

![](images/Screenshot%202024-08-31%20at%204.21.01%20PM-07.png){width="517"}

Thresholds= Model 1

![](images/clipboard-1358058122.png){width="359"}

**Class Prevalence: Equal v. Unequal 1 = .33.3, .33.3, 33.3 ; 2 = .60, .30, .10**

#### Iterator Matrix for Model 4 - Model 12

```{r}

p1 <- expand.grid(N = c(500, 1000, 2500, 5000),
TPs = c(3.179, 0.407),
mix = c(1, 2))

p1
```

#### Simulation Setup: Model 4

We will now run a Monte Carlo simulation for Model 4. The simulation will iterate over different combinations of sample sizes, transition probabilities, and mixing proportion components. The following code sets up the cluster for parallel processing and defines the function to run the simulation.

```{r, eval = FALSE}

#| label: "lta-rilta-simulation-Model 4"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Step 1: Create the cluster (use PSOCK for Windows)
num_cores <- detectCores() - 1  # Detect number of cores
cl <- makeCluster(num_cores, type = "PSOCK")    # Create the cluster with PSOCK

RILTA_RILTA_func4 <- function(N, TPs, mix) {
  
  # Construct the MODELPOPULATION argument based on the value of mix
  MODELPOPULATION <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      
       f by u11*.1 u12*.1 u13*.2 u14*.1 u15*2 (p1-p5)
            u21*.1 u22*.1 u23*.2 u24*.1 u25*2 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
    
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;

      	
       f by u11*.1 u12*.1 u13*.2 u14*.1 u15*2 (p1-p5)
            u21*.1 u22*.1 u23*.2 u24*.1 u25*2 (p1-p5);
        f@1;
        [f@0];
        
        
      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	
      
       f by u11*.1 u12*.1 u13*.2 u14*.1 u15*2 (p1-p5)
            u21*.1 u22*.1 u23*.2 u24*.1 u25*2 (p1-p5);
        f@1;
        [f@0];

      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2: 	
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
    
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	
      
       f by u11*.1 u12*.1 u13*.2 u14*.1 u15*2 (p1-p5)
            u21*.1 u22*.1 u23*.2 u24*.1 u25*2 (p1-p5);
        f@1;
        [f@0];

      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2: 	
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  }

  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);

    ")
  }

  # Construct the Mplus object
  RILTA_RILTA4 <- mplusObject(
    TITLE = glue("RILTA_RILTA_M1_N_{N}_TP_{TPs}_M_{mix}_L_X"),
    MONTECARLO = glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N};
      SEED = 07252005;
      NREPS = 500;
      !SAVE = repM4*.dat;
      RESULTS = RILTA_RILTA_M1_N_{N}_TP_{TPs}_M_{mix}_L_X.csv;"),
    
    
    ANALYSIS = "TYPE = MIXTURE;
      algorithm = integration;
      STARTS = 50 10;
      processors = 24;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_RILTA_Model4<- mplusModeler(RILTA_RILTA4, 
                                   dataout = here('Simulations', 'STUDY_2', '4_RILTA_GEN_RILTA_ANALYZED', glue("RILTA_RILTA_M1_N_{N}_TP_{TPs}_M_{mix}_L_X.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '4_RILTA_GEN_RILTA_ANALYZED', "RILTA_RILTA_M1_N_{N}_TP_{TPs}_M_{mix}_L_X.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_RILTA_Model4)
}

# Step 3: Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_rilta_func4", "p1")))

# Ensure that the packages are loaded on each cluster node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(p1), function(i) {
  RILTA_RILTA_func4(p1$N[i], p1$TPs[i], p1$mix[i])
               })

stopCluster(cl)
```

# Model 5: Pattern M1_Y

# RILTA Generated, LTA Analyzed

### Conditions:

Sample Size: N = 500, 1000, 2500, 5500

Transition logit (Probability): TPs = 3.179 (Stayer), 0.407 (Mover)

![](images/clipboard-2891141057.png){width="352"}

RI Loadings: lambda = Pattern Y

![](images/Screenshot%202024-08-31%20at%204.21.01%20PM-08.png){width="509"}

Thresholds= Model 1

**Class Prevalence: Equal v. Unequal 1 = .33.3, .33.3, 33.3 ; 2 = .60, .30, .10**

#### Simulation Setup: Model 5

We will now run a Monte Carlo simulation for Model 5. The simulation will iterate over different combinations of sample sizes, transition probabilities, and mixing proportion components. The following code sets up the cluster for parallel processing and defines the function to run the simulation.

```{r, eval = FALSE}

#| label: "lta-rilta-simulation-Model 5"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true


# Step 1: Create the cluster (use PSOCK for Windows)
num_cores <- detectCores() - 1  # Detect number of cores
cl <- makeCluster(num_cores, type = "PSOCK")    # Create the cluster with PSOCK

RILTA_RILTA_func5 <- function(N, TPs, mix) {
  
  # Construct the MODELPOPULATION argument based on the value of mix
  MODELPOPULATION <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
        	
       f by u11*.9 u12*1.2 u13*.9 u14*1 u15*3.5 (p1-p5)
            u21*.9 u22*1.2 u23*.9 u24*1 u25*3.5 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
    
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;

      	
       f by u11*.9 u12*1.2 u13*.9 u14*1 u15*3.5 (p1-p5)
            u21*.9 u22*1.2 u23*.9 u24*1 u25*3.5 (p1-p5);
        f@1;
        [f@0];
        
        
      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	
      
       f by u11*.9 u12*1.2 u13*.9 u14*1 u15*3.5 (p1-p5)
            u21*.9 u22*1.2 u23*.9 u24*1 u25*3.5 (p1-p5);
        f@1;
        [f@0];

      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2: 	
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
    
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

       f by u11*.9 u12*1.2 u13*.9 u14*1 u15*3.5 (p1-p5)
            u21*.9 u22*1.2 u23*.9 u24*1 u25*3.5 (p1-p5);
        f@1;
        [f@0];

      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2: 	
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  }

  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
 
    ")
  }

  # Construct the Mplus object
  RILTA_RILTA5 <- mplusObject(
    TITLE = glue("RILTA_RILTA_M1_N_{N}_TP_{TPs}_M_{mix}_L_Y"),
    MONTECARLO = glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N};
      SEED = 07252005;
      NREPS = 500;
      !SAVE = repM5*.dat;
      RESULTS = RILTA_RILTA_M1_N_{N}_TP_{TPs}_M_{mix}_L_Y.csv;"),
    
    
    ANALYSIS = "TYPE = MIXTURE;
      algorithm = integration;
      STARTS = 50 10;
      processors = 24;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_RILTA_Model5<- mplusModeler(RILTA_RILTA5, 
                                   dataout = here('Simulations', 'STUDY_2', '4_RILTA_GEN_RILTA_ANALYZED', glue("RILTA_RILTA_M1_N_{N}_TP_{TPs}_M_{mix}_L_Y.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '4_RILTA_GEN_RILTA_ANALYZED', "RILTA_RILTA_M1_N_{N}_TP_{TPs}_M_{mix}_L_Y.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_RILTA_Model5)
}

# Step 3: Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_rilta_func5", "p1")))

# Ensure that the packages are loaded on each cluster node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(p1), function(i) {
  RILTA_RILTA_func5(p1$N[i], p1$TPs[i], p1$mix[i])
               })

stopCluster(cl)
```

# Model 6: PATTERN M1_Z

# RILTA Generated, LTA Analyzed

### Conditions:

Sample Size: N = 500, 1000, 2500, 5500

Transition logit (Probability): TPs = 3.179 (Stayer), 0.407 (Mover)

![](images/clipboard-2891141057.png){width="352"}

RI Loadings: lambda = Pattern Z

![](images/Screenshot%202024-08-31%20at%204.21.01%20PM-08.png){width="509"}

Thresholds: Model 1

**Class Prevalence: Equal v. Unequal 1 = .33.3, .33.3, 33.3 ; 2 = .60, .30, .10**

#### Simulation Setup: Model 6

We will now run a Monte Carlo simulation for Model 6. The simulation will iterate over different combinations of sample sizes, transition probabilities, and mixing proportion components. The following code sets up the cluster for parallel processing and defines the function to run the simulation.

```{r, eval = FALSE}

#| label: "lta-rilta-simulation-Model 6"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Step 1: Create the cluster (use PSOCK for Windows)
num_cores <- detectCores() - 1  # Detect number of cores
cl <- makeCluster(num_cores, type = "PSOCK")    # Create the cluster with PSOCK

RILTA_RILTA_func6 <- function(N, TPs, mix) {
  
  # Construct the MODELPOPULATION argument based on the value of mix
  MODELPOPULATION <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.1 u12*2.3 u13*3.1 u14*3 u15*6.5 (p1-p5)
            u21*.2 u22*2.4 u23*3.1 u24*3 u25*6.5 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
    
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.1 u12*2.3 u13*3.1 u14*3 u15*6.5 (p1-p5)
            u21*.2 u22*2.4 u23*3.1 u24*3 u25*6.5 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

       f by u11*.1 u12*2.3 u13*3.1 u14*3 u15*6.5 (p1-p5)
            u21*.2 u22*2.4 u23*3.1 u24*3 u25*6.5 (p1-p5);
        f@1;
        [f@0];
        
      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2: 	
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
    
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

       f by u11*.1 u12*2.3 u13*3.1 u14*3 u15*6.5 (p1-p5)
            u21*.2 u22*2.4 u23*3.1 u24*3 u25*6.5 (p1-p5);
        f@1;
        [f@0];
        
      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2: 	
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  }

  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  }

  # Construct the Mplus object
  RILTA_RILTA6 <- mplusObject(
    TITLE = glue("RILTA_RILTA_M1_N_{N}_TP_{TPs}_M_{mix}_L_Z"),
    MONTECARLO = glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N};
      SEED = 07252005;
      NREPS = 500;
      !SAVE = repM6*.dat;
      RESULTS = RILTA_RILTA_M1_N_{N}_TP_{TPs}_M_{mix}_L_Z.csv;"),
    
    
    ANALYSIS = "TYPE = MIXTURE;
      algorithm = integration;
      STARTS = 50 10;
      processors = 24;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_RILTA_Model6<- mplusModeler(RILTA_RILTA6, 
                                   dataout = here('Simulations', 'STUDY_2', '4_RILTA_GEN_RILTA_ANALYZED', glue("RILTA_RILTA_M1_N_{N}_TP_{TPs}_M_{mix}_L_Z.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '4_RILTA_GEN_RILTA_ANALYZED', "RILTA_RILTA_M1_N_{N}_TP_{TPs}_M_{mix}_L_Z.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_RILTA_Model6)
}

# Step 3: Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_rilta_func6", "p1")))

# Ensure that the packages are loaded on each cluster node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(p1), function(i) {
  RILTA_RILTA_func6(p1$N[i], p1$TPs[i], p1$mix[i])
               })

stopCluster(cl)
```

# Model 7: PATTERN M2_X

### Conditions:

Sample Size: N = 500, 1000, 2500, 5500

Transition logit (Probability): TPs = 3.179 (Stayer), 0.407 (Mover)

![](images/clipboard-2891141057.png){width="352"}

RI Loadings: lambda = Pattern X

![](images/Screenshot%202024-08-31%20at%204.21.01%20PM-08.png){width="509"}

Thresholds= Model 2

![](images/clipboard-3697136395.png){width="226"}

**Class Prevalence: Equal v. Unequal 1 = .33.3, .33.3, 33.3 ; 2 = .60, .30, .10**

#### Simulation Setup: Model 7

We will now run a Monte Carlo simulation for Model 7. The simulation will iterate over different combinations of sample sizes, transition probabilities, and mixing proportion components. The following code sets up the cluster for parallel processing and defines the function to run the simulation.

```{r, eval = FALSE}

#| label: "lta-rilta-simulation-Model 7"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true


# Step 1: Create the cluster (use PSOCK for Windows)
num_cores <- detectCores() - 1  # Detect number of cores
cl <- makeCluster(num_cores, type = "PSOCK")    # Create the cluster with PSOCK

RILTA_RILTA_func7 <- function(N, TPs, mix) {
  
  # Construct the MODELPOPULATION argument based on the value of mix
  MODELPOPULATION <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.1 u12*.1 u13*.2 u14*.1 u15*2 (p1-p5)
            u21*.1 u22*.1 u23*.2 u24*.1 u25*2 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
    
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.1 u12*.1 u13*.2 u14*.1 u15*2 (p1-p5)
            u21*.1 u22*.1 u23*.2 u24*.1 u25*2 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

       f by u11*.1 u12*.1 u13*.2 u14*.1 u15*2 (p1-p5)
            u21*.1 u22*.1 u23*.2 u24*.1 u25*2 (p1-p5);
        f@1;
        [f@0];
        
      MODEL c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL c2: 	
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
    
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	


       f by u11*.1 u12*.1 u13*.2 u14*.1 u15*2 (p1-p5)
            u21*.1 u22*.1 u23*.2 u24*.1 u25*2 (p1-p5);
        f@1;
        [f@0];
        
      MODEL c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL c2: 	
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
  }

  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);

    ")
  }

  # Construct the Mplus object
  RILTA_RILTA7 <- mplusObject(
    TITLE = glue("RILTA_RILTA_M2_N_{N}_TP_{TPs}_M_{mix}_L_X"),
    MONTECARLO = glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N};
      SEED = 07252005;
      NREPS = 500;
      !SAVE = repM7*.dat;
      RESULTS = RILTA_RILTA_M2_N_{N}_TP_{TPs}_M_{mix}_L_X.csv;"),
    
    
    ANALYSIS = "TYPE = MIXTURE;
      algorithm = integration;
      STARTS = 50 10;
      processors = 24;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_RILTA_Model7<- mplusModeler(RILTA_RILTA7, 
                                   dataout = here('Simulations', 'STUDY_2', '4_RILTA_GEN_RILTA_ANALYZED', glue("RILTA_RILTA_M2_N_{N}_TP_{TPs}_M_{mix}_L_X.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '4_RILTA_GEN_RILTA_ANALYZED', "RILTA_RILTA_M2_N_{N}_TP_{TPs}_M_{mix}_L_X.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_RILTA_Model7)
}

# Step 3: Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_rilta_func7", "p1")))

# Ensure that the packages are loaded on each cluster node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(p1), function(i) {
  RILTA_RILTA_func7(p1$N[i], p1$TPs[i], p1$mix[i])
               })

stopCluster(cl)
```

# Model 8: Pattern M2_Y

### Conditions:

Sample Size: N = 500, 1000, 2500, 5500

Transition logit (Probability): TPs = 3.179 (Stayer), 0.407 (Mover)

![](images/clipboard-2891141057.png){width="352"}

RI Loadings: lambda = Pattern Y

![](images/Screenshot%202024-08-31%20at%204.21.01%20PM-08.png){width="509"}

Thresholds= Model 2

**Class Prevalence: Equal v. Unequal 1 = .33.3, .33.3, 33.3 ; 2 = .60, .30, .10**

#### Simulation Setup: Model 8

We will now run a Monte Carlo simulation for Model 8. The simulation will iterate over different combinations of sample sizes, transition probabilities, and mixing proportion components. The following code sets up the cluster for parallel processing and defines the function to run the simulation.

```{r, eval = FALSE}

#| label: "lta-rilta-simulation-Model 8"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Step 1: Create the cluster (use PSOCK for Windows)
num_cores <- detectCores() - 1  # Detect number of cores
cl <- makeCluster(num_cores, type = "PSOCK")    # Create the cluster with PSOCK

RILTA_RILTA_func8 <- function(N, TPs, mix) {
  
  # Construct the MODELPOPULATION argument based on the value of mix
  MODELPOPULATION <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.9 u12*1.2 u13*.9 u14*1 u15*3.5 (p1-p5)
            u21*.9 u22*1.2 u23*.9 u24*1 u25*3.5 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
    
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.9 u12*1.2 u13*.9 u14*1 u15*3.5 (p1-p5)
            u21*.9 u22*1.2 u23*.9 u24*1 u25*3.5 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

       f by u11*.9 u12*1.2 u13*.9 u14*1 u15*3.5 (p1-p5)
            u21*.9 u22*1.2 u23*.9 u24*1 u25*3.5 (p1-p5);
        f@1;
        [f@0];
        
      MODEL c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL c2: 	
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
    
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

       f by u11*.9 u12*1.2 u13*.9 u14*1 u15*3.5 (p1-p5)
            u21*.9 u22*1.2 u23*.9 u24*1 u25*3.5 (p1-p5);
        f@1;
        [f@0];
        
      MODEL c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL c2: 	
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
  }

  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  }

  # Construct the Mplus object
  RILTA_RILTA8 <- mplusObject(
    TITLE = glue("RILTA_RILTA_M2_N_{N}_TP_{TPs}_M_{mix}_L_Y"),
    MONTECARLO = glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N};
      SEED = 07252005;
      NREPS = 500;
      !SAVE = repM8*.dat;
      RESULTS = RILTA_RILTA_M2_N_{N}_TP_{TPs}_M_{mix}_L_Y.csv;"),
    
    ANALYSIS = "TYPE = MIXTURE;
      algorithm = integration;
      processors = 24;
      STARTS 50 10;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_RILTA_Model8<- mplusModeler(RILTA_RILTA8, 
                                   dataout = here('Simulations', 'STUDY_2', '4_RILTA_GEN_RILTA_ANALYZED', glue("RILTA_RILTA_M2_N_{N}_TP_{TPs}_M_{mix}_L_Y.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '4_RILTA_GEN_RILTA_ANALYZED', "RILTA_RILTA_M2_N_{N}_TP_{TPs}_M_{mix}_L_Y.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_RILTA_Model8)
}

# Step 3: Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_rilta_func8", "p1")))

# Ensure that the packages are loaded on each cluster node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(p1), function(i) {
  RILTA_RILTA_func8(p1$N[i], p1$TPs[i], p1$mix[i])
               })

stopCluster(cl)
```

# Model 9: PATTERN M2_Z

### Conditions:

Sample Size: N = 500, 1000, 2500, 5500

Transition logit (Probability): TPs = 3.179 (Stayer), 0.407 (Mover)

![](images/clipboard-2891141057.png){width="352"}

RI Loadings: lambda = Pattern Z

![](images/Screenshot%202024-08-31%20at%204.21.01%20PM-08.png){width="509"}

Thresholds= Model 2

**Class Prevalence: Equal v. Unequal 1 = .33.3, .33.3, 33.3 ; 2 = .60, .30, .10**

#### Simulation Setup: Model 9

We will now run a Monte Carlo simulation for Model 9. The simulation will iterate over different combinations of sample sizes, transition probabilities, and mixing proportion components. The following code sets up the cluster for parallel processing and defines the function to run the simulation.

```{r, eval = FALSE}

#| label: "lta-rilta-simulation-Model 9"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Step 1: Create the cluster (use PSOCK for Windows)
num_cores <- detectCores() - 1  # Detect number of cores
cl <- makeCluster(num_cores, type = "PSOCK")    # Create the cluster with PSOCK

RILTA_RILTA_func9 <- function(N, TPs, mix) {
  
  # Construct the MODELPOPULATION argument based on the value of mix
  MODELPOPULATION <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.1 u12*2.3 u13*3.1 u14*3 u15*6.5 (p1-p5)
            u21*.2 u22*2.4 u23*3.1 u24*3 u25*6.5 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
    
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.1 u12*2.3 u13*3.1 u14*3 u15*6.5 (p1-p5)
            u21*.2 u22*2.4 u23*3.1 u24*3 u25*6.5 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

       f by u11*.1 u12*2.3 u13*3.1 u14*3 u15*6.5 (p1-p5)
            u21*.2 u22*2.4 u23*3.1 u24*3 u25*6.5 (p1-p5);
        f@1;
        [f@0];
        
      MODEL c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL c2: 	
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
    
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);
      
       f by u11*.1 u12*2.3 u13*3.1 u14*3 u15*6.5 (p1-p5)
            u21*.2 u22*2.4 u23*3.1 u24*3 u25*6.5 (p1-p5);
        f@1;
        [f@0];
        
      MODEL c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL c2: 	
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
  }

  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      

    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  }

  # Construct the Mplus object
  RILTA_RILTA9 <- mplusObject(
    TITLE = glue("RILTA_RILTA_M2_N_{N}_TP_{TPs}_M_{mix}_L_Z"),
    MONTECARLO = glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N};
      SEED = 07252005;
      NREPS = 500;
      !SAVE = repM9*.dat;
      RESULTS = RILTA_RILTA_M2_N_{N}_TP_{TPs}_M_{mix}_L_Z.csv;"),
    
    ANALYSIS = "TYPE = MIXTURE;
      algorithm = integration;
      STARTS 50 10;
      processors = 24;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_RILTA_Model9<- mplusModeler(RILTA_RILTA9, 
                                   dataout = here('Simulations', 'STUDY_2', '4_RILTA_GEN_RILTA_ANALYZED', glue("RILTA_RILTA_M2_N_{N}_TP_{TPs}_M_{mix}_L_Z.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '4_RILTA_GEN_RILTA_ANALYZED', "RILTA_RILTA_M2_N_{N}_TP_{TPs}_M_{mix}_L_Z.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_RILTA_Model9)
}

# Step 3: Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_rilta_func9", "p1")))

# Ensure that the packages are loaded on each cluster node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(p1), function(i) {
  RILTA_RILTA_func9(p1$N[i], p1$TPs[i], p1$mix[i])
               })

stopCluster(cl)
```

# Model 10: Pattern M3_X

### Conditions:

Sample Size: N = 500, 1000, 2500, 5500

Transition logit (Probability): TPs = 3.179 (Stayer), 0.407 (Mover)

![](images/clipboard-2891141057.png){width="352"}

RI Loadings: lambda = PATTERN X

![](images/Screenshot%202024-08-31%20at%204.21.01%20PM-08.png){width="509"}

Thresholds= Model 2

![](images/clipboard-260898834.png){width="328"}

**Class Prevalence: Equal v. Unequal 1 = .33.3, .33.3, 33.3 ; 2 = .60, .30, .10**

#### Simulation Setup: Model 10

We will now run a Monte Carlo simulation for Model 10. The simulation will iterate over different combinations of sample sizes, transition probabilities, and mixing proportion components. The following code sets up the cluster for parallel processing and defines the function to run the simulation.

```{r, eval = FALSE}

#| label: "lta-rilta-simulation-Model 10"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Step 1: Create the cluster (use PSOCK for Windows)
num_cores <- detectCores() - 1  # Detect number of cores
cl <- makeCluster(num_cores, type = "PSOCK")    # Create the cluster with PSOCK

RILTA_RILTA_func10 <- function(N, TPs, mix) {
  
    # Construct the MODELPOPULATION argument based on the value of mix
  MODELPOPULATION <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.1 u12*.1 u13*.2 u14*.1 u15*2 (p1-p5)
            u21*.1 u22*.1 u23*.2 u24*.1 u25*2 (p1-p5);
        f@1;
        [f@0];
          
        MODEL POPULATION-c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
       ")
    
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.1 u12*.1 u13*.2 u14*.1 u15*2 (p1-p5)
            u21*.1 u22*.1 u23*.2 u24*.1 u25*2 (p1-p5);
        f@1;
        [f@0];
              
     MODEL POPULATION-c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
       ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

       f by u11*.1 u12*.1 u13*.2 u14*.1 u15*2 (p1-p5)
            u21*.1 u22*.1 u23*.2 u24*.1 u25*2 (p1-p5);
        f@1;
        [f@0];
        
     MODEL c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
	      ")      
      
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	      

       f by u11*.1 u12*.1 u13*.2 u14*.1 u15*2 (p1-p5)
            u21*.1 u22*.1 u23*.2 u24*.1 u25*2 (p1-p5);
        f@1;
        [f@0];
        
     MODEL c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
	      ")      
  }
    
  
  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  }
  
  RILTA_RILTA10 <- mplusObject(
    TITLE = glue("Generate RILTA_RILTA_M3_N_{N}_TP_{TPs}_M_{mix}_L_X"),

    MONTECARLO =
      glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N};
      SEED = 07252005;
      NREPS = 500;
      !SAVE = repM10*.dat;
      RESULTS = RILTA_RILTA_M3_N_{N}_TP_{TPs}_M_{mix}_L_X.csv;"),
    
    
    ANALYSIS = "TYPE = MIXTURE;
    Algorithm = INTEGRATION;
      STARTS = 50 10;
      processors = 24;
      logcriterion=0.00001;
      mconv=0.00001;",

    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_RILTA_Model10<- mplusModeler(RILTA_RILTA10, 
                                   dataout = here('Simulations', 'STUDY_2', '4_RILTA_GEN_RILTA_ANALYZED', glue("RILTA_RILTA_M3_N_{N}_TP_{TPs}_M_{mix}_L_X.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '4_RILTA_GEN_RILTA_ANALYZED', "RILTA_RILTA_M3_N_{N}_TP_{TPs}_M_{mix}_L_X.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_RILTA_Model10)
}

# Step 3: Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_rilta_func10", "p1")))

# Ensure that the packages are loaded on each cluster node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(p1), function(i) {
  RILTA_RILTA_func10(p1$N[i], p1$TPs[i], p1$mix[i])
})


stopCluster(cl)
```

# Model 11: PATTERN M3_Y

### Conditions:

Sample Size: N = 500, 1000, 2500, 5500

Transition logit (Probability): TPs = 3.179 (Stayer), 0.407 (Mover)

![](images/clipboard-2891141057.png){width="352"}

RI Loadings: lambda = Pattern Y

![](images/Screenshot%202024-08-31%20at%204.21.01%20PM-08.png){width="509"}

Thresholds= Model 3

**Class Prevalence: Equal v. Unequal 1 = .33.3, .33.3, 33.3 ; 2 = .60, .30, .10**

#### Simulation Setup: Model 11

We will now run a Monte Carlo simulation for Model 11. The simulation will iterate over different combinations of sample sizes, transition probabilities, and mixing proportion components. The following code sets up the cluster for parallel processing and defines the function to run the simulation.

```{r, eval = FALSE}

#| label: "lta-rilta-simulation-Model 11"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Step 1: Create the cluster (use PSOCK for Windows)
num_cores <- detectCores() - 1  # Detect number of cores
cl <- makeCluster(num_cores, type = "PSOCK")    # Create the cluster with PSOCK

RILTA_RILTA_func11 <- function(N, TPs, mix) {
  
    # Construct the MODELPOPULATION argument based on the value of mix
  MODELPOPULATION <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.9 u12*1.2 u13*.9 u14*1 u15*3.5 (p1-p5)
            u21*.9 u22*1.2 u23*.9 u24*1 u25*3.5 (p1-p5);
        f@1;
        [f@0];
          
        MODEL POPULATION-c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
       ")
    
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.9 u12*1.2 u13*.9 u14*1 u15*3.5 (p1-p5)
            u21*.9 u22*1.2 u23*.9 u24*1 u25*3.5 (p1-p5);
        f@1;
        [f@0];
              
     MODEL POPULATION-c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
       ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

       f by u11*.9 u12*1.2 u13*.9 u14*1 u15*3.5 (p1-p5)
            u21*.9 u22*1.2 u23*.9 u24*1 u25*3.5 (p1-p5);
        f@1;
        [f@0];
        
     MODEL c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
	      ")      
      
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	      

       f by u11*.9 u12*1.2 u13*.9 u14*1 u15*3.5 (p1-p5)
            u21*.9 u22*1.2 u23*.9 u24*1 u25*3.5 (p1-p5);
        f@1;
        [f@0];
        
     MODEL c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
	      ")      
  }
    
  
  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  }
  
  RILTA_RILTA11 <- mplusObject(
    TITLE = glue("Generate RILTA_RILTA_M3_N_{N}_TP_{TPs}_M_{mix}_L_Y"),

    MONTECARLO =
      glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N};
      SEED = 07252005;
      NREPS = 500;
      !SAVE = repM11*.dat;
      RESULTS = RILTA_RILTA_M3_N_{N}_TP_{TPs}_M_{mix}_L_Y.csv;"),
    
    
    ANALYSIS = "TYPE = MIXTURE;
    Algorithm = INTEGRATION;
      STARTS = 50 10;
      processors = 24;
      logcriterion=0.00001;
      mconv=0.00001;",

    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_RILTA_Model11<- mplusModeler(RILTA_RILTA11, 
                                   dataout = here('Simulations', 'STUDY_2', '4_RILTA_GEN_RILTA_ANALYZED', glue("RILTA_RILTA_M3_N_{N}_TP_{TPs}_M_{mix}_L_Y.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '4_RILTA_GEN_RILTA_ANALYZED', "RILTA_RILTA_M3_N_{N}_TP_{TPs}_M_{mix}_L_Y.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_RILTA_Model11)
}

# Step 3: Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_rilta_func11", "p1")))

# Ensure that the packages are loaded on each cluster node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(p1), function(i) {
  RILTA_RILTA_func11(p1$N[i], p1$TPs[i], p1$mix[i])
})


stopCluster(cl)
```

# Model 12: Pattern M3_Z

### Conditions:

Sample Size: N = 500, 1000, 2500, 5500

Transition logit (Probability): TPs = 3.179 (Stayer), 0.407 (Mover)

![](images/clipboard-2891141057.png){width="352"}

RI Loadings: lambda = Pattern

![](images/Screenshot%202024-08-31%20at%204.21.01%20PM-08.png){width="509"}

Model 3

**Class Prevalence: Equal v. Unequal 1 = .33.3, .33.3, 33.3 ; 2 = .60, .30, .10**

#### Simulation Setup: Model 12

We will now run a Monte Carlo simulation for Model 12. The simulation will iterate over different combinations of sample sizes, transition probabilities, and mixing proportion components. The following code sets up the cluster for parallel processing and defines the function to run the simulation.

```{r, eval = FALSE}

#| label: "lta-rilta-simulation-Model 12"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Step 1: Create the cluster (use PSOCK for Windows)
num_cores <- detectCores() - 1  # Detect number of cores
cl <- makeCluster(num_cores, type = "PSOCK")    # Create the cluster with PSOCK

RILTA_RILTA_func12 <- function(N, TPs, mix) {
  
    # Construct the MODELPOPULATION argument based on the value of mix
  MODELPOPULATION <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.1 u12*2.3 u13*3.1 u14*3 u15*6.5 (p1-p5)
            u21*.2 u22*2.4 u23*3.1 u24*3 u25*6.5 (p1-p5);
        f@1;
        [f@0];
          
        MODEL POPULATION-c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
       ")
    
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.1 u12*2.3 u13*3.1 u14*3 u15*6.5 (p1-p5)
            u21*.2 u22*2.4 u23*3.1 u24*3 u25*6.5 (p1-p5);
        f@1;
        [f@0];
              
     MODEL POPULATION-c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
       ")
  }

  # Construct the MODEL argument based on the value of mix
  MODEL <- if (mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

       f by u11*.1 u12*2.3 u13*3.1 u14*3 u15*6.5 (p1-p5)
            u21*.2 u22*2.4 u23*3.1 u24*3 u25*6.5 (p1-p5);
        f@1;
        [f@0];

     MODEL c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
	      ")      
      
  } else if (mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	      

       f by u11*.1 u12*2.3 u13*3.1 u14*3 u15*6.5 (p1-p5)
            u21*.2 u22*2.4 u23*3.1 u24*3 u25*6.5 (p1-p5);
        f@1;
        [f@0];

     MODEL c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
	      ")      
  }
    
  
  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  }
  
  RILTA_RILTA12 <- mplusObject(
    TITLE = glue("Generate RILTA_RILTA_M3_N_{N}_TP_{TPs}_M_{mix}_L_Z"),

    MONTECARLO =
      glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N};
      SEED = 07252005;
      NREPS = 500;
      !SAVE = repM12*.dat;
      RESULTS = RILTA_RILTA_M3_N_{N}_TP_{TPs}_M_{mix}_L_Z.csv;"),
    
    
    ANALYSIS = "TYPE = MIXTURE;
      algorithm = integration;
      STARTS = 50 10;
      processors = 24;
      logcriterion=0.00001;
      mconv=0.00001;",

    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_RILTA_Model12<- mplusModeler(RILTA_RILTA12, 
                                   dataout = here('Simulations', 'STUDY_2', '4_RILTA_GEN_RILTA_ANALYZED', glue("RILTA_RILTA_M3_N_{N}_TP_{TPs}_M_{mix}_L_Z.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '4_RILTA_GEN_RILTA_ANALYZED', "RILTA_RILTA_M3_N_{N}_TP_{TPs}_M_{mix}_L_Z.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_RILTA_Model12)
}

# Step 3: Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_rilta_func12", "p1")))

# Ensure that the packages are loaded on each cluster node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(p1), function(i) {
  RILTA_RILTA_func12(p1$N[i], p1$TPs[i], p1$mix[i])
})

stopCluster(cl)

```

# CHECK FOR LABEL SWITCHING

### Step 1: Combine All CSV Files into One Data Frame

**Objective:** 

*Load all CSV files and combine them into a single data frame.*

```{r}
#| label: "combine-csv-files-parallel"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true


# Step 1: Set the correct CSV directory
csv_directory <- here('Simulations', 'STUDY_2', '4_RILTA_GEN_RILTA_ANALYZED')

# Step 2: Source the child document
source(here('Child_Docs', 'data_scraping.R'))
```

### Step 2: Scrape Rows and Process Data

**Objective:** 

*Extract the first 3 rows from each 12-row chunk and prepare the data for further processing.*

```{r}
#| label: "scrape-rows-process-data-parallel"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Step 2: Process the data using the child script
source(here('Child_Docs', 'step2_f_RILTA.R'))
#returns df final_combined_data
```

### Step 3: Convert Logits to Probabilities and Add Actual (Population) Values

**Objective:** 

*Convert the logits to probabilities and add the known actual values to each row.*

```{r}
#| label: "convert-logits-and-flags"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Step 3 and 4: Process the data and return results
source(here('Child_Docs', 'step_3.r'))

# The objects `final_data_with_actuals` and `violators` should now be in the global environment
```

### **Step 4: Plot Random Sample of Violators for Visual Inspection**

#### **Objective**

*Generate plots of randomly sampled violators for visual inspection using parallel processing.*

```{r, eval=FALSE}
#| label: "plot-violators"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Set plot dimensions
plot_width <- 8
plot_height <- 6

# Set seed and sample violators
set.seed(123)
sampled_violators <- violators[sample(nrow(violators), 250), ]

# Define the function to create and save plots for violators
plot_violator <- function(i) {
  row_data <- sampled_violators[i, ]
  file_name <- row_data$FileName  # Extract file name
  
  # Extract probabilities for EC1 through AC3
  probabilities <- c(
    as.numeric(row_data[c("Ec1u1", "Ec1u2", "Ec1u3", "Ec1u4", "Ec1u5")]),
    as.numeric(row_data[c("Ec2u1", "Ec2u2", "Ec2u3", "Ec2u4", "Ec2u5")]),
    as.numeric(row_data[c("Ec3u1", "Ec3u2", "Ec3u3", "Ec3u4", "Ec3u5")]),
    as.numeric(row_data[c("Ac1u1", "Ac1u2", "Ac1u3", "Ac1u4", "Ac1u5")]),
    as.numeric(row_data[c("Ac2u1", "Ac2u2", "Ac2u3", "Ac2u4", "Ac2u5")]),
    as.numeric(row_data[c("Ac3u1", "Ac3u2", "Ac3u3", "Ac3u4", "Ac3u5")])
  )
  
  # Create labels for the legend
  labels <- c(
    paste0("EC1: (", round(row_data$Ec1u1, 3), ", ", round(row_data$Ec1u2, 3), ", ", round(row_data$Ec1u3, 3), ", ", round(row_data$Ec1u4, 3), ", ", round(row_data$Ec1u5, 3), ")"),
    paste0("EC2: (", round(row_data$Ec2u1, 3), ", ", round(row_data$Ec2u2, 3), ", ", round(row_data$Ec2u3, 3), ", ", round(row_data$Ec2u4, 3), ", ", round(row_data$Ec2u5, 3), ")"),
    paste0("EC3: (", round(row_data$Ec3u1, 3), ", ", round(row_data$Ec3u2, 3), ", ", round(row_data$Ec3u3, 3), ", ", round(row_data$Ec3u4, 3), ", ", round(row_data$Ec3u5, 3), ")"),
    paste0("AC1: (", round(row_data$Ac1u1, 3), ", ", round(row_data$Ac1u2, 3), ", ", round(row_data$Ac1u3, 3), ", ", round(row_data$Ac1u4, 3), ", ", round(row_data$Ac1u5, 3), ")"),
    paste0("AC2: (", round(row_data$Ac2u1, 3), ", ", round(row_data$Ac2u2, 3), ", ", round(row_data$Ac2u3, 3), ", ", round(row_data$Ac2u4, 3), ", ", round(row_data$Ac2u5, 3), ")"),
    paste0("AC3: (", round(row_data$Ac3u1, 3), ", ", round(row_data$Ac3u2, 3), ", ", round(row_data$Ac3u3, 3), ", ", round(row_data$Ac3u4, 3), ", ", round(row_data$Ac3u5, 3), ")")
  )

  # Create data frame for plotting
  plot_data <- data.frame(
    Items = rep(1:5, 6),
    Probabilities = probabilities,
    Class = rep(labels, each = 5)
  )

  # Generate the plot
  p <- ggplot(plot_data, aes(x = Items, y = Probabilities, color = Class, group = Class)) +
    geom_line(size = 1.2) +
    geom_point(size = 3) +
    labs(title = file_name, x = "Items", y = "Probabilities") +
    theme_minimal(base_size = 16) +
    theme(
      panel.background = element_rect(fill = "white"),
      plot.background = element_rect(fill = "white"),
      plot.title = element_text(size = 14, hjust = 0.5)
    ) +
    scale_color_manual(values = c(
      "darkblue", "darkgreen", "darkred",  # AC1 to AC3
      "lightblue", "lightgreen", "lightcoral"  # EC1 to EC3
    ))

  # Save the plot to the specified folder
  ggsave(filename = file.path("z2t_lta_rilta_violator_plots", paste0("violator_plot_", i, "_", file_name, ".png")),
         plot = p, width = plot_width, height = plot_height)
}

# Generate and save plots for each sampled violator
invisible(lapply(1:nrow(sampled_violators), plot_violator))

```

### **Step 5: Summarize Violations**

#### **Objective**

*Calculate the percentage of violations for each file, handling missing values appropriately.*

#### Step 5: Part 1 Scrape Output Files for Errors for specific replications

```{r}
#| label: "summarize-errors"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

library(parallel)

extract_errors_from_file <- function(filepath, total_replications) {
  lines <- readLines(filepath)
  results <- vector("list", total_replications)
  error_keywords <- c("NON-POSITIVE DEFINITE", "SADDLE")

  # Initialize results for every replication
  for (rep in 1:total_replications) {
    results[[rep]] <- tibble(
      FileName = basename(filepath),
      Replication = rep,
      Message = "None",
      MessageType = "None"
    )
  }

  current_replication <- NULL
  for (line in lines) {
    if (str_detect(line, "REPLICATION")) {
      current_replication <- as.integer(str_extract(line, "\\d+"))
    }

    if (!is.null(current_replication) && current_replication <= total_replications &&
        any(sapply(error_keywords, grepl, line, ignore.case = TRUE))) {
      results[[current_replication]] <- tibble(
        FileName = basename(filepath),
        Replication = current_replication,
        Message = str_trim(line),
        MessageType = "Error"
      )
    }
  }

  return(bind_rows(results))
}

# Step 2: Extract Completed Replications
extract_completed_replications <- function(filepath) {
  lines <- readLines(filepath)
  completed_line <- lines[grepl("Completed", lines, ignore.case = TRUE)]
  completed <- as.integer(str_match(completed_line, "Completed\\s+(\\d+)")[, 2])
  if (length(completed) == 0) completed <- 0
  tibble(FileName = basename(filepath), CompletedReplications = completed)
}


# Step 3: Extract Requested Replications
extract_requested_replications <- function(filepath) {
  lines <- readLines(filepath)
  requested_line <- lines[grepl("Requested", lines, ignore.case = TRUE)]
  requested <- as.integer(str_match(requested_line, "Requested\\s+(\\d+)")[, 2])
  if (length(requested) == 0) requested <- 0
  tibble(FileName = basename(filepath), RequestedReplications = requested)
}

calculate_replication_summary <- function(error_summary, completed_replications, requested_replications) {
  summary <- error_summary %>%
    group_by(FileName) %>%
    summarise(
      ErrorReplications = n_distinct(Replication[MessageType == "Error"]),
      .groups = "drop"
    )

  full_summary <- requested_replications %>%
    left_join(completed_replications, by = "FileName") %>%
    left_join(summary, by = "FileName") %>%
    mutate(
      ErrorReplications = coalesce(ErrorReplications, 0),
      GoodReplications = CompletedReplications - ErrorReplications,
      ErrorRate = if_else(CompletedReplications > 0, (ErrorReplications / CompletedReplications) * 100, 0)
    ) %>%
    select(FileName, RequestedReplications, CompletedReplications, ErrorReplications, GoodReplications, ErrorRate)

  full_summary
}

# Step 4: Parallelized Processing (Windows/Mac/Linux Compatible)
output_folder <- "4_RILTA_GEN_RILTA_ANALYZED"  # Adjust to your folder path
file_list <- list.files(output_folder, pattern = "\\.out$", full.names = TRUE)

# Step 5: Detect OS and Set Up Cluster
cluster_type <- ifelse(.Platform$OS.type == "windows", "PSOCK", "FORK")
num_cores <- detectCores() - 1  # Use all but one core
cl <- makeCluster(num_cores, type = cluster_type)

# Export necessary libraries and functions to the cluster
invisible(clusterExport(cl, c("extract_errors_from_file", "extract_completed_replications", "extract_requested_replications")))
invisible(clusterEvalQ(cl, library(tidyverse)))

# Step 6: Parallel Processing
# Calculate completed replications first
completed_rep_list <- parLapply(cl, file_list, extract_completed_replications)

# Extract errors while passing the total number of completed replications to the function
error_summary <- bind_rows(mapply(function(filepath, completed_data) {
  extract_errors_from_file(filepath, completed_data$CompletedReplications)
}, file_list, completed_rep_list, SIMPLIFY = FALSE))

completed_replications <- bind_rows(parLapply(cl, file_list, extract_completed_replications))
requested_replications <- bind_rows(parLapply(cl, file_list, extract_requested_replications))

# Stop the cluster
stopCluster(cl)

# Step 7: Calculate Replication Summary
replication_summary <- calculate_replication_summary(error_summary, completed_replications, requested_replications)

# Step 8: Create and Display the Table with Error Rate
replication_summary_table <- replication_summary %>%
  gt() %>%
  tab_header(
    title = "Replication Summary",
    subtitle = paste0("Folder: ", output_folder)
  ) %>%
  fmt_number(columns = c(CompletedReplications, RequestedReplications, ErrorReplications, GoodReplications, ErrorRate), decimals = 2) %>%
  cols_label(
    FileName = "File Name",
    CompletedReplications = "Completed Replications",
    RequestedReplications = "Requested Replications",
    ErrorReplications = "Replications with Errors",
    GoodReplications = "Good Replications",
    ErrorRate = "Error Rate (%)"
  ) %>%
  tab_options(
    table.font.size = "small",
    heading.title.font.size = "medium",
    heading.subtitle.font.size = "small"
  )

# Display the table
replication_summary_table

completed_replications <- completed_replications %>%
  mutate(FileName = str_replace(FileName, "\\.out$", ""),
         FileName = tolower(FileName),
         FileName = str_trim(FileName))

error_summary <- error_summary %>%
  mutate(FileName = str_replace(FileName, "\\.out$", ""),
         FileName = tolower(FileName),
         FileName = str_trim(FileName))

final_data_with_actuals <- final_data_with_actuals %>%
  mutate(FileName = tolower(FileName),
         FileName = str_trim(FileName))

replication_summary <- replication_summary %>%
  mutate(FileName = str_replace(FileName, "\\.out$", ""),
         FileName = tolower(FileName),
         FileName = str_trim(FileName))

cat("Rows in final_data_with_actuals:", nrow(final_data_with_actuals), "\n")
# Output the final number of rows to confirm data handling
cat("Number of rows in error_summary: ", nrow(error_summary), "\n")
cat("Number of rows in replication_summary: ", nrow(replication_summary), "\n")

```

#### Step 5: Part 2 Merge errors with main data

```{r}
#| label: "merge-errors"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Ensure consistent column formats and remove .out and .csv extensions
error_summary <- error_summary %>%
  mutate(
    FileName = tolower(str_trim(gsub("\\.out$|\\.csv$", "", FileName))), # Remove extensions and standardize FileName
    Replication = as.character(Replication) # Convert Replication to character
  )

final_data_with_actuals <- final_data_with_actuals %>%
  mutate(
    FileName = tolower(str_trim(gsub("\\.out$|\\.csv$", "", FileName))), # Remove extensions and standardize FileName
    Replication = as.character(Replication) # Convert Replication to character
  )

# Add a new column to flag errors
error_summary <- error_summary %>%
  mutate(ErrorFlag = if_else(Message == "None", 0, 1))

# Merge ErrorFlag into final_data_with_actuals
final_data_with_actuals <- final_data_with_actuals %>%
  left_join(error_summary %>% select(FileName, Replication, ErrorFlag),
            by = c("FileName" = "FileName", "Replication" = "Replication"))
```

#### Step 5: Part 3 Create Columns from Filename

```{r}
#| label: "create-columns"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true


final_data_with_actuals <- final_data_with_actuals %>%
  mutate(
    Model = case_when(
      grepl("m1", FileName) ~ "1",
      grepl("m2", FileName) ~ "2",
      grepl("m3", FileName) ~ "3",
      TRUE ~ NA_character_
    ),
    N = case_when(
      grepl("n_5000", FileName) ~ 4,
      grepl("n_500", FileName) ~ 1,
      grepl("n_1000", FileName) ~ 2,
      grepl("n_2500", FileName) ~ 3,
      TRUE ~ NA_integer_
    ),
    Mixing_proportion = case_when(
      grepl("m_1", FileName) ~ 1,
      grepl("m_2", FileName) ~ 2,
      TRUE ~ NA_integer_
    ),
    Population = case_when(
      grepl("tp_0.407", FileName) ~ "0.200",
      grepl("tp_3.179", FileName) ~ "0.800",
      TRUE ~ NA_character_
    ),
    Lambda_values = case_when(
      grepl("l_0\\.5$", FileName) ~ "0.5",
      grepl("l_1\\.5$", FileName) ~ "1.5",
      grepl("l_3$", FileName) ~ "3",
      grepl("l_x$", FileName) ~ "X",
      grepl("l_y$", FileName) ~ "Y",
      grepl("l_z$", FileName) ~ "Z",
      TRUE ~ NA_character_
    )
  ) %>%
  mutate(
    Model = factor(Model, levels = c(1, 2, 3), labels = c("Model 1", "Model 2", "Model 3")),
    N = factor(N, levels = c(1, 2, 3, 4), labels = c("N = 500", "N = 1000", "N = 2500", "N = 5000")),
    Mixing_proportion = factor(Mixing_proportion, levels = c(1, 2), labels = c("Even Proportions", "Uneven Proportions")),
    Population = factor(Population, levels = c("0.200", "0.800"), labels = c(".200", ".800"))
  )



```

#### Step 5: Part 4 Calculate Violation Percentages per Condition to create new iterators

```{r}

#| label: "calculate-violations"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Step 6 Part 2: Summarize Violations and Adjust for Errors

# 1. Summarize violations per condition
violation_summary <- final_data_with_actuals %>%
  mutate(
    Any_Violation = ifelse(is.na(Any_Violation), 0, Any_Violation),
    ErrorFlag = ifelse(is.na(ErrorFlag), 0, ErrorFlag)  # Ensure no missing values for ErrorFlag
  ) %>%
  group_by(FileName, Model, Population, N, Mixing_proportion, Lambda_values) %>%
  summarize(
    Total_Rows = n(),                                # Total runs
    Total_Violations = sum(Any_Violation, na.rm = TRUE), # Total violations
    Total_Errors = sum(ErrorFlag, na.rm = TRUE),         # Total errors from ErrorFlag
    Percentage_Violations = (Total_Violations / Total_Rows) * 100, # % violations
    .groups = "drop"
  ) %>%
  # 2. Calculate Replications Needed for label switching
  mutate(
    N_numeric = as.numeric(gsub("N = ", "", as.character(N))), 
    Additional_Runs = (500 + Total_Violations) * (Percentage_Violations / 100), 
    Replications_Needed = ceiling(500 + Total_Violations + Additional_Runs + 20),
    Replications_Needed = if_else(Replications_Needed < 500, 500, Replications_Needed),
    ErrorRate = Total_Errors / Total_Rows,  # Calculate ErrorRate directly
    Adjusted_Replications_Needed = ceiling(Replications_Needed / (1 - ErrorRate)),
    Adjusted_Replications_Needed = if_else(Adjusted_Replications_Needed < 500, 500, Adjusted_Replications_Needed)
  ) %>%
  select(
    FileName, Model, Population, N, N_numeric, Mixing_proportion,
    Lambda_values, Total_Rows, Total_Violations, Total_Errors,
    ErrorRate, Percentage_Violations, Replications_Needed,
    Adjusted_Replications_Needed
  )

```

#### Step 5: Part 5 Summarize & Visualize Label Switching Percentage Results

```{r}
#| label: "create-new-iterators"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true


# Update violation_summary to include TPs, Mix, and adjusted replications
violation_summary <- violation_summary %>%
  mutate(
    # Transition Probabilities based on Population
    TPs = case_when(
      Population == ".800" ~ 3.179,
      Population == ".200" ~ 0.407,
      TRUE ~ NA_real_
    ),
    
    # Numeric Mix column
    Mix = case_when(
      Mixing_proportion == "Even Proportions" ~ 1,
      Mixing_proportion == "Uneven Proportions" ~ 2,
      TRUE ~ NA_integer_
    )
  )

# Function to create datasets based on model and lambda values
create_combined_model_data <- function(data, model, lambda_values) {
  data %>%
    filter(Model == model, Lambda_values %in% lambda_values) %>%
    select(
      `Transition Probability` = Population,             
      TPs,                                    # Numeric transition probabilities
      N,                                      # Categorical sample size
      N_numeric,                              # Numeric sample size
      `Mixing Proportion` = Mixing_proportion, # Even/Uneven proportions
      Mix,                                    # Numeric mix column
      Lambda = Lambda_values,                 # Lambda column
      `Total Mplus Runs` = Total_Rows,        # Total rows
      `Total Violations` = Total_Violations,  # Total Violations
      `% of Violations` = Percentage_Violations, # Violation percentage
      `Total Errors` = Total_Errors,           #Total Eerrors
      `Error Rate` = ErrorRate,               # Error Rate
      `Replications Needed` = Replications_Needed, # Original replications needed
       Adjusted_Replications_Needed           # Final replications
    )
}

# Datasets with multiple lambdas (0.5, 1.5, and 3)
model1_data <- create_combined_model_data(violation_summary, "Model 1", c("0.5", "1.5", "3"))
model2_data <- create_combined_model_data(violation_summary, "Model 2", c("0.5", "1.5", "3"))
model3_data <- create_combined_model_data(violation_summary, "Model 3", c("0.5", "1.5", "3"))

# Datasets with single lambdas (X, Y, and Z)
model4_data <- create_combined_model_data(violation_summary, "Model 1", c("X"))
model5_data <- create_combined_model_data(violation_summary, "Model 1", c("Y"))
model6_data <- create_combined_model_data(violation_summary, "Model 1", c("Z"))

model7_data <- create_combined_model_data(violation_summary, "Model 2", c("X"))
model8_data <- create_combined_model_data(violation_summary, "Model 2", c("Y"))
model9_data <- create_combined_model_data(violation_summary, "Model 2", c("Z"))

model10_data <- create_combined_model_data(violation_summary, "Model 3", c("X"))
model11_data <- create_combined_model_data(violation_summary, "Model 3", c("Y"))
model12_data <- create_combined_model_data(violation_summary, "Model 3", c("Z"))

# Define a function to create `gt` tables for models
create_gt_table <- function(data, model, Lambda) {
  data %>%
    gt() %>%
    tab_header(
      title = paste(model, ": Monte Carlo Results"),
      subtitle = paste("Lambda =", paste(Lambda, collapse = ", "), "- Label Switching and Errors Adjusted")
    ) %>%
    fmt_number(
      columns = c(`% of Violations`, `Error Rate`),
      decimals = 2
    ) %>%
    cols_align(align = "center", columns = everything()) %>%
    tab_options(
      table.font.size = "small",
      heading.title.font.size = "medium",
      heading.subtitle.font.size = "small"
    ) %>%
    tab_style(style = cell_text(align = "center"), locations = cells_column_labels(everything()))
}

# Generate tables for each model
model1_table <- create_gt_table(model1_data, "Model 1", c("0.5", "1.5", "3"))
model2_table <- create_gt_table(model2_data, "Model 2", c("0.5", "1.5", "3"))
model3_table <- create_gt_table(model3_data, "Model 3", c("0.5", "1.5", "3"))

model4_table <- create_gt_table(model4_data, "Model 1", c("X"))
model5_table <- create_gt_table(model5_data, "Model 1", c("Y"))
model6_table <- create_gt_table(model6_data, "Model 1", c("Z"))

model7_table <- create_gt_table(model7_data, "Model 2", c("X"))
model8_table <- create_gt_table(model8_data, "Model 2", c("Y"))
model9_table <- create_gt_table(model9_data, "Model 2", c("Z"))

model10_table <- create_gt_table(model10_data, "Model 3", c("X"))
model11_table <- create_gt_table(model11_data, "Model 3", c("Y"))
model12_table <- create_gt_table(model12_data, "Model 3", c("Z"))

# Print tables
model1_table
model2_table
model3_table
model4_table
model5_table
model6_table
model7_table
model8_table
model9_table
model10_table
model11_table
model12_table



```

#### Step 5: Part 5 RUN A REGRESSION on ERRORS

```{r}

# Ensure variables are factors with the correct levels
regression_data <- violation_summary %>%
  mutate(
    Model = factor(Model, levels = c("Model 1", "Model 2", "Model 3")),
    `Transition Probability` = factor(`Transition Probability`, levels = c(".800", ".200")),
    Lambda_values = factor(Lambda_values, levels = c("0.5", "1.5", "3", "X", "Y", "Z")),
    Mixing_proportion = factor(Mixing_proportion, levels = c("Even Proportions", "Uneven Proportions")),
    ErrorRate = ErrorRate * 100  # Convert ErrorRate to percentage
  )


# Run the regression
regression_model <- lm(
  ErrorRate ~ Model + `Transition Probability` + N + Lambda_values + Mixing_proportion,
  data = regression_data
)

# Extract overall regression statistics
r_squared <- model_summary$r.squared
adj_r_squared <- model_summary$adj.r.squared
f_statistic <- model_summary$fstatistic
f_p_value <- pf(f_statistic[1], f_statistic[2], f_statistic[3], lower.tail = FALSE)

# Simplify the p-value for presentation
formatted_p_value <- ifelse(f_p_value < .0001, "p < .0001", paste0("p = ", signif(f_p_value, 3)))

# Create the gt table for regression coefficients with a footer note
coefficients %>%
  gt() %>%
  tab_header(
    title = "Regression Model Summary",
    subtitle = "Error Rate Regression on Model and Predictors"
  ) %>%
  fmt_number(
    columns = c(Estimate, `Std. Error`, `t value`, `P-value`),
    decimals = 3
  ) %>%
  cols_align(align = "center", columns = everything()) %>%
  tab_options(
    table.font.size = "small",
    heading.title.font.size = "medium",
    heading.subtitle.font.size = "small"
  ) %>%
  tab_footnote(
    footnote = paste0(
      "Overall model fit: R² = ", round(r_squared, 3), 
      ", Adjusted R² = ", round(adj_r_squared, 3),
      ", F(", f_statistic[2], ", ", f_statistic[3], 
      ") = ", round(f_statistic[1], 2), 
      ", ", formatted_p_value
    ),
    locations = cells_title(groups = "subtitle")
  )

```

#### Step 5 Part 6 Followup ANOVA with Pairwise Comparisons

```{r}
# Load necessary libraries
library(emmeans)
library(gt)
library(dplyr)
library(broom)

# Perform ANOVA on regression_data
anova_results <- aov(ErrorRate ~ Model + `Transition Probability` + N + Lambda_values + Mixing_proportion, data = regression_data)

# Summarize the ANOVA results
anova_summary <- summary(anova_results)

# Create a tidy ANOVA table
anova_table <- broom::tidy(anova_summary[[1]]) %>%
  rename(
    Predictor = term,
    `Sum of Squares` = sumsq,
    `Degrees of Freedom` = df,
    `Mean Square` = meansq,
    `F-value` = statistic,
    `P-value` = p.value
  ) %>%
  mutate(`P-value` = ifelse(`P-value` < .0001, "< .0001", round(`P-value`, 4)))

# Perform Tukey pairwise comparisons for each predictor
pairwise_results <- list(
  Model = emmeans::emmeans(anova_results, "Model") %>%
    emmeans::contrast(method = "pairwise"),
  `Transition Probability` = emmeans::emmeans(anova_results, "Transition Probability") %>%
    emmeans::contrast(method = "pairwise"),
  N = emmeans::emmeans(anova_results, "N") %>%
    emmeans::contrast(method = "pairwise"),
  Lambda_values = emmeans::emmeans(anova_results, "Lambda_values") %>%
    emmeans::contrast(method = "pairwise"),
  Mixing_proportion = emmeans::emmeans(anova_results, "Mixing_proportion") %>%
    emmeans::contrast(method = "pairwise")
)

# Convert pairwise results into a single data frame
pairwise_results_df <- bind_rows(
  lapply(pairwise_results, function(x) as.data.frame(x) %>% rename(Comparison = contrast)),
  .id = "Predictor"
) %>%
  select(Predictor, Comparison, estimate, SE, t.ratio, p.value) %>%
  mutate(
    `P-value` = ifelse(p.value < .0001, "< .0001", round(p.value, 4))
  ) %>%
  select(-p.value)  # Remove raw p-value column

# Generate the ANOVA gt table
anova_table %>%
  gt() %>%
  tab_header(
    title = "ANOVA Results",
    subtitle = "Variance Analysis on Predictors"
  ) %>%
  fmt_number(
    columns = c(`Sum of Squares`, `Mean Square`, `F-value`),
    decimals = 3
  ) %>%
  cols_align(align = "center", columns = everything()) %>%
  tab_options(
    table.font.size = "small",
    heading.title.font.size = "medium",
    heading.subtitle.font.size = "small"
  )

# Generate the pairwise comparisons gt table
pairwise_results_df %>%
  gt() %>%
  tab_header(
    title = "Tukey Pairwise Comparisons",
    subtitle = "Within Predictors Only"
  ) %>%
  fmt_number(
    columns = c(estimate, SE, t.ratio),
    decimals = 3
  ) %>%
  cols_align(align = "center", columns = everything()) %>%
  tab_options(
    table.font.size = "small",
    heading.title.font.size = "medium",
    heading.subtitle.font.size = "small"
  )

```

# Part 2: Run Simulation again

#### Objective

*Conduct Simulation again with dynamic replications to account for error rates*\

## Model 1

```{r,eval = FALSE}

#| label: "lta-rilta-simulation-Model-1b"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

rilta_rilta_func <- function(N_numeric, TPs, Lambda, Mix, Adjusted_Replications_Needed) {

  
  # Construct the MODELPOPULATION argument based on the value of Mix
  MODELPOPULATION <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      
       f by u11-u15*{Lambda} (p1-p5)
            u21-u25*{Lambda} (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;

       f by u11-u15*{Lambda} (p1-p5)
            u21-u25*{Lambda} (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  }

  # Construct the MODEL argument based on the value of Mix
  MODEL <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

       f by u11-u15*{Lambda} (p1-p5)
            u21-u25*{Lambda} (p1-p5);
        f@1;
        [f@0];

      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2: 	
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	
      
       f by u11-u15*{Lambda} (p1-p5)
            u21-u25*{Lambda} (p1-p5);
        f@1;
        [f@0];      

      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2: 	
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  }

  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);

      
    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);

    ")
  }

  # Construct the Mplus object
  RILTA_RILTA <- mplusObject(
    TITLE = glue("RILTA_RILTA_M1_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_{Lambda}"),
    MONTECARLO = glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N_numeric};
      SEED = 07252005;
      NREPS = {Adjusted_Replications_Needed};
      !!SAVE = repM1*.dat;
      RESULTS = RILTA_RILTA_M1_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_{Lambda}.csv;"),
    
    
    ANALYSIS = "TYPE = MIXTURE;
      algorithm = integration;
      STARTS = 50 10;
      processors = 24;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_RILTA_Model<- mplusModeler(RILTA_RILTA, 
                                   dataout = here('Simulations', 'STUDY_2', '4_RILTA_GEN_RILTA_ANALYZED_REP', glue("RILTA_RILTA_M1_N_{N}_TP_{TPs}_M_{Mix}_L_{Lambda}.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '4_RILTA_GEN_RILTA_ANALYZED_REP', "RILTA_RILTA_M1_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_{Lambda}.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_RILTA_Model)
}

library(parallel)

# Start the cluster
num_cores <- detectCores() - 1

# Step 2: Select the cluster type based on the system (PSOCK for Windows, FORK for macOS/Linux)
cluster_type <- ifelse(.Platform$OS.type == "windows", "PSOCK", "FORK")


cl <- makeCluster(num_cores, type = cluster_type)

# Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_rilta_func", "model1_data", "here", "glue", "mplusModeler", "mplusObject")))

# Ensure required libraries are loaded on each node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(model1_data), function(i) {
  rilta_rilta_func(
    model1_data$N_numeric[i], 
    model1_data$TPs[i], 
    model1_data$Lambda[i], 
    model1_data$Mix[i],  
    model1_data$Adjusted_Replications_Needed[i]
  )
})

# Stop the cluster after the simulation
stopCluster(cl)
```

## Model 2

```{r, eval = FALSE}

#| label: "lta-rilta-simulation-Model 2b"
#| echo: true
#| message: false
#| warning: false


rilta_rilta_func2 <- function(N_numeric, TPs, Lambda, Mix, Adjusted_Replications_Needed) {
  
    # Construct the MODELPOPULATION argument based on the value of Mix
  MODELPOPULATION <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
       
       f by u11-u15*{Lambda} (p1-p5)
            u21-u25*{Lambda} (p1-p5);
        f@1;
        [f@0];
        
        MODEL POPULATION-c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
       ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      
       f by u11-u15*{Lambda} (p1-p5)
            u21-u25*{Lambda} (p1-p5);
        f@1;
        [f@0];
        
     MODEL POPULATION-c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
       ")
  }

  # Construct the MODEL argument based on the value of Mix
  MODEL <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

       f by u11-u15*{Lambda} (p1-p5)
            u21-u25*{Lambda} (p1-p5);
        f@1;
        [f@0];
        
     MODEL c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
	      ")      


            
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	      

           f by u11-u15*{Lambda} (p1-p5)
            u21-u25*{Lambda} (p1-p5);
        f@1;
        [f@0];
        
     MODEL c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
	      ")      
  }
  
  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);

    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);

    ")
  }
  
  RILTA_RILTA2 <- mplusObject(
    TITLE = glue("Generate RILTA_RILTA_M2_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_{Lambda}"),

    MONTECARLO =
      glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N_numeric};
      SEED = 07252005;
      NREPS = {Adjusted_Replications_Needed};
      !SAVE = repM2*.dat;
      RESULTS = RILTA_RILTA_M2_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_{Lambda}.csv;"),
    
    
    ANALYSIS = "TYPE = MIXTURE;
      algorithm = integration;
      STARTS = 50 10;
      processors = 24;
      logcriterion=0.00001;
      mconv=0.00001;",

    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_RILTA_Model2<- mplusModeler(RILTA_RILTA2, 
                                   dataout = here('Simulations', 'STUDY_2', '4_RILTA_GEN_RILTA_ANALYZED_REP', glue("RILTA_RILTA_M2_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_{Lambda}.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '4_RILTA_GEN_RILTA_ANALYZED_REP', "RILTA_RILTA_M2_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_{Lambda}.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_RILTA_Model2)
}

library(parallel)

# Start the cluster
num_cores <- detectCores() - 1

# Step 2: Select the cluster type based on the system (PSOCK for Windows, FORK for macOS/Linux)
cluster_type <- ifelse(.Platform$OS.type == "windows", "PSOCK", "FORK")


cl <- makeCluster(num_cores, type = cluster_type)

# Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_rilta_func2", "model2_data", "here", "glue", "mplusModeler", "mplusObject")))

# Ensure required libraries are loaded on each node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(model2_data), function(i) {
  rilta_rilta_func2(
    model2_data$N_numeric[i], 
    model2_data$TPs[i], 
    model2_data$Lambda[i], 
    model2_data$Mix[i],  
    model2_data$Adjusted_Replications_Needed[i]
  )
})

# Stop the cluster after the simulation
stopCluster(cl)
```

## Model 3

```{r,message=FALSE, warning=FALSE, eval = FALSE}

#| label: "lta-rilta-simulation-Model-3b"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true



rilta_rilta_func3 <- function(N_numeric, TPs, Lambda, Mix, Adjusted_Replications_Needed) {
  
    # Construct the MODELPOPULATION argument based on the value of Mix
  MODELPOPULATION <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11-u15*{Lambda} (p1-p5)
            u21-u25*{Lambda} (p1-p5);
        f@1;
        [f@0];
          
        MODEL POPULATION-c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
       ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11-u15*{Lambda} (p1-p5)
            u21-u25*{Lambda} (p1-p5);
        f@1;
        [f@0];
              
     MODEL POPULATION-c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
       ")
  }

  # Construct the MODEL argument based on the value of Mix
  MODEL <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	
      	
       f by u11-u15*{Lambda} (p1-p5)
            u21-u25*{Lambda} (p1-p5);
        f@1;
        [f@0];
          
     MODEL c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
	      ")      

          
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	      
      	
       f by u11-u15*{Lambda} (p1-p5)
            u21-u25*{Lambda} (p1-p5);
        f@1;
        [f@0];
          
     MODEL c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
	      ")      
  }
    
  
  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  }
  
  RILTA_RILTA3 <- mplusObject(
    TITLE = glue("Generate RILTA_RILTA_M3_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_{Lambda}"),

    MONTECARLO =
      glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N_numeric};
      SEED = 07252005;
      NREPS = {Adjusted_Replications_Needed};
      !SAVE = repM3*.dat;
      RESULTS = RILTA_RILTA_M3_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_{Lambda}.csv;"),
    
    
    ANALYSIS = "TYPE = MIXTURE;
      algorithm = integration;
      STARTS = 50 10;
      processors = 24;
      logcriterion=0.00001;
      mconv=0.00001;",

    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_RILTA_Model3<- mplusModeler(RILTA_RILTA3, 
                                   dataout = here('Simulations', 'STUDY_2', '4_RILTA_GEN_RILTA_ANALYZED_REP', glue("RILTA_RILTA_M3_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_{Lambda}.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '4_RILTA_GEN_RILTA_ANALYZED_REP', "RILTA_RILTA_M3_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_{Lambda}.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_RILTA_Model3)
}

library(parallel)

# Start the cluster
num_cores <- detectCores() - 1

# Step 2: Select the cluster type based on the system (PSOCK for Windows, FORK for macOS/Linux)
cluster_type <- ifelse(.Platform$OS.type == "windows", "PSOCK", "FORK")


cl <- makeCluster(num_cores, type = cluster_type)

# Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_rilta_func3", "model3_data", "here", "glue", "mplusModeler", "mplusObject")))

# Ensure required libraries are loaded on each node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(model3_data), function(i) {
  rilta_rilta_func3(
    model3_data$N_numeric[i], 
    model3_data$TPs[i], 
    model3_data$Lambda[i], 
    model3_data$Mix[i],  
    model3_data$Adjusted_Replications_Needed[i]
  )
})

# Stop the cluster after the simulation
stopCluster(cl)
```

## Model 4: PATTERN M1_X

```{r, eval = FALSE}

#| label: "lta-rilta-simulation-Model 4b"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true


rilta_rilta_func4 <- function(N_numeric, TPs, Mix, Adjusted_Replications_Needed) {
  
  # Construct the MODELPOPULATION argument based on the value of Mix
  MODELPOPULATION <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      
       f by u11*.1 u12*.1 u13*.2 u14*.1 u15*2 (p1-p5)
            u21*.1 u22*.1 u23*.2 u24*.1 u25*2 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;

      	
       f by u11*.1 u12*.1 u13*.2 u14*.1 u15*2 (p1-p5)
            u21*.1 u22*.1 u23*.2 u24*.1 u25*2 (p1-p5);
        f@1;
        [f@0];
        
        
      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  }

  # Construct the MODEL argument based on the value of Mix
  MODEL <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	
      
       f by u11*.1 u12*.1 u13*.2 u14*.1 u15*2 (p1-p5)
            u21*.1 u22*.1 u23*.2 u24*.1 u25*2 (p1-p5);
        f@1;
        [f@0];

      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2: 	
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	
      
       f by u11*.1 u12*.1 u13*.2 u14*.1 u15*2 (p1-p5)
            u21*.1 u22*.1 u23*.2 u24*.1 u25*2 (p1-p5);
        f@1;
        [f@0];

      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2: 	
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  }

  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);

    ")
  }

  # Construct the Mplus object
  RILTA_RILTA4 <- mplusObject(
    TITLE = glue("RILTA_RILTA_M1_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_X"),
    MONTECARLO = glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N_numeric};
      SEED = 07252005;
      NREPS = {Adjusted_Replications_Needed};
      !SAVE = repM4*.dat;
      RESULTS = RILTA_RILTA_M1_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_X.csv;"),
    
    
    ANALYSIS = "TYPE = MIXTURE;
      algorithm = integration;
      STARTS = 50 10;
      processors = 24;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_RILTA_Model4<- mplusModeler(RILTA_RILTA4, 
                                   dataout = here('Simulations', 'STUDY_2', '4_RILTA_GEN_RILTA_ANALYZED_REP', glue("RILTA_RILTA_M1_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_X.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '4_RILTA_GEN_RILTA_ANALYZED_REP', "RILTA_RILTA_M1_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_X.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_RILTA_Model4)
}

library(parallel)

# Start the cluster
num_cores <- detectCores() - 1

# Step 2: Select the cluster type based on the system (PSOCK for Windows, FORK for macOS/Linux)
cluster_type <- ifelse(.Platform$OS.type == "windows", "PSOCK", "FORK")


cl <- makeCluster(num_cores, type = cluster_type)

# Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_rilta_func4", "model4_data", "here", "glue", "mplusModeler", "mplusObject")))

# Ensure required libraries are loaded on each node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(model4_data), function(i) {
  rilta_rilta_func4(
    model4_data$N_numeric[i], 
    model4_data$TPs[i], 
    model4_data$Mix[i],  
    model4_data$Adjusted_Replications_Needed[i]
  )
})

# Stop the cluster after the simulation
stopCluster(cl)
```

## Model 5: Pattern M1_Y

```{r, eval = FALSE}

#| label: "lta-rilta-simulation-Model-5b"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true



rilta_rilta_func5 <- function(N_numeric, TPs, Mix, Adjusted_Replications_Needed) {
  
  # Construct the MODELPOPULATION argument based on the value of Mix
  MODELPOPULATION <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
        	
       f by u11*.9 u12*1.2 u13*.9 u14*1 u15*3.5 (p1-p5)
            u21*.9 u22*1.2 u23*.9 u24*1 u25*3.5 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;

      	
       f by u11*.9 u12*1.2 u13*.9 u14*1 u15*3.5 (p1-p5)
            u21*.9 u22*1.2 u23*.9 u24*1 u25*3.5 (p1-p5);
        f@1;
        [f@0];
        
        
      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  }

  # Construct the MODEL argument based on the value of Mix
  MODEL <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	
      
       f by u11*.9 u12*1.2 u13*.9 u14*1 u15*3.5 (p1-p5)
            u21*.9 u22*1.2 u23*.9 u24*1 u25*3.5 (p1-p5);
        f@1;
        [f@0];

      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2: 	
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

       f by u11*.9 u12*1.2 u13*.9 u14*1 u15*3.5 (p1-p5)
            u21*.9 u22*1.2 u23*.9 u24*1 u25*3.5 (p1-p5);
        f@1;
        [f@0];

      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2: 	
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  }

  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
 
    ")
  }

  # Construct the Mplus object
  RILTA_RILTA5 <- mplusObject(
    TITLE = glue("RILTA_RILTA_M1_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_Y"),
    MONTECARLO = glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N_numeric};
      SEED = 07252005;
      NREPS = {Adjusted_Replications_Needed};
      !SAVE = repM5*.dat;
      RESULTS = RILTA_RILTA_M1_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_Y.csv;"),
    
    
    ANALYSIS = "TYPE = MIXTURE;
      algorithm = integration;
      STARTS = 50 10;
      processors = 24;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_RILTA_Model5<- mplusModeler(RILTA_RILTA5, 
                                   dataout = here('Simulations', 'STUDY_2', '4_RILTA_GEN_RILTA_ANALYZED_REP', glue("RILTA_RILTA_M1_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_Y.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '4_RILTA_GEN_RILTA_ANALYZED_REP', "RILTA_RILTA_M1_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_Y.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_RILTA_Model5)
}

library(parallel)

# Start the cluster
num_cores <- detectCores() - 1

# Step 2: Select the cluster type based on the system (PSOCK for Windows, FORK for macOS/Linux)
cluster_type <- ifelse(.Platform$OS.type == "windows", "PSOCK", "FORK")


cl <- makeCluster(num_cores, type = cluster_type)

# Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_rilta_func5", "model5_data", "here", "glue", "mplusModeler", "mplusObject")))

# Ensure required libraries are loaded on each node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(model5_data), function(i) {
  rilta_rilta_func5(
    model5_data$N_numeric[i], 
    model5_data$TPs[i], 
    model5_data$Mix[i],  
    model5_data$Adjusted_Replications_Needed[i]
  )
})

# Stop the cluster after the simulation
stopCluster(cl)
```

## Model 6: PATTERN M1_Z

```{r, eval = FALSE}

#| label: "lta-rilta-simulation-Model-6b"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true


rilta_rilta_func6 <- function(N_numeric, TPs, Mix, Adjusted_Replications_Needed) {
  
  # Construct the MODELPOPULATION argument based on the value of Mix
  MODELPOPULATION <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.1 u12*2.3 u13*3.1 u14*3 u15*6.5 (p1-p5)
            u21*.2 u22*2.4 u23*3.1 u24*3 u25*6.5 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.1 u12*2.3 u13*3.1 u14*3 u15*6.5 (p1-p5)
            u21*.2 u22*2.4 u23*3.1 u24*3 u25*6.5 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL POPULATION-c2:  
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  }

  # Construct the MODEL argument based on the value of Mix
  MODEL <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

       f by u11*.1 u12*2.3 u13*3.1 u14*3 u15*6.5 (p1-p5)
            u21*.2 u22*2.4 u23*3.1 u24*3 u25*6.5 (p1-p5);
        f@1;
        [f@0];
        
      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2: 	
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

       f by u11*.1 u12*2.3 u13*3.1 u14*3 u15*6.5 (p1-p5)
            u21*.2 u22*2.4 u23*3.1 u24*3 u25*6.5 (p1-p5);
        f@1;
        [f@0];
        
      MODEL c1:
      %c1#1%
      [u11$1*1 u12$1*1 u13$1*1 u14$1*1 u15$1*1] (p111-p115);
      %c1#2%
      [u11$1*1 u12$1*1 u13$1*-1 u14$1*-1 u15$1*-1] (p121-p125);
      %c1#3%
      [u11$1*-1 u12$1*-1 u13$1*-1 u14$1*-1 u15$1*-1] (p131-p135);

      MODEL c2: 	
      %c2#1%
      [u21$1*1 u22$1*1 u23$1*1 u24$1*1 u25$1*1] (p111-p115);
      %c2#2%
      [u21$1*1 u22$1*1 u23$1*-1 u24$1*-1 u25$1*-1] (p121-p125);
      %c2#3%
      [u21$1*-1 u22$1*-1 u23$1*-1 u24$1*-1 u25$1*-1] (p131-p135);
    ")
  }

  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  }

  # Construct the Mplus object
  RILTA_RILTA6 <- mplusObject(
    TITLE = glue("RILTA_RILTA_M1_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_Z"),
    MONTECARLO = glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N_numeric};
      SEED = 07252005;
      NREPS = {Adjusted_Replications_Needed};
      !SAVE = repM6*.dat;
      RESULTS = RILTA_RILTA_M1_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_Z.csv;"),
    
    
    ANALYSIS = "TYPE = MIXTURE;
      algorithm = integration;
      STARTS = 50 10;
      processors = 24;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_RILTA_Model6<- mplusModeler(RILTA_RILTA6, 
                                   dataout = here('Simulations', 'STUDY_2', '4_RILTA_GEN_RILTA_ANALYZED_REP', glue("RILTA_RILTA_M1_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_Z.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '4_RILTA_GEN_RILTA_ANALYZED_REP', "RILTA_RILTA_M1_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_Z.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_RILTA_Model6)
}

library(parallel)

# Start the cluster
num_cores <- detectCores() - 1

# Step 2: Select the cluster type based on the system (PSOCK for Windows, FORK for macOS/Linux)
cluster_type <- ifelse(.Platform$OS.type == "windows", "PSOCK", "FORK")


cl <- makeCluster(num_cores, type = cluster_type)

# Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_rilta_func6", "model6_data", "here", "glue", "mplusModeler", "mplusObject")))

# Ensure required libraries are loaded on each node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(model6_data), function(i) {
  rilta_rilta_func6(
    model6_data$N_numeric[i], 
    model6_data$TPs[i], 
    model6_data$Mix[i],  
    model6_data$Adjusted_Replications_Needed[i]
  )
})

# Stop the cluster after the simulation
stopCluster(cl)
```

## Model 7: PATTERN M2_X

```{r, eval = FALSE}

#| label: "lta-rilta-simulation-Model-7b"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

rilta_rilta_func7 <- function(N_numeric, TPs, Mix, Adjusted_Replications_Needed) {
  
  # Construct the MODELPOPULATION argument based on the value of Mix
  MODELPOPULATION <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.1 u12*.1 u13*.2 u14*.1 u15*2 (p1-p5)
            u21*.1 u22*.1 u23*.2 u24*.1 u25*2 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.1 u12*.1 u13*.2 u14*.1 u15*2 (p1-p5)
            u21*.1 u22*.1 u23*.2 u24*.1 u25*2 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
  }

  # Construct the MODEL argument based on the value of Mix
  MODEL <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

       f by u11*.1 u12*.1 u13*.2 u14*.1 u15*2 (p1-p5)
            u21*.1 u22*.1 u23*.2 u24*.1 u25*2 (p1-p5);
        f@1;
        [f@0];
        
      MODEL c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL c2: 	
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	


       f by u11*.1 u12*.1 u13*.2 u14*.1 u15*2 (p1-p5)
            u21*.1 u22*.1 u23*.2 u24*.1 u25*2 (p1-p5);
        f@1;
        [f@0];
        
      MODEL c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL c2: 	
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
  }

  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);

    ")
  }

  # Construct the Mplus object
  RILTA_RILTA7 <- mplusObject(
    TITLE = glue("RILTA_RILTA_M2_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_X"),
    MONTECARLO = glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N_numeric};
      SEED = 07252005;
      NREPS = {Adjusted_Replications_Needed};
      !SAVE = repM7*.dat;
      RESULTS = RILTA_RILTA_M2_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_X.csv;"),
    
    
    ANALYSIS = "TYPE = MIXTURE;
      algorithm = integration;
      STARTS = 50 10;
      processors = 24;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_RILTA_Model7<- mplusModeler(RILTA_RILTA7, 
                                   dataout = here('Simulations', 'STUDY_2', '4_RILTA_GEN_RILTA_ANALYZED_REP', glue("RILTA_RILTA_M2_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_X.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '4_RILTA_GEN_RILTA_ANALYZED_REP', "RILTA_RILTA_M2_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_X.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_RILTA_Model7)
}

library(parallel)

# Start the cluster
num_cores <- detectCores() - 1

# Step 2: Select the cluster type based on the system (PSOCK for Windows, FORK for macOS/Linux)
cluster_type <- ifelse(.Platform$OS.type == "windows", "PSOCK", "FORK")


cl <- makeCluster(num_cores, type = cluster_type)

# Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_rilta_func7", "model7_data", "here", "glue", "mplusModeler", "mplusObject")))

# Ensure required libraries are loaded on each node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(model7_data), function(i) {
  rilta_rilta_func7(
    model7_data$N_numeric[i], 
    model7_data$TPs[i], 
    model7_data$Mix[i],  
    model7_data$Adjusted_Replications_Needed[i]
  )
})

# Stop the cluster after the simulation
stopCluster(cl)
```

## Model 8: Pattern M2_Y

```{r, eval = FALSE}

#| label: "lta-rilta-simulation-Model-8b"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true


rilta_rilta_func8 <- function(N_numeric, TPs, Mix, Adjusted_Replications_Needed) {
  
  # Construct the MODELPOPULATION argument based on the value of Mix
  MODELPOPULATION <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.9 u12*1.2 u13*.9 u14*1 u15*3.5 (p1-p5)
            u21*.9 u22*1.2 u23*.9 u24*1 u25*3.5 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.9 u12*1.2 u13*.9 u14*1 u15*3.5 (p1-p5)
            u21*.9 u22*1.2 u23*.9 u24*1 u25*3.5 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
  }

  # Construct the MODEL argument based on the value of Mix
  MODEL <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

       f by u11*.9 u12*1.2 u13*.9 u14*1 u15*3.5 (p1-p5)
            u21*.9 u22*1.2 u23*.9 u24*1 u25*3.5 (p1-p5);
        f@1;
        [f@0];
        
      MODEL c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL c2: 	
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

       f by u11*.9 u12*1.2 u13*.9 u14*1 u15*3.5 (p1-p5)
            u21*.9 u22*1.2 u23*.9 u24*1 u25*3.5 (p1-p5);
        f@1;
        [f@0];
        
      MODEL c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL c2: 	
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
  }

  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  }

  # Construct the Mplus object
  RILTA_RILTA8 <- mplusObject(
    TITLE = glue("RILTA_RILTA_M2_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_Y"),
    MONTECARLO = glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N_numeric};
      SEED = 07252005;
      NREPS = {Adjusted_Replications_Needed};
      !SAVE = repM8*.dat;
      RESULTS = RILTA_RILTA_M2_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_Y.csv;"),
    
    ANALYSIS = "TYPE = MIXTURE;
      algorithm = integration;
      processors = 24;
      STARTS 50 10;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_RILTA_Model8<- mplusModeler(RILTA_RILTA8, 
                                   dataout = here('Simulations', 'STUDY_2', '4_RILTA_GEN_RILTA_ANALYZED_REP', glue("RILTA_RILTA_M2_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_Y.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '4_RILTA_GEN_RILTA_ANALYZED_REP', "RILTA_RILTA_M2_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_Y.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_RILTA_Model8)
}

library(parallel)

# Start the cluster
num_cores <- detectCores() - 1

# Step 2: Select the cluster type based on the system (PSOCK for Windows, FORK for macOS/Linux)
cluster_type <- ifelse(.Platform$OS.type == "windows", "PSOCK", "FORK")


cl <- makeCluster(num_cores, type = cluster_type)

# Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_rilta_func8", "model8_data", "here", "glue", "mplusModeler", "mplusObject")))

# Ensure required libraries are loaded on each node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(model8_data), function(i) {
  rilta_rilta_func8(
    model8_data$N_numeric[i], 
    model8_data$TPs[i], 
    model8_data$Mix[i],  
    model8_data$Adjusted_Replications_Needed[i]
  )
})

# Stop the cluster after the simulation
stopCluster(cl)
```

## Model 9: PATTERN M2_Z

```{r, eval = FALSE}

#| label: "lta-rilta-simulation-Model-9b"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

rilta_rilta_func9 <- function(N_numeric, TPs, Mix, Adjusted_Replications_Needed) {
  
  # Construct the MODELPOPULATION argument based on the value of Mix
  MODELPOPULATION <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.1 u12*2.3 u13*3.1 u14*3 u15*6.5 (p1-p5)
            u21*.2 u22*2.4 u23*3.1 u24*3 u25*6.5 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.1 u12*2.3 u13*3.1 u14*3 u15*6.5 (p1-p5)
            u21*.2 u22*2.4 u23*3.1 u24*3 u25*6.5 (p1-p5);
        f@1;
        [f@0];
        
      MODEL POPULATION-c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
  }

  # Construct the MODEL argument based on the value of Mix
  MODEL <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

       f by u11*.1 u12*2.3 u13*3.1 u14*3 u15*6.5 (p1-p5)
            u21*.2 u22*2.4 u23*3.1 u24*3 u25*6.5 (p1-p5);
        f@1;
        [f@0];
        
      MODEL c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL c2: 	
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);
      
       f by u11*.1 u12*2.3 u13*3.1 u14*3 u15*6.5 (p1-p5)
            u21*.2 u22*2.4 u23*3.1 u24*3 u25*6.5 (p1-p5);
        f@1;
        [f@0];
        
      MODEL c1:
        %c1#1%
     [u11$1*-5 u12$1*-1.21 u13$1*-1.45 u14$1*-1.55 u15$1*-5] (p111-p115);

        %c1#2%
     [u11$1*5 u12$1*-5 u13$1*.94 u14$1*-.02 u15$1*-.89] (p121-p125);
     
        %c1#3%
     [u11$1*-5 u12$1*1.55 u13$1*4.17 u14$1*-.16 u15$1*-1.99] (p131-p135);

      MODEL c2: 	
        %c2#1%
     [u21$1*-5 u22$1*-1.21 u23$1*-1.45 u24$1*-1.55 u25$1*-5] (p111-p115);

        %c2#2%
     [u21$1*5 u22$1*-5 u23$1*.94 u24$1*-.02 u25$1*-.89] (p121-p125);
     
        %c2#3%
     [u21$1*-5 u22$1*1.55 u23$1*4.17 u24$1*-.16 u25$1*-1.99] (p131-p135);
    ")
  }

  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      

    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  }

  # Construct the Mplus object
  RILTA_RILTA9 <- mplusObject(
    TITLE = glue("RILTA_RILTA_M2_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_Z"),
    MONTECARLO = glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N_numeric};
      SEED = 07252005;
      NREPS = {Adjusted_Replications_Needed};
      !SAVE = repM9*.dat;
      RESULTS = RILTA_RILTA_M2_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_Z.csv;"),
    
    ANALYSIS = "TYPE = MIXTURE;
      algorithm = integration;
      STARTS 50 10;
      processors = 24;
      logcriterion=0.00001;
      mconv=0.00001;",
    
    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_RILTA_Model9<- mplusModeler(RILTA_RILTA9, 
                                   dataout = here('Simulations', 'STUDY_2', '4_RILTA_GEN_RILTA_ANALYZED_REP', glue("RILTA_RILTA_M2_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_Z.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '4_RILTA_GEN_RILTA_ANALYZED_REP', "RILTA_RILTA_M2_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_Z.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_RILTA_Model9)
}

library(parallel)

# Start the cluster
num_cores <- detectCores() - 1

# Step 2: Select the cluster type based on the system (PSOCK for Windows, FORK for macOS/Linux)
cluster_type <- ifelse(.Platform$OS.type == "windows", "PSOCK", "FORK")


cl <- makeCluster(num_cores, type = cluster_type)

# Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_rilta_func9", "model9_data", "here", "glue", "mplusModeler", "mplusObject")))

# Ensure required libraries are loaded on each node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(model9_data), function(i) {
  rilta_rilta_func9(
    model9_data$N_numeric[i], 
    model9_data$TPs[i], 
    model9_data$Mix[i],  
    model9_data$Adjusted_Replications_Needed[i]
  )
})

# Stop the cluster after the simulation
stopCluster(cl)
```

## Model 10: Pattern M3_X

```{r, eval = FALSE}

#| label: "lta-rilta-simulation-Model-10b"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

rilta_rilta_func10 <- function(N_numeric, TPs, Mix, Adjusted_Replications_Needed) {
  
    # Construct the MODELPOPULATION argument based on the value of Mix
  MODELPOPULATION <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.1 u12*.1 u13*.2 u14*.1 u15*2 (p1-p5)
            u21*.1 u22*.1 u23*.2 u24*.1 u25*2 (p1-p5);
        f@1;
        [f@0];
          
        MODEL POPULATION-c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
       ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.1 u12*.1 u13*.2 u14*.1 u15*2 (p1-p5)
            u21*.1 u22*.1 u23*.2 u24*.1 u25*2 (p1-p5);
        f@1;
        [f@0];
              
     MODEL POPULATION-c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
       ")
  }

  # Construct the MODEL argument based on the value of Mix
  MODEL <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

       f by u11*.1 u12*.1 u13*.2 u14*.1 u15*2 (p1-p5)
            u21*.1 u22*.1 u23*.2 u24*.1 u25*2 (p1-p5);
        f@1;
        [f@0];
        
     MODEL c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
	      ")      
      
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	      

       f by u11*.1 u12*.1 u13*.2 u14*.1 u15*2 (p1-p5)
            u21*.1 u22*.1 u23*.2 u24*.1 u25*2 (p1-p5);
        f@1;
        [f@0];
        
     MODEL c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
	      ")      
  }
    
  
  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  }
  
  RILTA_RILTA10 <- mplusObject(
    TITLE = glue("Generate RILTA_RILTA_M3_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_X"),

    MONTECARLO =
      glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N_numeric};
      SEED = 07252005;
      NREPS = {Adjusted_Replications_Needed};
      !SAVE = repM10*.dat;
      RESULTS = RILTA_RILTA_M3_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_X.csv;"),
    
    
    ANALYSIS = "TYPE = MIXTURE;
    Algorithm = INTEGRATION;
      STARTS = 50 10;
      processors = 24;
      logcriterion=0.00001;
      mconv=0.00001;",

    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_RILTA_Model10<- mplusModeler(RILTA_RILTA10, 
                                   dataout = here('Simulations', 'STUDY_2', '4_RILTA_GEN_RILTA_ANALYZED_REP', glue("RILTA_RILTA_M3_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_X.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '4_RILTA_GEN_RILTA_ANALYZED_REP', "RILTA_RILTA_M3_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_X.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_RILTA_Model10)
}

library(parallel)

# Start the cluster
num_cores <- detectCores() - 1

# Step 2: Select the cluster type based on the system (PSOCK for Windows, FORK for macOS/Linux)
cluster_type <- ifelse(.Platform$OS.type == "windows", "PSOCK", "FORK")


cl <- makeCluster(num_cores, type = cluster_type)

# Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_rilta_func10", "model10_data", "here", "glue", "mplusModeler", "mplusObject")))

# Ensure required libraries are loaded on each node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(model10_data), function(i) {
  rilta_rilta_func10(
    model10_data$N_numeric[i], 
    model10_data$TPs[i], 
    model10_data$Mix[i],  
    model10_data$Adjusted_Replications_Needed[i]
  )
})

# Stop the cluster after the simulation
stopCluster(cl)
```

## Model 11: PATTERN M3_Y

```{r, eval = FALSE}

#| label: "lta-rilta-simulation-Model-11b"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

rilta_rilta_func11 <- function(N_numeric, TPs, Mix, Adjusted_Replications_Needed) {
  
    # Construct the MODELPOPULATION argument based on the value of Mix
  MODELPOPULATION <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.9 u12*1.2 u13*.9 u14*1 u15*3.5 (p1-p5)
            u21*.9 u22*1.2 u23*.9 u24*1 u25*3.5 (p1-p5);
        f@1;
        [f@0];
          
        MODEL POPULATION-c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
       ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.9 u12*1.2 u13*.9 u14*1 u15*3.5 (p1-p5)
            u21*.9 u22*1.2 u23*.9 u24*1 u25*3.5 (p1-p5);
        f@1;
        [f@0];
              
     MODEL POPULATION-c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
       ")
  }

  # Construct the MODEL argument based on the value of Mix
  MODEL <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

       f by u11*.9 u12*1.2 u13*.9 u14*1 u15*3.5 (p1-p5)
            u21*.9 u22*1.2 u23*.9 u24*1 u25*3.5 (p1-p5);
        f@1;
        [f@0];
        
     MODEL c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
	      ")      
      
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	      

       f by u11*.9 u12*1.2 u13*.9 u14*1 u15*3.5 (p1-p5)
            u21*.9 u22*1.2 u23*.9 u24*1 u25*3.5 (p1-p5);
        f@1;
        [f@0];
        
     MODEL c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
	      ")      
  }
    
  
  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  }
  
  RILTA_RILTA11 <- mplusObject(
    TITLE = glue("Generate RILTA_RILTA_M3_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_Y"),

    MONTECARLO =
      glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N_numeric};
      SEED = 07252005;
      NREPS = {Adjusted_Replications_Needed};
      !SAVE = repM11*.dat;
      RESULTS = RILTA_RILTA_M3_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_Y.csv;"),
    
    
    ANALYSIS = "TYPE = MIXTURE;
    Algorithm = INTEGRATION;
      STARTS = 50 10;
      processors = 24;
      logcriterion=0.00001;
      mconv=0.00001;",

    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_RILTA_Model11<- mplusModeler(RILTA_RILTA11, 
                                   dataout = here('Simulations', 'STUDY_2', '4_RILTA_GEN_RILTA_ANALYZED_REP', glue("RILTA_RILTA_M3_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_Y.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '4_RILTA_GEN_RILTA_ANALYZED_REP', "RILTA_RILTA_M3_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_Y.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_RILTA_Model11)
}

library(parallel)

# Start the cluster
num_cores <- detectCores() - 1

# Step 2: Select the cluster type based on the system (PSOCK for Windows, FORK for macOS/Linux)
cluster_type <- ifelse(.Platform$OS.type == "windows", "PSOCK", "FORK")


cl <- makeCluster(num_cores, type = cluster_type)

# Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_rilta_func11", "model11_data", "here", "glue", "mplusModeler", "mplusObject")))

# Ensure required libraries are loaded on each node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(model11_data), function(i) {
  rilta_rilta_func11(
    model11_data$N_numeric[i], 
    model11_data$TPs[i], 
    model11_data$Mix[i],  
    model11_data$Adjusted_Replications_Needed[i]
  )
})

# Stop the cluster after the simulation
stopCluster(cl)
```

## Model 12: Pattern M3_Z

```{r, eval = FALSE}

#| label: "lta-rilta-simulation-Model-12b"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

rilta_rilta_func12 <- function(N_numeric, TPs, Mix, Adjusted_Replications_Needed) {
  
    # Construct the MODELPOPULATION argument based on the value of Mix
  MODELPOPULATION <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.1 u12*2.3 u13*3.1 u14*3 u15*6.5 (p1-p5)
            u21*.2 u22*2.4 u23*3.1 u24*3 u25*6.5 (p1-p5);
        f@1;
        [f@0];
          
        MODEL POPULATION-c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
       ")
    
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] ; 
      [c2#2*-1.1] ; 
      c2#1 on c1#1*{TPs};
      c2#1 on c1#2*1.1; 
      c2#2 on c1#1*1.1; 
      c2#2 on c1#2*1.793147;
      	
       f by u11*.1 u12*2.3 u13*3.1 u14*3 u15*6.5 (p1-p5)
            u21*.2 u22*2.4 u23*3.1 u24*3 u25*6.5 (p1-p5);
        f@1;
        [f@0];
              
     MODEL POPULATION-c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

      MODEL POPULATION-c2:  
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
       ")
  }

  # Construct the MODEL argument based on the value of Mix
  MODEL <- if (Mix == 1) { 
    glue("	
      %OVERALL%
      [c1#1*0] ;
      [c1#2*0] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	

       f by u11*.1 u12*2.3 u13*3.1 u14*3 u15*6.5 (p1-p5)
            u21*.2 u22*2.4 u23*3.1 u24*3 u25*6.5 (p1-p5);
        f@1;
        [f@0];

     MODEL c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
	      ")      
      
  } else if (Mix == 2) { 
    glue("	
      %OVERALL%
      [c1#1*1.897] ;
      [c1#2*1.099] ;
      [c2#1*-1.1] (a1);
      [c2#2*-1.1] (a2); 
      c2#1 on c1#1*{TPs} (b11); 
      c2#1 on c1#2*1.1 (b21); 
      c2#2 on c1#1*1.1 (b12); 
      c2#2 on c1#2*1.793147 (b22);	      

       f by u11*.1 u12*2.3 u13*3.1 u14*3 u15*6.5 (p1-p5)
            u21*.2 u22*2.4 u23*3.1 u24*3 u25*6.5 (p1-p5);
        f@1;
        [f@0];

     MODEL c1:
        %c1#1%
     [u11$1*5 u12$1*2.38 u13$1*1.385 u14$1*4.59 u15$1*4.59] (p111-p115);

        %c1#2%
     [u11$1*.62 u12$1*.81 u13$1*.82 u14$1*.28 u15$1*1.39] (p121-p125);
     
        %c1#3%
     [u11$1*-1.45 u12$1*-2.44 u13$1*-5 u14$1*-1.70 u15$1*-.71] (p131-p135);

    MODEL c2: 	
        %c2#1%
     [u21$1*5 u22$1*2.38 u23$1*1.385 u24$1*4.59 u25$1*4.59] (p111-p115);

        %c2#2%
     [u21$1*.62 u22$1*.81 u23$1*.82 u24$1*.28 u25$1*1.39] (p121-p125);
     
        %c2#3%
     [u21$1*-1.45 u22$1*-2.44 u23$1*-5 u24$1*-1.70 u25$1*-.71] (p131-p135);
	      ")      
  }
    
  
  # Construct the MODELCONSTRAINT argument based on the value of TPs
  MODELCONSTRAINT <- if (TPs == 3.179) {
    glue("
      New(
        trans11*.8 trans12*.1 trans13*.1 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  } else if (TPs == 0.407) {
    glue("
      New(
        trans11*.2 trans12*.4 trans13*.4 
        trans21*.25 trans22*.5 trans23*.25);
      trans11 = exp(a1+b11)/(exp(a1+b11)+exp(a2+b12)+1);
      trans12 = exp(a2+b12)/(exp(a1+b11)+exp(a2+b12)+1);
      trans13 = 1-(trans11+trans12);
      trans21 = exp(a1+b21)/(exp(a1+b21)+exp(a2+b22)+1);
      trans22 = exp(a2+b22)/(exp(a1+b21)+exp(a2+b22)+1);
      trans23 = 1-(trans21+trans22);
      
    ")
  }
  
  RILTA_RILTA12 <- mplusObject(
    TITLE = glue("Generate RILTA_RILTA_M3_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_Z"),

    MONTECARLO =
      glue("NAMES = u11-u15 u21-u25;
      GENERATE = u11-u15 u21-u25(1);
      CATEGORICAL = u11-u15 u21-u25;
      GENCLASSES = c1(3) c2(3);
      CLASSES = c1(3) c2(3);
      NOBSERVATIONS = {N_numeric};
      SEED = 07252005;
      NREPS = {Adjusted_Replications_Needed};
      !SAVE = repM12*.dat;
      RESULTS = RILTA_RILTA_M3_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_Z.csv;"),
    
    
    ANALYSIS = "TYPE = MIXTURE;
      algorithm = integration;
      STARTS = 50 10;
      processors = 24;
      logcriterion=0.00001;
      mconv=0.00001;",

    MODELPOPULATION = MODELPOPULATION,
    MODEL = MODEL,
    MODELCONSTRAINT = MODELCONSTRAINT
  )

  # Run Mplus model
  RILTA_RILTA_Model12<- mplusModeler(RILTA_RILTA12, 
                                   dataout = here('Simulations', 'STUDY_2', '4_RILTA_GEN_RILTA_ANALYZED_REP', glue("RILTA_RILTA_M3_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_Z.dat")),
                                   modelout = glue(here('Simulations', 'STUDY_2', '4_RILTA_GEN_RILTA_ANALYZED_REP', "RILTA_RILTA_M3_N_{N_numeric}_TP_{TPs}_M_{Mix}_L_Z.inp")),
                                   check = TRUE, run = TRUE, hashfilename = FALSE)
return(RILTA_RILTA_Model12)
}

library(parallel)

# Start the cluster
num_cores <- detectCores() - 1

# Step 2: Select the cluster type based on the system (PSOCK for Windows, FORK for macOS/Linux)
cluster_type <- ifelse(.Platform$OS.type == "windows", "PSOCK", "FORK")


cl <- makeCluster(num_cores, type = cluster_type)

# Export necessary objects to the cluster
invisible(clusterExport(cl, c("rilta_rilta_func12", "model12_data", "here", "glue", "mplusModeler", "mplusObject")))

# Ensure required libraries are loaded on each node
invisible(clusterEvalQ(cl, {
  library(MplusAutomation)
  library(glue)
  library(here)
}))

result_list <- parLapply(cl, 1:nrow(model12_data), function(i) {
  rilta_rilta_func12(
    model12_data$N_numeric[i], 
    model12_data$TPs[i], 
    model12_data$Mix[i],  
    model12_data$Adjusted_Replications_Needed[i]
  )
})

# Stop the cluster after the simulation
stopCluster(cl)
```

# CHECK FOR ERRORS AND LABEL SWITCHING

### Step 6: Combine All CSV Files into One Data Frame

**Objective:** 

*Load all CSV files and combine them into a single data frame.*

```{r}
#| label: "combine-csv-files-parallel2"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Step 1: Set the correct CSV directory
csv_directory <- here('Simulations', 'STUDY_2', '4_RILTA_GEN_RILTA_ANALYZED_REP')

# Step 2: Source the child document
source(here('Child_Docs', 'data_scraping.R'))
```

### Step 7: Scrape Rows and Process Data

**Objective:** 

*Extract the first 3 rows from each 11-row chunk and prepare the data for further processing.*

```{r}
#| label: "scrape-rows-process-data-parallel2"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Step 2: Process the data using the child script
source(here('Child_Docs', 'step2_f_LTA.R'))
```

### Step 8: Convert Logits to Probabilities and Add Actual (Population) Values

**Objective:** 

*Convert the logits to probabilities and add the known actual values to each row.*

```{r}

#| label: "convert-logits-and-flags2"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Step 3 and 4: Process the data and return results
source(here('Child_Docs', 'step_3.r'))

# The objects `final_data_with_actuals` and `violators` should now be in the global environment
```

### **Step 9: Summarize Violations**

#### **Objective**

*Calculate the percentage of violations for each file, handling missing values appropriately.*

#### Step 9: Part 1 Scrape Output Files for Errors for specific replications

```{r}

#| label: "summarize-errors2"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

library(parallel)

extract_errors_from_file <- function(filepath, total_replications) {
  lines <- readLines(filepath)
  results <- vector("list", total_replications)
  error_keywords <- c("NON-POSITIVE DEFINITE", "SADDLE")

  # Initialize results for every replication
  for (rep in 1:total_replications) {
    results[[rep]] <- tibble(
      FileName = basename(filepath),
      Replication = rep,
      Message = "None",
      MessageType = "None"
    )
  }

  current_replication <- NULL
  for (line in lines) {
    if (str_detect(line, "REPLICATION")) {
      current_replication <- as.integer(str_extract(line, "\\d+"))
    }

    if (!is.null(current_replication) && current_replication <= total_replications &&
        any(sapply(error_keywords, grepl, line, ignore.case = TRUE))) {
      results[[current_replication]] <- tibble(
        FileName = basename(filepath),
        Replication = current_replication,
        Message = str_trim(line),
        MessageType = "Error"
      )
    }
  }

  return(bind_rows(results))
}

# Step 2: Extract Completed Replications
extract_completed_replications <- function(filepath) {
  lines <- readLines(filepath)
  completed_line <- lines[grepl("Completed", lines, ignore.case = TRUE)]
  completed <- as.integer(str_match(completed_line, "Completed\\s+(\\d+)")[, 2])
  if (length(completed) == 0) completed <- 0
  tibble(FileName = basename(filepath), CompletedReplications = completed)
}


# Step 3: Extract Requested Replications
extract_requested_replications <- function(filepath) {
  lines <- readLines(filepath)
  requested_line <- lines[grepl("Requested", lines, ignore.case = TRUE)]
  requested <- as.integer(str_match(requested_line, "Requested\\s+(\\d+)")[, 2])
  if (length(requested) == 0) requested <- 0
  tibble(FileName = basename(filepath), RequestedReplications = requested)
}

calculate_replication_summary <- function(error_summary, completed_replications, requested_replications) {
  summary <- error_summary %>%
    group_by(FileName) %>%
    summarise(
      ErrorReplications = n_distinct(Replication[MessageType == "Error"]),
      .groups = "drop"
    )

  full_summary <- requested_replications %>%
    left_join(completed_replications, by = "FileName") %>%
    left_join(summary, by = "FileName") %>%
    mutate(
      ErrorReplications = coalesce(ErrorReplications, 0),
      GoodReplications = CompletedReplications - ErrorReplications,
      ErrorRate = if_else(CompletedReplications > 0, (ErrorReplications / CompletedReplications) * 100, 0)
    ) %>%
    select(FileName, RequestedReplications, CompletedReplications, ErrorReplications, GoodReplications, ErrorRate)

  full_summary
}

# Step 4: Parallelized Processing (Windows/Mac/Linux Compatible)
output_folder <- "4_RILTA_GEN_RILTA_ANALYZED"  # Adjust to your folder path
file_list <- list.files(output_folder, pattern = "\\.out$", full.names = TRUE)

# Step 5: Detect OS and Set Up Cluster
cluster_type <- ifelse(.Platform$OS.type == "windows", "PSOCK", "FORK")
num_cores <- detectCores() - 1  # Use all but one core
cl <- makeCluster(num_cores, type = cluster_type)

# Export necessary libraries and functions to the cluster
invisible(clusterExport(cl, c("extract_errors_from_file", "extract_completed_replications", "extract_requested_replications")))
invisible(clusterEvalQ(cl, library(tidyverse)))

# Step 6: Parallel Processing
# Calculate completed replications first
completed_rep_list <- parLapply(cl, file_list, extract_completed_replications)

# Extract errors while passing the total number of completed replications to the function
error_summary <- bind_rows(mapply(function(filepath, completed_data) {
  extract_errors_from_file(filepath, completed_data$CompletedReplications)
}, file_list, completed_rep_list, SIMPLIFY = FALSE))

completed_replications <- bind_rows(parLapply(cl, file_list, extract_completed_replications))
requested_replications <- bind_rows(parLapply(cl, file_list, extract_requested_replications))

# Stop the cluster
stopCluster(cl)

# Step 7: Calculate Replication Summary
replication_summary <- calculate_replication_summary(error_summary, completed_replications, requested_replications)

# Step 8: Create and Display the Table with Error Rate
replication_summary_table <- replication_summary %>%
  gt() %>%
  tab_header(
    title = "Replication Summary",
    subtitle = paste0("Folder: ", output_folder)
  ) %>%
  fmt_number(columns = c(CompletedReplications, RequestedReplications, ErrorReplications, GoodReplications, ErrorRate), decimals = 2) %>%
  cols_label(
    FileName = "File Name",
    CompletedReplications = "Completed Replications",
    RequestedReplications = "Requested Replications",
    ErrorReplications = "Replications with Errors",
    GoodReplications = "Good Replications",
    ErrorRate = "Error Rate (%)"
  ) %>%
  tab_options(
    table.font.size = "small",
    heading.title.font.size = "medium",
    heading.subtitle.font.size = "small"
  )

# Display the table
replication_summary_table

completed_replications <- completed_replications %>%
  mutate(FileName = str_replace(FileName, "\\.out$", ""),
         FileName = tolower(FileName),
         FileName = str_trim(FileName))

error_summary <- error_summary %>%
  mutate(FileName = str_replace(FileName, "\\.out$", ""),
         FileName = tolower(FileName),
         FileName = str_trim(FileName))

final_data_with_actuals <- final_data_with_actuals %>%
  mutate(FileName = tolower(FileName),
         FileName = str_trim(FileName))

replication_summary <- replication_summary %>%
  mutate(FileName = str_replace(FileName, "\\.out$", ""),
         FileName = tolower(FileName),
         FileName = str_trim(FileName))

cat("Rows in final_data_with_actuals:", nrow(final_data_with_actuals), "\n")
# Output the final number of rows to confirm data handling
cat("Number of rows in error_summary: ", nrow(error_summary), "\n")
cat("Number of rows in replication_summary: ", nrow(replication_summary), "\n")

```

#### Step 9: Part 2 Merge errors with main data

```{r}
#| label: "merge-errors2"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true



# Ensure consistent column formats and remove .out and .csv extensions
error_summary <- error_summary %>%
  mutate(
    FileName = tolower(str_trim(gsub("\\.out$|\\.csv$", "", FileName))), # Remove extensions and standardize FileName
    Replication = as.character(Replication) # Convert Replication to character
  )

final_data_with_actuals <- final_data_with_actuals %>%
  mutate(
    FileName = tolower(str_trim(gsub("\\.out$|\\.csv$", "", FileName))), # Remove extensions and standardize FileName
    Replication = as.character(Replication) # Convert Replication to character
  )

# Add a new column to flag errors
error_summary <- error_summary %>%
  mutate(ErrorFlag = if_else(Message == "None", 0, 1))

# Merge ErrorFlag into final_data_with_actuals
final_data_with_actuals <- final_data_with_actuals %>%
  left_join(error_summary %>% select(FileName, Replication, ErrorFlag),
            by = c("FileName" = "FileName", "Replication" = "Replication"))

```

#### Step 9: Part 3 Create Column Names from the Filename

```{r}
#| label: "create-columns2"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true


final_data_with_actuals <- final_data_with_actuals %>%
  mutate(
    Model = case_when(
      grepl("m1", FileName) ~ "1",
      grepl("m2", FileName) ~ "2",
      grepl("m3", FileName) ~ "3",
      TRUE ~ NA_character_
    ),
    N = case_when(
      grepl("n_5000", FileName) ~ 4,
      grepl("n_500", FileName) ~ 1,
      grepl("n_1000", FileName) ~ 2,
      grepl("n_2500", FileName) ~ 3,
      TRUE ~ NA_integer_
    ),
    Mixing_proportion = case_when(
      grepl("m_1", FileName) ~ 1,
      grepl("m_2", FileName) ~ 2,
      TRUE ~ NA_integer_
    ),
    Population = case_when(
      grepl("tp_0.407", FileName) ~ "0.200",
      grepl("tp_3.179", FileName) ~ "0.800",
      TRUE ~ NA_character_
    ),
    Lambda_values = case_when(
      grepl("l_0\\.5$", FileName) ~ "0.5",
      grepl("l_1\\.5$", FileName) ~ "1.5",
      grepl("l_3$", FileName) ~ "3",
      grepl("l_x$", FileName) ~ "X",
      grepl("l_y$", FileName) ~ "Y",
      grepl("l_z$", FileName) ~ "Z",
      TRUE ~ NA_character_
    )
  ) %>%
  mutate(
    Model = factor(Model, levels = c(1, 2, 3), labels = c("Model 1", "Model 2", "Model 3")),
    N = factor(N, levels = c(1, 2, 3, 4), labels = c("N = 500", "N = 1000", "N = 2500", "N = 5000")),
    Mixing_proportion = factor(Mixing_proportion, levels = c(1, 2), labels = c("Even Proportions", "Uneven Proportions")),
    Population = factor(Population, levels = c("0.200", "0.800"), labels = c(".200", ".800"))
  )
```

#### Step 9: Part 4 Calculate Violation Percentages per Condition

```{r}

#| label: "calculate-violations2"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# 1. Summarize violations per condition
violation_summary <- final_data_with_actuals %>%
  mutate(
    Any_Violation = ifelse(is.na(Any_Violation), 0, Any_Violation),
    ErrorFlag = ifelse(is.na(ErrorFlag), 0, ErrorFlag)  # Ensure no missing values for ErrorFlag
  ) %>%
  group_by(FileName, Model, Population, N, Mixing_proportion, Lambda_values) %>%
  summarize(
    Total_Rows = n(),                                # Total runs
    Total_Violations = sum(Any_Violation, na.rm = TRUE), # Total violations
    Total_Errors = sum(ErrorFlag, na.rm = TRUE),         # Total errors from ErrorFlag
    Percentage_Violations = (Total_Violations / Total_Rows) * 100, # % violations
    .groups = "drop"
  ) %>%
  # 2. Calculate Replications Needed for label switching
  mutate(
    N_numeric = as.numeric(gsub("N = ", "", as.character(N))), 
    Additional_Runs = (500 + Total_Violations) * (Percentage_Violations / 100), 
    Replications_Needed = ceiling(500 + Total_Violations + Additional_Runs + 20),
    Replications_Needed = if_else(Replications_Needed < 500, 500, Replications_Needed),
    ErrorRate = Total_Errors / Total_Rows,  # Calculate ErrorRate directly
    Adjusted_Replications_Needed = ceiling(Replications_Needed / (1 - ErrorRate)),
    Adjusted_Replications_Needed = if_else(Adjusted_Replications_Needed < 500, 500, Adjusted_Replications_Needed)
  ) %>%
  select(
    FileName, Model, Population, N, N_numeric, Mixing_proportion,
    Lambda_values, Total_Rows, Total_Violations, Total_Errors,
    ErrorRate, Percentage_Violations
  )

```

#### Step 9: Part 5 Summarize & Visualize Label Switching Percentage Results

```{r}
#| label: "summarize-final-errors-violators"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Update violation_summary to include TPs, Mix, and adjusted replications
violation_summary <- violation_summary %>%
  mutate(
    # Transition Probabilities based on Population
    TPs = case_when(
      Population == ".800" ~ 3.179,
      Population == ".200" ~ 0.407,
      TRUE ~ NA_real_
    ),
    
    # Numeric Mix column
    Mix = case_when(
      Mixing_proportion == "Even Proportions" ~ 1,
      Mixing_proportion == "Uneven Proportions" ~ 2,
      TRUE ~ NA_integer_
    )
  )

# Function to create datasets based on model and lambda values
create_combined_model_data <- function(data, model, lambda_values) {
  data %>%
    filter(Model == model, Lambda_values %in% lambda_values) %>%
    select(
      `Transition Probability` = Popuation,             
      TPs,                                    # Numeric transition probabilities
      N,                                      # Categorical sample size
      N_numeric,                              # Numeric sample size
      `Mixing Proportion` = Mixing_proportion, # Even/Uneven proportions
      Mix,                                    # Numeric mix column
      Lambda = Lambda_values,                 # Lambda column
      `Total Mplus Runs` = Total_Rows,        # Total rows
      `Total Violations` = Total_Violations,  # Total Violations
      `% of Violations` = Percentage_Violations, # Violation percentage
      `Total Errors` = Total_Errors,           #Total Eerrors
      `Error Rate` = ErrorRate
    )
}

# Datasets with multiple lambdas (0.5, 1.5, and 3)
model1_data <- create_combined_model_data(violation_summary, "Model 1", c("0.5", "1.5", "3"))
model2_data <- create_combined_model_data(violation_summary, "Model 2", c("0.5", "1.5", "3"))
model3_data <- create_combined_model_data(violation_summary, "Model 3", c("0.5", "1.5", "3"))

# Datasets with single lambdas (X, Y, and Z)
model4_data <- create_combined_model_data(violation_summary, "Model 1", c("X"))
model5_data <- create_combined_model_data(violation_summary, "Model 1", c("Y"))
model6_data <- create_combined_model_data(violation_summary, "Model 1", c("Z"))

model7_data <- create_combined_model_data(violation_summary, "Model 2", c("X"))
model8_data <- create_combined_model_data(violation_summary, "Model 2", c("Y"))
model9_data <- create_combined_model_data(violation_summary, "Model 2", c("Z"))

model10_data <- create_combined_model_data(violation_summary, "Model 3", c("X"))
model11_data <- create_combined_model_data(violation_summary, "Model 3", c("Y"))
model12_data <- create_combined_model_data(violation_summary, "Model 3", c("Z"))

create_gt_table <- function(data, model, Lambda) {
  data %>%
    gt() %>%
    tab_header(
      title = paste(model, ": Monte Carlo Results"),
      subtitle = paste("Lambda =", paste(Lambda, collapse = ", "), "- Label Switching and Errors Adjusted")
    ) %>%
    fmt_number(
      columns = c(`% of Violations`, `Error Rate`),
      decimals = 2
    ) %>%
    cols_align(align = "center", columns = everything()) %>%
    tab_options(
      table.font.size = "small",
      heading.title.font.size = "medium",
      heading.subtitle.font.size = "small"
    ) %>%
    tab_style(style = cell_text(align = "center"), locations = cells_column_labels(everything()))
}

# Generate tables for each model
model1_table <- create_gt_table(model1_data, "Model 1", c("0.5", "1.5", "3"))
model2_table <- create_gt_table(model2_data, "Model 2", c("0.5", "1.5", "3"))
model3_table <- create_gt_table(model3_data, "Model 3", c("0.5", "1.5", "3"))

model4_table <- create_gt_table(model4_data, "Model 1", c("X"))
model5_table <- create_gt_table(model5_data, "Model 1", c("Y"))
model6_table <- create_gt_table(model6_data, "Model 1", c("Z"))

model7_table <- create_gt_table(model7_data, "Model 2", c("X"))
model8_table <- create_gt_table(model8_data, "Model 2", c("Y"))
model9_table <- create_gt_table(model9_data, "Model 2", c("Z"))

model10_table <- create_gt_table(model10_data, "Model 3", c("X"))
model11_table <- create_gt_table(model11_data, "Model 3", c("Y"))
model12_table <- create_gt_table(model12_data, "Model 3", c("Z"))

# Print tables
model1_table
model2_table
model3_table
model4_table
model5_table
model6_table
model7_table
model8_table
model9_table
model10_table
model11_table
model12_table
```

### **Step 10: Delete Cases that Violate**

#### **Objective**

*Filter out cases with any violations, leaving only the clean data.*

```{r}
#| label: "delete-cases"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Filter out cases with no violations and no errors
filtered_data_with_no_violations <- final_data_with_actuals[
  final_data_with_actuals$Any_Violation == 0 & final_data_with_actuals$ErrorFlag == 0, ]
```

### Step 10: Part 1

Take random sample of replications to achieve n = 500

```{r}
#| label: "Select-random-sample-replications"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true


# Set seed for reproducibility
set.seed(07252005)

# Group data by FileName and sample 500 rows per condition (if possible)
cleaned_data <- filtered_data_with_no_violations %>%
  group_by(FileName) %>%
  slice_sample(n = 500, replace = FALSE) %>%  # Randomly sample 500 rows (without replacement)
  ungroup()

# Verify the number of rows per condition
condition_counts <- cleaned_data %>%
  group_by(FileName) %>%
  summarize(Count = n(), .groups = "drop")

# Print conditions with more or less than 500 rows (sanity check)
sanity_check <- condition_counts %>%
  filter(Count != 500)

if (nrow(sanity_check) > 0) {
  warning("Some conditions do not have exactly 500 rows. Please verify the data and ensure extra replications are sufficient.")
  print(sanity_check)
} else {
  message("All conditions have exactly 500 rows.")
}
```

### **Step 8: Compute Monte Carlo (MC) Values**

#### **Objective**

*Calculate Monte Carlo values for `TRANS11`, including population values, averages, standard errors, Mean Squared Error (MSE), coverage, and power.*

```{r}
#| label: "compute-mc-values"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true


# First, convert Population back to numeric if it's a factor
cleaned_data <- cleaned_data %>%
  mutate(Population = as.numeric(as.character(Population)))

# Calculate the Monte Carlo values, including Mixing_proportion, Model_Type, N, 
# population (transition probability), number of replications, and averages for TRANS11 and SE11
mc_values <- cleaned_data %>%
  group_by(FileName, Population, Mixing_proportion, Model, N) %>%  # Group by FileName, Population, Mixing_proportion, Model_Type, and N
  summarize(
    average = round(mean(TRANS11, na.rm = TRUE), 3),
    average_SE = round(mean(SE_11, na.rm = TRUE), 3),
    population_sd = round(sd(TRANS11, na.rm = TRUE), 3),
    
    # MSE calculation: mean squared error between TRANS11 and Population
    MSE = round(mean((TRANS11 - Population)^2, na.rm = TRUE), 3),
    
    # Coverage calculation: check if Population lies within the confidence interval
    Coverage = round(mean((Population >= (TRANS11 - 1.96 * SE_11)) & (Population <= (TRANS11 + 1.96 * SE_11)), na.rm = TRUE), 3),
    
    # Power calculation: proportion of cases where TRANS11 is significant
    Power = round(mean(TRANS11 / SE_11 > 1.96, na.rm = TRUE), 3),
    
    # Reps_Used counts the number of replications (rows) used for each FileName
    Reps_Used = n()
  )

# Round the values to 3 decimal points
mc_values <- mc_values %>%
  mutate(across(starts_with("Avg_"), ~ round(.x, 3)))

```

### **Step 9: Calculate Dichotomous Variables and Bias**

#### **Objective**

*Calculate dichotomous variables for Power and Coverage, compute Parameter and SE Bias, and prepare subsets for movers and stayers.*

```{r}
#| label: "calculate-bias-dichotomous-variables"
#| echo: true
#| message: true
#| warning: true
#| code-fold: true

# Step 1: Calculate dichotomous variable for Power (1 if Power >= 0.8, else 0)
mc_values <- mc_values %>%
  mutate(Power_Dic = ifelse(Power >= 0.8, 1, 0))

# Step 2: Calculate dichotomous variable for Coverage (0 if outside [0.91, 0.98], else 1)
mc_values <- mc_values %>%
  mutate(Coverage_Dic = ifelse(Coverage > 0.98 | Coverage < 0.91, 0, 1))

# Step 3: Remove any groupings before further calculations
mc_values <- mc_values %>%
  ungroup()

# Step 4: Ensure numeric columns are correctly formatted
mc_values <- mc_values %>%
  mutate(
    average = as.numeric(average),
    Population = as.numeric(Population),  # Ensure 'population' is numeric
    average_se = as.numeric(average_SE),
    population_sd = as.numeric(population_sd)
  )

# Step 5: Calculate Parameter Bias and SE Bias, rounding the results to 2 decimal places
mc_values <- mc_values %>%
  mutate(
    Parameter_Bias = (average - Population) / Population * 100,  # Bias for the parameter
    SE_Bias = (average_se - population_sd) / population_sd * 100  # Bias for the standard error
  ) %>%
  mutate(across(c(Parameter_Bias, SE_Bias), ~ round(.x, 2)))  # Round to 2 decimal places

```

### **Step 10: Subset Data for Movers and Stayers**

#### **Objective**

*Subset the Monte Carlo values data for transitions with movers and stayers based on the population value.*

```{r}
# Subset for population 0.2
subset_0.2 <- subset(mc_values, Population == 0.2)

# Subset for population 0.8
subset_0.8 <- subset(mc_values, Population == 0.8)

```

### **Step 11: Combined Plot for Mover and Stayer**

#### **Objective**

*Create streamlined plots for both mover and stayer subsets using a common theme and labels.*

```{r}
#| label: "bias-plots"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Step 1: Define a custom theme (used for both plots)
common_theme <- theme_minimal() +
  theme(
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank(),
    panel.grid.major.y = element_line(color = "gray", linewidth = 0.2),  # Major y-axis lines
    panel.grid.minor.y = element_blank(),
    axis.text.x = element_text(size = 8, color = "black"),  # Style for x-axis text
    axis.ticks = element_line(color = "black", size = 0.6),
    legend.position = "bottom",
    legend.title = element_blank(),
    text = element_text(family = "Times New Roman"),
    axis.title.x = element_text(margin = margin(t = 10, b = 10)),
    legend.margin = margin(t = -10),
    plot.caption = element_text(hjust = 0, margin = margin(t = 10))
  )

# Step 2: Define common labels function
common_labels <- function(title) {
  labs(
    x = "Sample Size",  
    y = "Bias (%)",
    color = "",
    title = title
  )
}

# Step 3: Create the plot function using the common theme and labels
create_bias_plot <- function(data, title, ylim_range) {
  
  # Identify which legends are present in the data
  present_categories <- c("Parameter Bias", "Standard Error Bias")
  if (any(data$Coverage_Dic == 0)) present_categories <- c(present_categories, "Coverage Failure")
  if (any(data$Power_Dic == 0)) present_categories <- c(present_categories, "Power Failure")
  
  # Define colors and shapes
  colors <- c("Parameter Bias" = "#7030A0", "Standard Error Bias" = "#C830CC", 
              "Coverage Failure" = "#7030A0", "Power Failure" = "black")
  shapes <- c("Parameter Bias" = 16, "Standard Error Bias" = 18, 
              "Coverage Failure" = 1, "Power Failure" = 4)
  
  # Filter the colors and shapes based on present categories
  filtered_colors <- colors[present_categories]
  filtered_shapes <- shapes[present_categories]
  
  ggplot(data, aes(x = factor(N))) +  
    geom_line(aes(y = Parameter_Bias, color = "Parameter Bias", group = Model), linewidth = 0.5, linetype = "solid") +  
    geom_line(aes(y = SE_Bias, color = "Standard Error Bias", group = Model), linewidth = 0.5, linetype = "solid") +  
    geom_point(aes(y = Parameter_Bias, color = "Parameter Bias"), shape = 16, size = 1.7, fill = "#7030A0", alpha = 1) +  
    geom_point(aes(y = SE_Bias, color = "Standard Error Bias"), shape = 18, size = 2.5, fill = "#C830CC", alpha = 1) +  
    geom_point(data = subset(data, Coverage_Dic == 0), aes(y = Parameter_Bias, color = "Coverage Failure"), shape = 1, size = 3, fill = "#7030A0", alpha = 1) +  
    geom_point(data = subset(data, Power_Dic == 0), aes(y = Parameter_Bias, color = "Power Failure"), shape = 4, size = 3, fill = "black", alpha = 1) +  
    scale_color_manual(
      values = filtered_colors, 
      labels = present_categories, 
      breaks = present_categories,
      guide = guide_legend(
        override.aes = list(
          shape = filtered_shapes
        )
      )
    ) +  
    common_labels(title) +  # Using the common labels function
    coord_cartesian(ylim = ylim_range) +  
    facet_grid(Mixing_proportion ~ Model, scales = "free", space = "free_y") + 
    scale_x_discrete(labels = c(expression(italic("N") ~ " = 500"), expression(italic("N") ~ " = 1000"), expression(italic("N") ~ " = 2500"), expression(italic("N") ~ " = 5000"))) +  
    scale_y_continuous(breaks = seq(ylim_range[1], ylim_range[2], by = 20)) +  # Change break intervals to 20
    common_theme +  # Apply the common theme
    theme(
      legend.position = "bottom", 
      strip.placement = "top",  # Move facet labels to the top
      strip.background = element_blank(),
      panel.spacing = unit(0.5, "lines"),
      axis.text.x = element_text(angle = 45, hjust = 1, size = 8),  # Rotate x-axis labels for readability
      plot.margin = margin(r = 20)  # Add margin to the right side
    ) +
    geom_hline(yintercept = c(-10, 10), linetype = "dashed", color = "#7030A0", linewidth = 0.3) +  
    geom_hline(yintercept = c(-5, 5), linetype = "dashed", color = "#C830CC", linewidth = 0.3)
}

# Plot for movers (population = 0.2)
plot_mover <- create_bias_plot(subset_0.2, "LTA Generated / LTA Analyzed with Mover Transition Probabilities", c(-80, 80))
print(plot_mover)

# Plot for stayers (population = 0.8)
plot_stayer <- create_bias_plot(subset_0.8, "LTA Generated / LTA Analyzed with Stationary Transition Probabilities", c(-80, 80))
print(plot_stayer)

```

### **Step 12: Prepare Data for Heatmaps**

#### **Objective**

*Prepare data for heatmap creation by ensuring correct formatting for population values, and subsetting the data based on class proportions and sample sizes.*

```{r}
#| label: "prepare-data-for-heatmaps"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Step 1: Ensure N is treated as a factor with the correct levels in order 
# No need to create N_Label; N is already a factor with correct labels
# Step 2: Order heatmap_data by population, Mixing_proportion, Model, and N
# Convert 'Population' into a factor with proper levels
heatmap_data <- mc_values %>%
  mutate(Population = factor(Population, levels = c(0.2, 0.8), labels = c(".200", ".800"))) %>%
  arrange(Population, Mixing_proportion, Model, N)


# Step 3: Create subsets for each combination of population and class proportions
subset_0.2_even_proportions <- subset(heatmap_data, Population == ".200" & Mixing_proportion == "Even Proportions",
                                       select = c(N, average, Coverage, Power, Parameter_Bias, SE_Bias))

subset_0.2_uneven_proportions <- subset(heatmap_data, Population == ".200" & Mixing_proportion == "Uneven Proportions",
                                         select = c(N, average, Coverage, Power, Parameter_Bias, SE_Bias))

subset_0.8_even_proportions <- subset(heatmap_data, Population == ".800" & Mixing_proportion == "Even Proportions",
                                       select = c(N, average, Coverage, Power, Parameter_Bias, SE_Bias))

subset_0.8_uneven_proportions <- subset(heatmap_data, Population == ".800" & Mixing_proportion == "Uneven Proportions",
                                         select = c(N, average, Coverage, Power, Parameter_Bias, SE_Bias))

# Step 4: Store subsets in a list for easier access and management
subset_list <- list(
  subset_0.2_even_proportions = subset_0.2_even_proportions,
  subset_0.2_uneven_proportions = subset_0.2_uneven_proportions,
  subset_0.8_even_proportions = subset_0.8_even_proportions,
  subset_0.8_uneven_proportions = subset_0.8_uneven_proportions
)

```

### **Step 13: Heatmap Creation and Rendering**

#### **Objective**

*Create heatmaps using the `gt` package and render each table separately for different subsets of the data.*

```{r}
#| label: "create-heatmap-function"
#| echo: true
#| message: false
#| warning: false
#| code-fold: true


# Function to create the gt heatmap table
create_table <- function(subset, transition_probability) {
  
  # Step 2: Create the gt object and set initial formatting
  gt_table <- subset %>%
    gt() %>%
    opt_table_font(stack = "geometric-humanist") %>%
    tab_header(
      title = paste("LTA Generated & RILTA Analyzed with Transition Probability of", transition_probability)
    ) %>%
    cols_label(
      N = "Sample Size",  # This will now use the ordered N values
      average = "Estimated<br>Probability",
      Coverage = "Coverage",
      Power = "Power",
      Parameter_Bias = "Parameter<br>Bias",
      SE_Bias = "Standard Error<br>Bias",
      .fn = md
    ) %>%
    tab_spanner(
      label = "Bias",
      columns = c("Parameter_Bias", "SE_Bias")
    ) %>%
    tab_row_group(label = "Model 3", rows = 9:12) %>%
    tab_row_group(label = "Model 2", rows = 5:8) %>%
    tab_row_group(label = "Model 1", rows = 1:4) %>%
    tab_style(
      style = cell_text(font = "bold italic"),  # Bold and italic styling for row subheaders
      locations = cells_row_groups()
    ) %>% 
    fmt_number(columns = c("Parameter_Bias", "SE_Bias"), decimals = 2) %>%
    fmt_number(columns = 4, decimals = 3) %>%
    tab_options(
      table_body.hlines.color = "white",
      table.border.top.color = "black",
      table.border.bottom.color = "black",
      heading.border.bottom.color = "black",
      column_labels.border.top.color = "black",
      column_labels.border.bottom.color = "black",
      row_group.border.top.color = "black",
      row_group.border.bottom.color = "black"
    ) %>%
    cols_align(align = "center", columns = everything())

  # Apply color highlighting for violations in Parameter Bias
  if (any(!(subset$Parameter_Bias >= -9.99 & subset$Parameter_Bias <= 9.99), na.rm = TRUE)) {
    gt_table <- gt_table %>%
      data_color(
        columns = "Parameter_Bias",
        rows = .data$Parameter_Bias < -9.99 | .data$Parameter_Bias > 9.99,  # Apply color only if outside the threshold
        method = "numeric",
        palette = c("#113386", "#DAE3FA", "#113386"),  # Darker blue for larger deviations
        domain = c(-40, 40)  # Adjust the domain to reflect the range of values
      ) %>%
      tab_footnote(
        footnote = md("Darker blue indicates larger deviations from zero *Parameter Bias* beyond the ±9.99 threshold."),
        locations = cells_column_labels(columns = "Parameter_Bias")
      )
  }

  # Apply color highlighting for violations in SE Bias
  if (any(!(subset$SE_Bias >= -4.99 & subset$SE_Bias <= 4.99), na.rm = TRUE)) {
    gt_table <- gt_table %>%
      data_color(
        columns = "SE_Bias",
        rows = .data$SE_Bias < -4.99 | .data$SE_Bias > 4.99,  # Apply color only if outside the threshold
        method = "numeric",
        palette = c("#B4186E", "#F9D5E9", "#B4186E"),  # Darker red for larger deviations
        domain = c(-80, 80)  # Adjust the domain for the SE_Bias range
      ) %>%
      tab_footnote(
        footnote = md("Darker red indicates larger deviations from zero *Standard Error Bias* beyond the ±4.99 threshold."),
        locations = cells_column_labels(columns = "SE_Bias")
      )
  }

  if (any(subset$Coverage < 0.93 | subset$Coverage > 0.979, na.rm = TRUE)) {
    gt_table <- gt_table %>%
      data_color(
        columns = "Coverage",
        rows = subset$Coverage < 0.93 | subset$Coverage > 0.979,
        method = "numeric",
        palette = c("#93C6B1", "white"),  # Green for coverage issues
        domain = c(0, 1)
      ) %>%
      tab_footnote(
        footnote = md("Green indicates failure to achieve adequate *Coverage*."),
        locations = cells_column_labels(columns = "Coverage")
      )
  }

  if (any(subset$Power < 0.8, na.rm = TRUE)) {
    gt_table <- gt_table %>%
      data_color(
        columns = "Power",
        rows = subset$Power < 0.8,
        method = "numeric",
        palette = c("#502CD1", "white"),  # Purple for power issues
        domain = c(0, 1)
      ) %>%
      tab_footnote(
        footnote = md("Purple indicates failure to achieve adequate *Power*."),
        locations = cells_column_labels(columns = "Power")
      )
  }

  return(gt_table)
}

```

### Step 14: Print Heatmaps

```{r}
subset_02_table_even_proportions <- create_table(subset_0.2_even_proportions, ".200, Even Mixing Proportions")

subset_02_table_even_proportions

subset_02_table_even_proportions |> tab_options(table.width = pct(55)) |> gtsave(here('Simulations', 'STUDY_2', 'zHeatmaps', 'z2t_lta_rilta_tables', '2T_L_R_.200_Even_Proportions.png'), expand = 8)
```

```{r}
subset_0.2_table_uneven_proportions <- create_table(subset_0.2_uneven_proportions, ".200, Uneven Mixing Proportions")
subset_0.2_table_uneven_proportions
subset_0.2_table_uneven_proportions |> tab_options(table.width = pct(55)) |> gtsave(here('Simulations', 'STUDY_2', 'zHeatmaps', 'z2t_lta_rilta_tables','2T_L_R_.200_Uneven Proportions.png'), expand = 8)
```

```{r}
subset_0.8_table_even_proportions <- create_table(subset_0.8_even_proportions, ".800, Even Mixing Proportions")
subset_0.8_table_even_proportions
subset_0.8_table_even_proportions |> tab_options(table.width = pct(55)) |> gtsave(here('Simulations', 'STUDY_2', 'zHeatmaps', 'z2t_lta_rilta_tables', '2T_L_R_.800_Even_Proportions.png'), expand = 8)
```

```{r}
subset_0.8_table_uneven_proportions <- create_table(subset_0.8_uneven_proportions, ".800, Uneven Mixing Proportions")

subset_0.8_table_uneven_proportions

subset_0.8_table_uneven_proportions |> tab_options(table.width = pct(55)) |> gtsave(here('Simulations', 'STUDY_2', 'zHeatmaps', 'z2t_rilta_rilta_tables', '2T_L_R_.800_Uneven Proportions.png'), expand = 8)
```
